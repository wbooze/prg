diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/auxfns.lisp norvig-paip-pjb/auxfns.lisp
--- norvig/auxfns.lisp	2002-04-09 21:18:14.000000000 +0200
+++ norvig-paip-pjb/auxfns.lisp	2012-06-20 11:05:46.000000000 +0200
@@ -1,152 +1,51 @@
-;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
-;;; Code from Paradigms of AI Programming
-;;; Copyright (c) 1991 Peter Norvig
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+;;;; File auxfns.lisp: Auxiliary functions used by all other programs
+;;;; Load this file after auxmacs, but before running any other programs.
+
+(proclaim '(inline mappend mklist flatten random-elt member-equal
+                   starts-with compose last1 length=1
+                   rest2 rest3 simbol old-symbol reuse-cons
+                   queue-contents make-queue enqueue dequeue
+                   front empty-queue-p queue-nconc))
+
+#-(or common-lisp CLtL2 clisp)
+(proclaim '(inline reduce))
+#+common-lisp
+(declaim (inline reduce*))
 
-;;; File auxfns.lisp: Auxiliary functions used by all other programs
-;;; Load this file before running any other programs.
+;;; The function REQUIRES is used in subsequent files to state dependencies
+;;; between files.  The current definition just loads the required files,
+;;; assumming they match the pathname specified in *PAIP-source-files*.
+;;; You should change that to match where you have stored the files.
+;;; A more sophisticated REQUIRES would only load it if it has not yet
+;;; been loaded, and would search in different directories if needed.
 
-;;;; Implementation-Specific Details
+;;; First set up read macros for #P"pathname", if they are missing.
 
+#-(or common-lisp CLtL2 clisp)
 (eval-when (eval compile load)
-  ;; Make it ok to place a function definition on a built-in LISP symbol.
-  #+(or Allegro EXCL)
-  (dolist (pkg '(excl common-lisp common-lisp-user))
-    (setf (excl:package-definition-lock (find-package pkg)) nil))
-
-  ;; Don't warn if a function is defined in multiple files --
-  ;; this happens often since we refine several programs.
-  #+Lispworks
-  (setq *PACKAGES-FOR-WARN-ON-REDEFINITION* nil)
+  (defun read-pathname (stream char arg-count)
+    (declare (ignore char arg-count))
+    (parse-namestring
+     (read-preserving-whitespace stream t nil t)))
 
-  #+LCL 
-   (compiler-options :warnings nil)
+  (set-dispatch-macro-character #\# #\P #'read-pathname)
+  (set-dispatch-macro-character #\# #\p #'read-pathname)
   )
 
-;;;; REQUIRES
-
-;;; The function REQUIRES is used in subsequent files to state dependencies
-;;; between files.  The current definition just loads the required files,
-;;; assumming they match the pathname specified in *PAIP-DIRECTORY*.
-;;; You should change that to match where you have stored the files.
-;;; A more sophisticated REQUIRES would only load it if it has not yet
-;;; been loaded, and would search in different directories if needed.
+(defvar *PAIP-source-files* #P"*.lisp"
+  "The location of the source files for this book.
+  CHANGE IT TO REFLECT THE LOCATION OF THE FILES ON YOUR COMPUTER.")
 
 (defun requires (&rest files)
   "The arguments are files that are required to run an application."
-  (mapc #'load-paip-file files))
+  (let ((*default-pathname-defaults* *paip-source-files*))
+    (mapc #'load files)))
 
-(defvar *paip-files*
-  `("auxfns" "tutor" "examples" 
-    "intro" "simple" "overview" "gps1" "gps" "eliza1" "eliza" "patmatch" 
-    "eliza-pm" "search" "gps-srch" "student" "macsyma" "macsymar" "unify" 
-    "prolog1" "prolog" "prologc1" "prologc2" "prologc" "prologcp" 
-    "clos" "krep1" "krep2" "krep" "cmacsyma" "mycin" "mycin-r" "waltz" 
-    "othello" "othello2" "syntax1" "syntax2" "syntax3" "unifgram" 
-    "grammar" "lexicon" "interp1" "interp2" "interp3" 
-    "compile1" "compile2" "compile3" "compopt"))
-
-(defparameter *paip-directory*
-  (make-pathname :name nil :type nil
-		 :defaults (or (and (boundp '*load-truename*) *load-truename*)
-			       (truename ""))) ;;??? Maybe Change this
-  "The location of the source files for this book.  If things don't work,
-  change it to reflect the location of the files on your computer.")
-
-(defparameter *paip-source* 
-  (make-pathname :name nil :type "lisp" ;;???  Maybe Change this
-		 :defaults *paip-directory*)) 
-
-(defparameter *paip-binary*
-  (make-pathname
-   :name nil
-   :type (first (list #+LCL (first *load-binary-pathname-types*)
-		      #+Lispworks system::*binary-file-type*
-		      #+MCL "fasl"
-		      #+Allegro excl:*fasl-default-type*
-		      #+(or AKCL KCL) "o"
-		      #+CMU "sparcf"
-		      #+CLISP "fas"
-		      "bin"))  ;;???  Maybe Change this
-   :directory (append (pathname-directory *paip-source*) '("bin"))
-   :defaults *paip-directory*))
-
-(defun paip-pathname (name &optional (type :lisp))
-  (make-pathname :name name 
-		 :defaults (ecase type
-			     ((:lisp :source) *paip-source*)
-			     ((:binary :bin) *paip-binary*))))
-
-(defun compile-all-paip-files ()
-  (mapc #'compile-paip-file *paip-files*))
-
-(defun compile-paip-file (name)
-  (let ((path (paip-pathname name :lisp)))
-    (load path)
-    (compile-file path :output-file (paip-pathname name :binary))))
-
-(defun load-paip-file (file)
-  "Load the binary file if it exists and is newer, else load the source."
-  (let* ((src (paip-pathname file :lisp))
-	 (src-date (file-write-date src))
-	 (bin (paip-pathname file :binary))
-	 (bin-date (file-write-date bin)))
-    (load (if (and (probe-file bin) src-date bin-date (>= bin-date src-date))
-	      bin
-	    src))))
-
-;;;; Macros (formerly in auxmacs.lisp: that file no longer needed)
-
-(eval-when (load eval compile)
-  (defmacro once-only (variables &rest body)
-    "Returns the code built by BODY.  If any of VARIABLES
-  might have side effects, they are evaluated once and stored
-  in temporary variables that are then passed to BODY."
-    (assert (every #'symbolp variables))
-    (let ((temps nil))
-      (dotimes (i (length variables)) (push (gensym) temps))
-      `(if (every #'side-effect-free? (list .,variables))
-	(progn .,body)
-	(list 'let
-	 ,`(list ,@(mapcar #'(lambda (tmp var)
-			       `(list ',tmp ,var))
-			   temps variables))
-	 (let ,(mapcar #'(lambda (var tmp) `(,var ',tmp))
-		       variables temps)
-	   .,body)))))
-
-  (defun side-effect-free? (exp)
-    "Is exp a constant, variable, or function,
-  or of the form (THE type x) where x is side-effect-free?"
-    (or (atom exp) (constantp exp)
-	(starts-with exp 'function)
-	(and (starts-with exp 'the)
-	     (side-effect-free? (third exp)))))
-
-  (defmacro funcall-if (fn arg)
-    (once-only (fn)
-	       `(if ,fn (funcall ,fn ,arg) ,arg)))
-
-  (defmacro read-time-case (first-case &rest other-cases)
-    "Do the first case, where normally cases are
-  specified with #+ or possibly #- marks."
-    (declare (ignore other-cases))
-    first-case)
-
-  (defun rest2 (x)
-    "The rest of a list after the first TWO elements."
-    (rest (rest x)))
-
-  (defun find-anywhere (item tree)
-    "Does item occur anywhere in tree?"
-    (if (atom tree)
-	(if (eql item tree) tree)
-	(or (find-anywhere item (first tree))
-	    (find-anywhere item (rest tree)))))
-
-  (defun starts-with (list x)
-    "Is x a list whose first element is x?"
-    (and (consp list) (eql (first list) x)))
-  )
+;; (mapc (lambda (file) (load  (merge-pathnames file *paip-source-files*))) files)))
 
 ;;;; Auxiliary Functions
 
@@ -183,6 +82,50 @@
 
 ;;; ==============================
 
+#-(or common-lisp CLtL2 clisp)
+(defun map-into (result-sequence function &rest sequences)
+  "Destructively set elements of RESULT-SEQUENCE to the results
+  of applying FUNCTION to respective elements of SEQUENCES."
+  (let ((arglist (make-list (length sequences)))
+        (n (if (listp result-sequence)
+               most-positive-fixnum
+               (array-dimension result-sequence 0))))
+    ;; arglist is made into a list of args for each call
+    ;; n is the length of the longest vector
+    (when sequences
+      (setf n (min n (loop for seq in sequences
+                           minimize (length seq)))))
+    ;; Define some shared functions:
+    (flet
+      ((do-one-call (i)
+         (loop for seq on sequences
+               for arg on arglist
+               do (if (listp (first seq))
+                      (setf (first arg)
+                            (pop (first seq)))
+                      (setf (first arg)
+                            (aref (first seq) i))))
+         (apply function arglist))
+       (do-result (i)
+         (if (and (vectorp result-sequence)
+                  (array-has-fill-pointer-p result-sequence))
+             (setf (fill-pointer result-sequence) 
+                   (max i (fill-pointer result-sequence))))))
+      (declare (inline do-one-call))
+      ;; Decide if the result is a list or vector,
+      ;; and loop through each element
+      (if (listp result-sequence)
+          (loop for i from 0 to (- n 1)
+                for r on result-sequence
+                do (setf (first r)
+                         (do-one-call i))
+                finally (do-result i))
+          (loop for i from 0 to (- n 1)
+                do (setf (aref result-sequence i)
+                         (do-one-call i))
+                finally (do-result i))))
+      result-sequence))
+
 (defun seq-ref (seq index)
   "Return code that indexes into a sequence, using
   the pop-lists/aref-vectors strategy."
@@ -199,14 +142,122 @@
       (setf (fill-pointer array) 
             (max (fill-pointer array) new-length))))
 
+;;;; Reduce
+
+#-(or CLtL2)
+(defun reduce* (fn seq from-end start end key init init-p)
+  (funcall (if (listp seq) #'reduce-list #'reduce-vect)
+           fn seq from-end (or start 0) end key init init-p))
+
+#-(or common-lisp CLtL2 clisp)
+(defun reduce (function sequence &key from-end start end key
+               (initial-value nil initial-value-p))
+  (reduce* function sequence from-end start end
+           key initial-value initial-value-p))
+
+#-CLtL2
+(defun reduce-vect (fn seq from-end start end key init init-p)
+  (if (null end) (setf end (length seq)))
+  (assert (<= 0 start end (length seq)) (start end)
+          "Illegal subsequence of ~a --- :start ~d :end ~d"
+          seq start end)
+  (case (- end start)
+    (1 (if init-p
+           (funcall fn init (funcall-if key (aref seq start)))
+           (funcall-if key (aref seq start))))
+    (0 (if init-p init (funcall fn)))
+    (t (if (not from-end)
+           (let ((result
+                   (if init-p
+                       (funcall
+                         fn init
+                         (funcall-if key (aref seq start)))
+                       (funcall
+                         fn
+                         (funcall-if key (aref seq start))
+                         (funcall-if key (aref seq (+ start 1)))))))
+             (loop for i from (+ start (if init-p 1 2))
+                   to (- end 1)
+                   do (setf result
+                            (funcall
+                              fn result
+                              (funcall-if key (aref seq i)))))
+             result)
+           (let ((result
+                   (if init-p
+                       (funcall
+                         fn
+                         (funcall-if key (aref seq (- end 1)))
+                         init)
+                       (funcall
+                         fn
+                         (funcall-if key (aref seq (- end 2)))
+                         (funcall-if key (aref seq (- end 1)))))))
+             (loop for i from (- end (if init-p 2 3)) downto start
+                   do (setf result
+                            (funcall
+                              fn
+                              (funcall-if key (aref seq i))
+                              result)))
+             result)))))
+
+#-CLtL2
+(defun reduce-list (fn seq from-end start end key init init-p)
+  (if (null end) (setf end (length seq)))
+  (cond ((> start 0)
+         (reduce-list fn (nthcdr start seq) from-end 0
+                      (- end start) key init init-p))
+        ((or (null seq) (eql start end))
+         (if init-p init (funcall fn)))
+        ((= (- end start) 1)
+         (if init-p
+             (funcall fn init (funcall-if key (first seq)))
+             (funcall-if key (first seq))))
+        (from-end
+         (reduce-vect fn (coerce seq 'vector) t start end
+                      key init init-p))
+        ((null (rest seq))
+         (if init-p
+             (funcall fn init (funcall-if key (first seq)))
+             (funcall-if key (first seq))))
+        (t (let ((result
+                   (if init-p
+                       (funcall
+                         fn init
+                         (funcall-if key (pop seq)))
+                       (funcall
+                         fn
+                         (funcall-if key (pop seq))
+                         (funcall-if key (pop seq))))))
+             (if end
+                 (loop repeat (- end (if init-p 1 2)) while seq
+                    do (setf result
+                             (funcall
+                               fn result
+                               (funcall-if key (pop seq)))))
+                 (loop while seq
+                    do (setf result
+                             (funcall
+                               fn result
+                               (funcall-if key (pop seq))))))
+             result))))
+
 ;;; ==============================
 
+;;;; Other:
+
 ;;; NOTE: In ANSI Common Lisp, the effects of adding a definition (or most
 ;;; anything else) to a symbol in the common-lisp package is undefined.
-;;; Therefore, it would be best to rename the function SYMBOL to something 
-;;; else.  This has not been done (for compatibility with the book).  
+;;; Therefore, it would be best to rename the function symbol to something else.
+;;; This has not been done (for compatibility with the book).  The only near-ANSI
+;;; Lisp tested was Franz's Allegro EXCL, for which we allow the definition by
+;;; unlocking the excl and common-lisp packages with the following form:
+
+#+EXCL
+(dolist (pkg '(excl common-lisp))
+  (setf (package-lock-fdefinitions (find-package pkg)) nil))
 
-(defun symbol (&rest args)
+(defun simbol (&rest args)
   "Concatenate symbols or strings to form an interned symbol"
   (intern (format nil "~{~a~}" args)))
 
@@ -242,13 +293,7 @@
 (defun member-equal (item list)
   (member item list :test #'equal))
 
-;;; ==============================
-
-(defun compose (&rest functions)
-  #'(lambda (x)
-      (reduce #'funcall functions :from-end t :initial-value x)))
-
-;;;; The Debugging Output Facility:
+;;; The Debugging Output Facility:
 
 (defvar *dbg-ids* nil "Identifiers used by dbg")
 
@@ -258,7 +303,7 @@
     (fresh-line *debug-io*)
     (apply #'format *debug-io* format-string args)))
 
-(defun debug (&rest ids)
+(defun dodebug (&rest ids)
   "Start dbg output on the given ids."
   (setf *dbg-ids* (union ids *dbg-ids*)))
 
@@ -276,7 +321,7 @@
     (dotimes (i indent) (princ "  " *debug-io*))
     (apply #'format *debug-io* format-string args)))
 
-;;;; PATTERN MATCHING FACILITY
+;;; ==============================
 
 (defconstant fail nil)
 (defconstant no-bindings '((t . t)))
@@ -292,38 +337,14 @@
         (t fail)))
 
 (defun match-variable (var input bindings)
-  "Does VAR match input?  Uses (or updates) and returns bindings."
-  (let ((binding (get-binding var bindings)))
-    (cond ((not binding) (extend-bindings var input bindings))
-          ((equal input (binding-val binding)) bindings)
-          (t fail))))
-
-(defun make-binding (var val) (cons var val))
-
-(defun binding-var (binding)
-  "Get the variable part of a single binding."
-  (car binding))
-
-(defun binding-val (binding)
-  "Get the value part of a single binding."
-  (cdr binding))
-
-(defun get-binding (var bindings)
-  "Find a (variable . value) pair in a binding list."
-  (assoc var bindings))
-
-(defun lookup (var bindings)
-  "Get the value part (for var) from a binding list."
-  (binding-val (get-binding var bindings)))
-
-(defun extend-bindings (var val bindings)
-  "Add a (var . value) pair to a binding list."
-  (cons (cons var val)
-        ;; Once we add a "real" binding,
-        ;; we can get rid of the dummy no-bindings
-        (if (eq bindings no-bindings)
-            nil
-            bindings)))
+  "Match a single variable against input in the context of the bindings"
+  (if (get-binding var bindings)
+      (if (equal input (lookup var bindings)) bindings fail)
+      (extend-bindings var input bindings)))
+
+(defun get-binding (var bindings) (assoc var bindings))
+(defun lookup (var bindings) (rest (assoc var bindings)))
+(defun extend-bindings (var val bindings) (cons (cons var val) bindings)) 
 
 (defun variable-p (x)
   "Is x a variable (a symbol beginning with `?')?"
@@ -331,6 +352,17 @@
 
 ;;; ==============================
 
+(defun compose (&rest functions)
+  #'(lambda (x)
+      (reduce #'funcall functions :from-end t :initial-value x)))
+
+#-(or common-lisp CLtL2 clisp)
+(defun complement (fn)
+  "If FN returns y, then (complement FN) returns (not y)."
+  #'(lambda (&rest args) (not (apply fn args))))
+
+;;; ==============================
+
 ;;;; The Memoization facility:
 
 (defmacro defun-memo (fn args &body body)
@@ -361,7 +393,6 @@
     (when table (clrhash table))))
 
 ;;;; Delayed computation:
-
 (defstruct delay value (computed? nil))
 
 (defmacro delay (&rest body)
@@ -376,12 +407,11 @@
              (setf (delay-computed? delay) t))))
 
 ;;;; Defresource:
-
 (defmacro defresource (name &key constructor (initial-copies 0)
                        (size (max initial-copies 10)))
-  (let ((resource (symbol '* (symbol name '-resource*)))
-        (deallocate (symbol 'deallocate- name))
-        (allocate (symbol 'allocate- name)))
+  (let ((resource (simbol '* (symbol name '-resource*)))
+        (deallocate (simbol 'deallocate- name))
+        (allocate (simbol 'allocate- name)))
     `(progn
        (defparameter ,resource (make-array ,size :fill-pointer 0))
        (defun ,allocate ()
@@ -399,8 +429,8 @@
 
 (defmacro with-resource ((var resource &optional protect) &rest body)
   "Execute body with VAR bound to an instance of RESOURCE."
-  (let ((allocate (symbol 'allocate- resource))
-        (deallocate (symbol 'deallocate- resource)))
+  (let ((allocate (simbol 'allocate- resource))
+        (deallocate (simbol 'deallocate- resource)))
     (if protect
         `(let ((,var nil))
            (unwind-protect (progn (setf ,var (,allocate)) ,@body)
@@ -487,16 +517,29 @@
       (or (find-if-anywhere predicate (first tree))
           (find-if-anywhere predicate (rest tree)))))
 
+#-(or common-lisp CLtL2 clisp)
+(defmacro with-compilation-unit (options &body body)
+  "Do the body, but delay compiler warnings until the end."
+  ;; That way, undefined function warnings that are really
+  ;; just forward references will not be printed at all.
+  ;; This is defined in Common Lisp the Language, 2nd ed.
+  (declare (ignore options))
+  `(,(read-time-case
+       #+Lispm 'compiler:compiler-warnings-context-bind
+       #+Lucid 'with-deferred-warnings
+               'progn)
+    .,body))
+
 ;;; ==============================
 
 (defmacro define-enumerated-type (type &rest elements)
   "Represent an enumerated type with integers 0-n."
   `(progn
      (deftype ,type () '(integer 0 ,(- (length elements) 1)))
-     (defun ,(symbol type '->symbol) (,type)
+     (defun ,(simbol type '->symbol) (,type)
        (elt ',elements ,type))
-     (defun ,(symbol 'symbol-> type) (symbol)
-       (position symbol ',elements))
+     (defun ,(simbol 'symbol-> type) (symbol)
+       (position simbol ',elements))
      ,@(loop for element in elements
              for i from 0
              collect `(defconstant ,element ,i))))
@@ -515,174 +558,3 @@
 
 ;;; ==============================
 
-;;;; CLtL2 and ANSI CL Compatibility
-
-(unless (fboundp 'defmethod)
-(defmacro defmethod (name args &rest body)
-  `(defun ',name ',args ,@body))
-)
-
-(unless (fboundp 'map-into)
-(defun map-into (result-sequence function &rest sequences)
-  "Destructively set elements of RESULT-SEQUENCE to the results
-  of applying FUNCTION to respective elements of SEQUENCES."
-  (let ((arglist (make-list (length sequences)))
-        (n (if (listp result-sequence)
-               most-positive-fixnum
-               (array-dimension result-sequence 0))))
-    ;; arglist is made into a list of args for each call
-    ;; n is the length of the longest vector
-    (when sequences
-      (setf n (min n (loop for seq in sequences
-                           minimize (length seq)))))
-    ;; Define some shared functions:
-    (flet
-      ((do-one-call (i)
-         (loop for seq on sequences
-               for arg on arglist
-               do (if (listp (first seq))
-                      (setf (first arg)
-                            (pop (first seq)))
-                      (setf (first arg)
-                            (aref (first seq) i))))
-         (apply function arglist))
-       (do-result (i)
-         (if (and (vectorp result-sequence)
-                  (array-has-fill-pointer-p result-sequence))
-             (setf (fill-pointer result-sequence) 
-                   (max i (fill-pointer result-sequence))))))
-      (declare (inline do-one-call))
-      ;; Decide if the result is a list or vector,
-      ;; and loop through each element
-      (if (listp result-sequence)
-          (loop for i from 0 to (- n 1)
-                for r on result-sequence
-                do (setf (first r)
-                         (do-one-call i))
-                finally (do-result i))
-          (loop for i from 0 to (- n 1)
-                do (setf (aref result-sequence i)
-                         (do-one-call i))
-                finally (do-result i))))
-      result-sequence))
-
-)
-
-(unless (fboundp 'complement)
-(defun complement (fn)
-  "If FN returns y, then (complement FN) returns (not y)."
-  #'(lambda (&rest args) (not (apply fn args))))
-)
-
-(unless (fboundp 'with-compilation-unit)
-(defmacro with-compilation-unit (options &body body)
-  "Do the body, but delay compiler warnings until the end."
-  ;; That way, undefined function warnings that are really
-  ;; just forward references will not be printed at all.
-  ;; This is defined in Common Lisp the Language, 2nd ed.
-  (declare (ignore options))
-  `(,(read-time-case
-       #+Lispm 'compiler:compiler-warnings-context-bind
-       #+Lucid 'with-deferred-warnings
-               'progn)
-    .,body))
-)
-
-;;;; Reduce
-
-(when nil ;; Change this to T if you need REDUCE with :key keyword.
-
-(defun reduce* (fn seq from-end start end key init init-p)
-  (funcall (if (listp seq) #'reduce-list #'reduce-vect)
-           fn seq from-end (or start 0) end key init init-p))
-
-(defun reduce (function sequence &key from-end start end key
-               (initial-value nil initial-value-p))
-  (reduce* function sequence from-end start end
-           key initial-value initial-value-p))
-
-(defun reduce-vect (fn seq from-end start end key init init-p)
-  (if (null end) (setf end (length seq)))
-  (assert (<= 0 start end (length seq)) (start end)
-          "Illegal subsequence of ~a --- :start ~d :end ~d"
-          seq start end)
-  (case (- end start)
-    (1 (if init-p
-           (funcall fn init (funcall-if key (aref seq start)))
-           (funcall-if key (aref seq start))))
-    (0 (if init-p init (funcall fn)))
-    (t (if (not from-end)
-           (let ((result
-                   (if init-p
-                       (funcall
-                         fn init
-                         (funcall-if key (aref seq start)))
-                       (funcall
-                         fn
-                         (funcall-if key (aref seq start))
-                         (funcall-if key (aref seq (+ start 1)))))))
-             (loop for i from (+ start (if init-p 1 2))
-                   to (- end 1)
-                   do (setf result
-                            (funcall
-                              fn result
-                              (funcall-if key (aref seq i)))))
-             result)
-           (let ((result
-                   (if init-p
-                       (funcall
-                         fn
-                         (funcall-if key (aref seq (- end 1)))
-                         init)
-                       (funcall
-                         fn
-                         (funcall-if key (aref seq (- end 2)))
-                         (funcall-if key (aref seq (- end 1)))))))
-             (loop for i from (- end (if init-p 2 3)) downto start
-                   do (setf result
-                            (funcall
-                              fn
-                              (funcall-if key (aref seq i))
-                              result)))
-             result)))))
-
-(defun reduce-list (fn seq from-end start end key init init-p)
-  (if (null end) (setf end (length seq)))
-  (cond ((> start 0)
-         (reduce-list fn (nthcdr start seq) from-end 0
-                      (- end start) key init init-p))
-        ((or (null seq) (eql start end))
-         (if init-p init (funcall fn)))
-        ((= (- end start) 1)
-         (if init-p
-             (funcall fn init (funcall-if key (first seq)))
-             (funcall-if key (first seq))))
-        (from-end
-         (reduce-vect fn (coerce seq 'vector) t start end
-                      key init init-p))
-        ((null (rest seq))
-         (if init-p
-             (funcall fn init (funcall-if key (first seq)))
-             (funcall-if key (first seq))))
-        (t (let ((result
-                   (if init-p
-                       (funcall
-                         fn init
-                         (funcall-if key (pop seq)))
-                       (funcall
-                         fn
-                         (funcall-if key (pop seq))
-                         (funcall-if key (pop seq))))))
-             (if end
-                 (loop repeat (- end (if init-p 1 2)) while seq
-                    do (setf result
-                             (funcall
-                               fn result
-                               (funcall-if key (pop seq)))))
-                 (loop while seq
-                    do (setf result
-                             (funcall
-                               fn result
-                               (funcall-if key (pop seq))))))
-             result))))
-)
\ No newline at end of file
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/auxmacs.lisp norvig-paip-pjb/auxmacs.lisp
--- norvig/auxmacs.lisp	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/auxmacs.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -0,0 +1,56 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+;;;; File auxmacs.lisp: Macros Used in other Auxiliary Functions
+;;;; Load this before anything else, then load auxfns.lisp.
+
+(defmacro once-only (variables &rest body)
+  "Returns the code built by BODY.  If any of VARIABLES
+  might have side effects, they are evaluated once and stored
+  in temporary variables that are then passed to BODY."
+  (assert (every #'symbolp variables))
+  (let ((temps nil))
+    (dotimes (i (length variables)) (push (gensym) temps))
+    `(if (every #'side-effect-free? (list .,variables))
+         (progn .,body)
+         (list 'let
+	  ,`(list ,@(mapcar #'(lambda (tmp var)
+				`(list ',tmp ,var))
+		     temps variables))
+	  (let ,(mapcar #'(lambda (var tmp) `(,var ',tmp))
+			variables temps)
+	    .,body)))))
+
+(defun side-effect-free? (exp)
+  "Is exp a constant, variable, or function,
+  or of the form (THE type x) where x is side-effect-free?"
+  (or (atom exp) (constantp exp)
+      (starts-with exp 'function)
+      (and (starts-with exp 'the)
+           (side-effect-free? (third exp)))))
+
+(defmacro funcall-if (fn arg)
+  (once-only (fn)
+    `(if ,fn (funcall ,fn ,arg) ,arg)))
+
+(defmacro read-time-case (first-case &rest other-cases)
+  "Do the first case, where normally cases are
+  specified with #+ or possibly #- marks."
+  (declare (ignore other-cases))
+  first-case)
+
+(defun rest2 (x)
+  "The rest of a list after the first TWO elements."
+  (rest (rest x)))
+
+(defun find-anywhere (item tree)
+  "Does item occur anywhere in tree?"
+  (if (atom tree)
+      (if (eql item tree) tree)
+      (or (find-anywhere item (first tree))
+          (find-anywhere item (rest tree)))))
+
+(defun starts-with (list x)
+  "Is x a list whose first element is x?"
+  (and (consp list) (eql (first list) x)))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/clos.dat norvig-paip-pjb/clos.dat
--- norvig/clos.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/clos.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,374 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp;  -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+> (setf acct (new-account "J. Random Customer" 1000.00)) -> 
+#<CLOSURE 23652465>
+
+> (send acct 'withdraw 500.00) -> 500.0
+
+> (send acct 'deposit 123.45) -> 623.45
+
+> (send acct 'name) -> "J. Random Customer"
+
+> (send acct 'balance) -> 623.45
+
+;;; ==============================
+
+(define-class account (name &optional (balance 0.00))
+              ((interest-rate .06))
+  (withdraw (amt) (if (<= amt balance)
+                      (decf balance amt)
+                      'insufficient-funds))
+  (deposit  (amt) (incf balance amt))
+  (balance  ()    balance)
+  (name     ()    name)
+  (interest ()    (incf balance (* interest-rate balance))))
+
+;;; ==============================
+
+> (setf acct2 (account "A. User" 2000.00)) -> #<CLOSURE 24003064>
+
+> (deposit acct2 42.00) -> 2042.0
+
+> (interest acct2) -> 2164.52
+
+> (balance acct2) -> 2164.52
+
+> (balance acct) -> 623.45
+
+;;; ==============================
+
+(define-class password-account (password acct) ()
+  (change-password (pass new-pass)
+                   (if (equal pass password)
+                       (setf password new-pass)
+                       'wrong-password))
+  (otherwise (pass &rest args)
+             (if (equal pass password)
+                 (apply message acct args)
+                 'wrong-password)))
+
+;;; ==============================
+
+(setf acct3 (password-account "secret" acct2)) -> #<CLOSURE 33427277>
+
+> (balance acct3 "secret") -> 2164.52
+
+> (withdraw acct3 "guess" 2000.00) -> WRONG-PASSWORD
+
+> (withdraw acct3 "secret" 2000.00) -> 164.52
+
+;;; ==============================
+
+(define-class limited-account (limit acct) ()
+  (withdraw  (amt)
+             (if (> amt limit)
+                 'over-limit
+                 (withdraw acct amt)))
+  (otherwise (&rest args)
+             (apply message acct args)))
+
+;;; ==============================
+
+> (setf acct4 (password-account "pass"
+                (limited-account 100.00
+                  (account "A. Thrifty Spender" 500.00)))) ->
+#<CLOSURE 34136775>
+
+> (withdraw acct4 "pass" 200.00) -> OVER-LIMIT
+
+> (withdraw acct4 "pass" 20.00) -> 480.0
+
+> (withdraw acct4 "guess" 20.00) -> WRONG-PASSWORD
+
+;;; ==============================
+
+(defun withdraw (acct amt &optional pass)
+  (cond ((and (typep acct 'password-account)
+              (not (equal pass (account-password acct))))
+         'wrong-password)
+        ((and (typep acct 'limited-account)
+              (> amt (account-limit account)))
+         'over-limit)
+        ((> amt balance)
+         'insufficient-funds)
+        (t (decf balance amt))))
+
+;;; ==============================
+
+(defstruct (limited-account (:include account)) limit)
+
+;;; ==============================
+
+(defclass account ()
+  ((name :initarg :name :reader name)
+   (balance :initarg :balance :initform 0.00 :accessor balance)
+   (interest-rate :allocation :class :initform .06 
+                  :reader interest-rate)))
+
+;;; ==============================
+
+> (setf a1 (make-instance 'account :balance 5000.00
+                          :name "Fred")) -> #<ACCOUNT 26726272>
+
+> (name a1) -> "Fred"
+
+> (balance a1) -> 5000.0
+
+> (interest-rate a1) -> 0.06
+
+;;; ==============================
+
+(defmethod withdraw ((acct account) amt)
+  (if (< amt (balance acct))
+      (decf (balance acct) amt)
+      'insufficient-funds))
+
+;;; ==============================
+
+(defclass limited-account (account)
+  ((limit :initarg :limit :reader limit)))
+
+(defmethod withdraw ((acct limited-account) amt)
+  (if (> amt (limit acct))
+      'over-limit
+      (call-next-method)))
+
+;;; ==============================
+
+> (setf a2 (make-instance 'limited-account
+                          :name "A. Thrifty Spender"
+                          :balance 500.00 :limit 100.00)) ->
+#<LIMITED-ACCOUNT 24155343>
+
+> (name a2) -> "A. Thrifty Spender"
+
+> (withdraw a2 200.00) -> OVER-LIMIT
+
+> (withdraw a2 20.00) -> 480.0
+
+;;; ==============================
+
+(defclass audited-account (account)
+  ((audit-trail :initform nil :accessor audit-trail)))
+
+(defmethod withdraw :before ((acct audited-account) amt)
+  (push (print `(withdrawing ,amt))
+        (audit-trail acct)))
+
+(defmethod withdraw :after ((acct audited-account) amt)
+  (push (print `(withdrawal (,amt) done))
+        (audit-trail acct)))
+
+;;; ==============================
+
+> (setf a3 (make-instance 'audited-account :balance 1000.00))
+#<AUDITED-ACCOUNT 33555607>
+
+> (withdraw a3 100.00)
+(WITHDRAWING 100.0) 
+(WITHDRAWAL (100.0) DONE) 
+900.0
+
+> (audit-trail a3)
+((WITHDRAWAL (100.0) DONE) (WITHDRAWING 100.0))
+
+> (setf (audit-trail a3) nil)
+NIL
+
+;;; ==============================
+
+;;;; The Search Utility in CLOS
+
+(defclass problem ()
+  ((states :initarg :states :accessor problem-states)))
+
+;;; ==============================
+
+(defmethod searcher ((prob problem))
+  "Find a state that solves the search problem."
+  (cond ((no-states-p prob) fail)
+        ((goal-p prob) (current-state prob))
+        (t (let ((current (pop-state prob)))
+             (setf (problem-states prob)
+                   (problem-combiner
+                     prob
+                     (problem-successors prob current)
+                     (problem-states prob))))
+           (searcher prob))))
+
+;;; ==============================
+
+(defmethod current-state ((prob problem))
+  "The current state is the first of the possible states."
+  (first (problem-states prob)))
+
+(defmethod pop-state ((prob problem))
+  "Remove and return the current state."
+  (pop (problem-states prob)))
+
+(defmethod no-states-p ((prob problem))
+  "Are there any more unexplored states?"
+  (null (problem-states prob)))
+
+;;; ==============================
+
+(defmethod searcher :before ((prob problem))
+  (dbg 'search "~&;; Search: ~a" (problem-states prob)))
+
+;;; ==============================
+
+(defclass eql-problem (problem)
+  ((goal :initarg :goal :reader problem-goal)))
+
+(defmethod goal-p ((prob eql-problem))
+  (eql (current-state prob) (problem-goal prob)))
+
+;;; ==============================
+
+(defclass dfs-problem (problem) ()
+  (:documentation "Depth-first search problem."))
+
+(defclass bfs-problem (problem) ()
+  (:documentation "Breadth-first search problem."))
+
+(defmethod problem-combiner ((prob dfs-problem) new old)
+  "Depth-first search looks at new states first."
+  (append new old))
+
+(defmethod problem-combiner ((prob bfs-problem) new old)
+  "Depth-first search looks at old states first."
+  (append old new))
+
+;;; ==============================
+
+(defclass binary-tree-problem (problem) ())
+
+(defmethod problem-successors ((prob binary-tree-problem) state)
+  (let ((n (* 2 state)))
+    (list n (+ n 1))))
+
+;;; ==============================
+
+(defclass binary-tree-eql-bfs-problem
+          (binary-tree-problem eql-problem bfs-problem) ())
+
+> (setf p1 (make-instance 'binary-tree-eql-bfs-problem 
+                          :states '(1) :goal 12))
+#<BINARY-TREE-EQL-BFS-PROBLEM 26725536>
+
+
+> (searcher p1)
+;; Search: (1)
+;; Search: (2 3)
+;; Search: (3 4 5)
+;; Search: (4 5 6 7)
+;; Search: (5 6 7 8 9)
+;; Search: (6 7 8 9 10 11)
+;; Search: (7 8 9 10 11 12 13)
+;; Search: (8 9 10 11 12 13 14 15)
+;; Search: (9 10 11 12 13 14 15 16 17)
+;; Search: (10 11 12 13 14 15 16 17 18 19)
+;; Search: (11 12 13 14 15 16 17 18 19 20 21)
+;; Search: (12 13 14 15 16 17 18 19 20 21 22 23)
+12
+
+;;; ==============================
+
+(defclass best-problem (problem) ()
+  (:documentation "A Best-first search problem."))
+
+(defmethod problem-combiner ((prob best-problem) new old)
+  "Best-first search sorts new and old according to cost-fn."
+  (sort (append new old) #'<
+        :key #'(lambda (state) (cost-fn prob state))))
+
+;;; ==============================
+
+(defmethod cost-fn ((prob eql-problem) state)
+  (abs (- state (problem-goal prob))))
+
+;;; ==============================
+
+(defclass beam-problem (problem)
+  ((beam-width :initarg :beam-width :initform nil
+               :reader problem-beam-width)))
+
+(defmethod problem-combiner :around ((prob beam-problem) new old)
+  (let ((combined (call-next-method)))
+    (subseq combined 0 (min (problem-beam-width prob) 
+                            (length combined)))))
+
+;;; ==============================
+
+(defclass binary-tree-eql-best-beam-problem
+  (binary-tree-problem eql-problem best-problem beam-problem) 
+  ())
+
+> (setf p3 (make-instance 'binary-tree-eql-best-beam-problem 
+                          :states '(1) :goal 12 :beam-width 3))
+#<BINARY-TREE-EQL-BEST-BEAM-PROBLEM 27523251>
+
+> (searcher p3)
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6 2)
+;; Search: (14 15 6)
+;; Search: (15 6 28)
+;; Search: (6 28 30)
+;; Search: (12 13 28)
+12
+
+;;; ==============================
+
+(defclass trip-problem (binary-tree-eql-best-beam-problem) 
+  ((beam-width :initform 1)))
+
+(defmethod cost-fn ((prob trip-problem) city)
+  (air-distance (problem-goal prob) city))
+
+(defmethod problem-successors ((prob trip-problem) city)
+  (neighbors city))
+
+;;; ==============================
+
+> (setf p4 (make-instance 'trip-problem 
+                          :states (list (city 'new-york)) 
+                          :goal (city 'san-francisco)))
+#<TRIP-PROBLEM 31572426>
+
+> (searcher p4)
+;; Search: ((NEW-YORK 73.58 40.47))
+;; Search: ((PITTSBURG 79.57 40.27))
+;; Search: ((CHICAGO 87.37 41.5))
+;; Search: ((KANSAS-CITY 94.35 39.06))
+;; Search: ((DENVER 105.0 39.45))
+;; Search: ((FLAGSTAFF 111.41 35.13))
+;; Search: ((RENO 119.49 39.3))
+;; Search: ((SAN-FRANCISCO 122.26 37.47))
+(SAN-FRANCISCO 122.26 37.47)
+
+;;; ==============================
+
+(defmethod conc ((x null) y) y)
+
+(defmethod conc (x (y null)) x)
+
+(defmethod conc ((x list) (y list))
+  (cons (first x) (conc (rest x) y)))
+
+(defmethod conc ((x vector) (y vector))
+  (let ((vect (make-array (+ (length x) (length y)))))
+    (replace vect x)
+    (replace vect y :start1 (length x))))
+
+;;; ==============================
+
+> (conc nil '(a b c)) -> (A B C)
+
+> (conc '(a b c) nil) -> (A B C)
+
+> (conc '(a b c) '(d e f)) -> (A B C D E F)
+
+> (conc '#(a b c) '#(d e f)) -> #(A B C D E F)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/cmacsyma.dat norvig-paip-pjb/cmacsyma.dat
--- norvig/cmacsyma.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/cmacsyma.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,35 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(canon-simplifier)
+CANON> (3 + x + 4 - x)
+7 
+CANON> (x + y + y + x)
+((2 * X) + (2 * Y)) 
+CANON> (3 * x + 4 * x)
+(7 * X) 
+CANON> (3 * x + y + x + 4 * x)
+((8 * X) + Y) 
+CANON> (3 * x + y + z + x + 4 * x)
+((8 * X) + (Y + Z)) 
+CANON> ((x + 1) ^ 10)
+((X ^ 10) + (10 * (X ^ 9)) + (45 * (X ^ 8)) + (120 * (X ^ 7))
+ + (210 * (X ^ 6)) + (252 * (X ^ 5)) + (210 * (X ^ 4))
+ + (120 * (X ^ 3)) + (45 * (X ^ 2)) + (10 * X) + 1) 
+CANON> ((x + 1) ^ 10 + (x - 1) ^ 10)
+((2 * (X ^ 10)) + (90 * (X ^ 8)) + (420 * (X ^ 6)) 
+ + (420 * (X ^ 4)) + (90 * (X ^ 2)) + 2)
+CANON> ((x + 1) ^ 10 - (x - 1) ^ 10)
+((20 * (X ^ 8)) + (240 * (X ^ 7)) + (504 * (X ^ 5))
+ + (240 * (X ^ 3)) + (20 * X)) 
+CANON> (3 * x ^ 3 + 4 * x * y * (x - 1) + x ^ 2 * (x + y))
+((4 * (X ^ 3)) + ((5 * Y) * (X ^ 2)) + ((-4 * Y) * X)) 
+CANON> (3 * x ^ 3 + 4 * x * w * (x - 1) + x ^ 2 * (x + w))
+((((5 * (X ^ 2)) + (-4 * X)) * W) + (4 * (X ^ 3))) 
+CANON> (d (3 * x ^ 2 + 2 * x + 1) / d x)
+((6 * X) + 2) 
+CANON> (d(z + 3 * x + 3 * z * x ^ 2 + z ^ 2 * x ^ 3) / d z)
+(((2 * Z) * (X ^ 3)) + (3 * (X ^ 2)) + 1) 
+CANON> [Abort]
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/cmacsyma.lisp norvig-paip-pjb/cmacsyma.lisp
--- norvig/cmacsyma.lisp	1997-02-05 07:39:47.000000000 +0100
+++ norvig-paip-pjb/cmacsyma.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -6,7 +6,7 @@
 
 ;;; Bug Fix by dst, Dave_Touretzky@CS.CMU.EDU
 
-(requires "macsyma") ; Only for the infix parser
+(requires "patmatch" "eliza-pm")
 
 ;;;; rule and expression definitions from "student.lisp"
 
@@ -21,6 +21,49 @@
 (defun binary-exp-p (x)
   (and (exp-p x) (= (length (exp-args x)) 2)))
 
+;;;; from original Macsyma:
+
+(defun infix->prefix (exp)
+  "Translate an infix expression into prefix notation."
+  ;; Note we cannot do implicit multiplication in this system
+  (cond ((atom exp) exp)
+        ((= (length exp) 1) (infix->prefix (first exp)))
+        ((rule-based-translator exp *infix->prefix-rules*
+           :rule-if #'rule-pattern :rule-then #'rule-response
+           :action
+           #'(lambda (bindings response)
+               (sublis (mapcar
+                         #'(lambda (pair)
+                             (cons (first pair)
+                                   (infix->prefix (rest pair))))
+                         bindings)
+                       response))))
+        ((symbolp (first exp))
+         (list (first exp) (infix->prefix (rest exp))))
+        (t (error "Illegal exp"))))
+
+(defun variable-p (exp)
+  "Variables are the symbols M through Z."
+  ;; put x,y,z first to find them a little faster
+  (member exp '(x y z m n o p q r s t u v w)))
+
+(pat-match-abbrev 'x+ '(?+ x))
+(pat-match-abbrev 'y+ '(?+ y))
+
+(defparameter *infix->prefix-rules*
+  (mapcar #'expand-pat-match-abbrev
+    '(((x+ = y+) (= x y))
+      ((- x+)    (- x))
+      ((+ x+)    (+ x))
+      ((x+ + y+) (+ x y))
+      ((x+ - y+) (- x y))
+      ((d y+ / d x) (d y x))        ;*** New rule
+      ((Int y+ d x) (int y x))      ;*** New rule
+      ((x+ * y+) (* x y))
+      ((x+ / y+) (/ x y))
+      ((x+ ^ y+) (^ x y))))
+    "A list of rules, ordered by precedence.")
+
 (proclaim '(inline main-var degree coef
                    var= var> poly make-poly))
 
@@ -246,7 +289,10 @@
 
 (defun canon (infix-exp)
   "Canonicalize argument and convert it back to infix"
-  (prefix->infix (canon->prefix (prefix->canon (infix->prefix infix-exp)))))
+  (prefix->infix
+    (canon->prefix
+      (prefix->canon
+        (infix->prefix infix-exp)))))
 
 (defun canon-simplifier ()
   "Read an expression, canonicalize it, and print the result."
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/compile2.lisp norvig-paip-pjb/compile2.lisp
--- norvig/compile2.lisp	1997-02-05 07:39:47.000000000 +0100
+++ norvig-paip-pjb/compile2.lisp	2012-06-20 11:06:18.000000000 +0200
@@ -227,9 +227,9 @@
 (defun new-fn (&key code env name args)
   "Build a new function."
   (assemble (make-fn :env env :name name :args args
-                     :code (optimize code))))
+                     :code (optymize code))))
 
 ;;; ==============================
 
-(defun optimize (code) code)
+(defun optymize (code) code)
 (defun assemble (fn) fn)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/compile3.lisp norvig-paip-pjb/compile3.lisp
--- norvig/compile3.lisp	1997-02-05 07:39:48.000000000 +0100
+++ norvig-paip-pjb/compile3.lisp	2012-06-20 11:06:20.000000000 +0200
@@ -6,9 +6,7 @@
 ;;;; and peephole optimizer.  Also the abstract machine simulator.
 ;;;; After loading this file, load the optimizers in compopt.lisp.
 
-;;; Bug fixes by Erann Gat, gat@aig.Jpl.Nasa.Gov, November 1992
-
-(requires "interp1" "compile1" "compile2")
+(requires "interp1")
 
 ;;; ==============================
 
@@ -94,7 +92,7 @@
          (env nil)
          (stack nil)
          (n-args 0)
-         (instr nil))
+         (instr))
     (loop
        (setf instr (elt code pc))
        (incf pc)
@@ -165,7 +163,7 @@
                        stack))
          
          ;; Nullary operations:
-         ((SCHEME-READ NEWLINE) ; *** fix, gat, 11/9/92
+         ((READ NEWLINE)
           (push (funcall (opcode instr)) stack))
          
          ;; Unary operations:
@@ -198,8 +196,7 @@
     (new-fn :name 'exit :args '(val) :code '((HALT))))
   (set-global-var! 'call/cc
     (new-fn :name 'call/cc :args '(f)
-            :code '((ARGS 1) (CC) (LVAR 0 0 ";" f)
-		    (CALLJ 1)))) ; *** Bug fix, gat, 11/9/92
+            :code '((ARGS 1) (CC) (LVAR 0 0 ";" f) (CALL 1))))
   (dolist (prim *primitive-fns*)
      (setf (get (prim-symbol prim) 'global-val)
            (new-fn :env nil :name (prim-symbol prim)
@@ -230,21 +227,21 @@
 
 ;;; ==============================
 
-(defun optimize (code)
+(defun optymize (code)
   "Perform peephole optimization on assembly code."
   (let ((any-change nil))
-    ;; Optimize each tail  
+    ;; Optymize each tail  
     (loop for code-tail on code do
-          (setf any-change (or (optimize-1 code-tail code)
+          (setf any-change (or (optymize-1 code-tail code)
                                any-change)))
-    ;; If any changes were made, call optimize again
+    ;; If any changes were made, call optymize again
     (if any-change
-        (optimize code)
+        (optymize code)
         code)))
 
 ;;; ==============================
 
-(defun optimize-1 (code all-code)
+(defun optymize-1 (code all-code)
   "Perform peephole optimization on a tail of the assembly code.
   If a change is made, return true."
   ;; Data-driven by the opcode of the first instruction
@@ -386,12 +383,10 @@
   ;; Don't copy structure, make changes in place.
   (typecase x
     (cons   (setf (car x) (convert-numbers (car x)))
-            (setf (cdr x) (convert-numbers (cdr x)))
-	    x) ; *** Bug fix, gat, 11/9/92
+            (setf (cdr x) (convert-numbers (cdr x))))
     (symbol (or (convert-number x) x))
     (vector (dotimes (i (length x))
-              (setf (aref x i) (convert-numbers (aref x i))))
-	    x) ; *** Bug fix, gat, 11/9/92
+              (setf (aref x i) (convert-numbers (aref x i)))))
     (t x)))
 
 (defun convert-number (symbol)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/compile.dat norvig-paip-pjb/compile.dat
--- norvig/compile.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/compile.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,200 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+;;;; First Version of the compiler (compile1.lisp):
+
+> (comp-show '(if (= x y) (f (g x)) (h x y (h 1 2))))
+        ARGS    0       
+        GVAR    X       
+        GVAR    Y       
+        GVAR    =       
+        CALL    2       
+        FJUMP   L1      
+        GVAR    X       
+        GVAR    G       
+        CALL    1       
+        GVAR    F       
+        CALL    1       
+        JUMP    L2      
+L1:     GVAR    X       
+        GVAR    Y       
+        CONST   1       
+        CONST   2       
+        GVAR    H       
+        CALL    2       
+        GVAR    H       
+        CALL    3       
+L2:     RETURN  
+
+;;;; Tail-Recursive version (compile2.lisp):
+
+> (comp-show '(if p (+ x y) (* x y)))
+        ARGS    0       
+        GVAR    P       
+        FJUMP   L1      
+        GVAR    X       
+        GVAR    Y       
+        +       
+        RETURN  
+L1:     GVAR    X       
+        GVAR    Y       
+        *       
+        RETURN  
+
+;;; ==============================
+
+> (comp-show '(begin (if p (+ x y) (* x y)) z))
+        ARGS   0      
+        GVAR   Z      
+        RETURN 
+
+;;; ==============================
+
+> (comp-show '(begin (if p (f x) (* x x)) z))
+        ARGS    0       
+        GVAR    P       
+        FJUMP   L2      
+        SAVE    K1      
+	GVAR    X       
+	GVAR    F       
+	CALLJ   1       
+ K1:    POP     
+ L2:    GVAR    Z       
+	RETURN  
+
+;;; ==============================
+
+> (comp-show '(if (null? (car l)) (f (+ (* a x) b))
+                  (g (/ x 2))))
+        ARGS    0       
+        GVAR    L       
+        CAR     
+        FJUMP   L1      
+        GVAR    X       
+        2       
+        /       
+        GVAR    G       
+        CALLJ   1       
+L1:     GVAR    A       
+        GVAR    X       
+        *       
+        GVAR    B       
+        +       
+        GVAR    F       
+        CALLJ   1             
+
+;;; ==============================
+
+> (comp-show '(define (last1 l)
+                (if (null? (cdr l)) (car l)
+                    (last1 (cdr l)))))
+        ARGS    0       
+        FN      
+                ARGS    1       
+                LVAR    0       0       ;       L       
+                CDR     
+                FJUMP   L1      
+                LVAR    0       0       ;       L       
+                CDR     
+                GVAR    LAST1   
+                CALLJ   1       
+L1:             LVAR    0       0       ;       L       
+                CAR     
+                RETURN  
+        GSET    LAST1   
+        CONST   LAST1   
+        NAME!   
+        RETURN  
+
+;;; ==============================
+
+> (comp-show '(define (length l)
+                (if (null? l) 0 (+ 1 (length (cdr l))))))
+        ARGS    0       
+        FN      
+                ARGS    1       
+                LVAR    0       0       ;       L       
+                FJUMP   L2      
+                1       
+                SAVE    K1      
+                LVAR    0       0       ;       L       
+                CDR     
+                GVAR    LENGTH  
+                CALLJ   1       
+K1:             +       
+                RETURN  
+L2:             0       
+                RETURN  
+        GSET    LENGTH  
+        CONST   LENGTH  
+        NAME!   
+        RETURN  
+
+;;; ==============================
+
+> (comp-show '(define (length l)
+                (letrec ((len (lambda (l n)
+                                (if (null? l) n
+                                    (len (rest l) (+ n 1))))))
+                  (len l 0))))
+        ARGS    0       
+        FN      
+                ARGS    1       
+                NIL     
+                FN      
+                        ARGS    1       
+                        FN      
+                                ARGS    2       
+                                LVAR    0       0       ;       L       
+                                FJUMP   L2      
+                                SAVE    K1      
+                                LVAR    0       0       ;       L       
+                                GVAR    REST    
+                                CALLJ   1       
+K1:                             LVAR    0       1       ;       N       
+                                1       
+                                +       
+                                LVAR    1       0       ;       LEN     
+                                CALLJ   2       
+L2:                             LVAR    0       1       ;       N       
+                                RETURN  
+                        LSET    0       0       ;       LEN     
+                        POP     
+                        LVAR    1       0       ;       L       
+                        0       
+                        LVAR    0       0       ;       LEN     
+                        CALLJ   2       
+                CALLJ   1       
+        GSET    LENGTH  
+        CONST   LENGTH  
+        NAME!   
+        RETURN    
+
+;;; ==============================
+
+> (comp-show '(if (not (and p q (not r))) x y))
+        ARGS    0       
+        GVAR    P       
+        FJUMP   L3      
+        GVAR    Q       
+        FJUMP   L1      
+        GVAR    R       
+        NOT     
+        JUMP    L2      
+L1:     NIL     
+L2:     JUMP    L4      
+L3:     NIL     
+L4:     FJUMP   L5      
+        GVAR    Y       
+        RETURN  
+L5:     GVAR    X       
+        RETURN  
+
+;;;; Peephole optimizer version (compile3.lisp):
+
+> (comp-show '(begin (if (if t 1 (f x)) (set! x 2)) x))
+   0: ARGS    0       
+   1: 2       
+   2: GSET    X       
+   3: RETURN  
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/eliza1.lisp norvig-paip-pjb/eliza1.lisp
--- norvig/eliza1.lisp	1997-02-05 07:39:49.000000000 +0100
+++ norvig-paip-pjb/eliza1.lisp	2012-06-20 11:06:28.000000000 +0200
@@ -4,13 +4,69 @@
 
 ;;;; File eliza1.lisp: Basic version of the Eliza program
 
-;;; The basic are in auxfns.lisp; look for "PATTERN MATCHING FACILITY"
-
-;; New version of pat-match with segment variables
-
 (defun variable-p (x)
   "Is x a variable (a symbol beginning with `?')?"
-  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))
+  (and (symbolp x) (equal (char (symbol-name x) 0) #\?)))
+
+;;; ==============================
+
+(defconstant fail nil "Indicates pat-match failure")
+
+;; Already defined in auxfns.lisp
+;; (defconstant no-bindings '((t . t))
+;;   "Indicates pat-match success, with no variables.")
+
+;;; ==============================
+
+(defun get-binding (var bindings)
+  "Find a (variable . value) pair in a binding list."
+  (assoc var bindings))
+
+(defun binding-val (binding)
+  "Get the value part of a single binding."
+  (cdr binding))
+
+(defun lookup (var bindings)
+  "Get the value part (for var) from a binding list."
+  (binding-val (get-binding var bindings)))
+
+(defun extend-bindings (var val bindings)
+  "Add a (var . value) pair to a binding list."
+  (cons (cons var val) bindings))
+
+;;; ==============================
+
+(defun pat-match (pattern input &optional (bindings no-bindings))
+  "Match pattern against input in the context of the bindings"
+  (cond ((eq bindings fail) fail)
+        ((variable-p pattern)
+         (match-variable pattern input bindings))
+        ((eql pattern input) bindings)
+        ((and (consp pattern) (consp input))
+         (pat-match (rest pattern) (rest input)
+                    (pat-match (first pattern) (first input) 
+                               bindings)))
+        (t fail)))
+
+(defun match-variable (var input bindings)
+  "Does VAR match input?  Uses (or updates) and returns bindings."
+  (let ((binding (get-binding var bindings)))
+    (cond ((not binding) (extend-bindings var input bindings))
+          ((equal input (binding-val binding)) bindings)
+          (t fail))))
+
+;;; ==============================
+
+(defun extend-bindings (var val bindings)
+  "Add a (var . value) pair to a binding list."
+  (cons (cons var val)
+        ;; Once we add a "real" binding,
+        ;; we can get rid of the dummy no-bindings
+        (if (and (eq bindings no-bindings))
+            nil
+            bindings)))
+
+;;; ==============================
 
 (defun pat-match (pattern input &optional (bindings no-bindings))
   "Match pattern against input in the context of the bindings"
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/ERRATA norvig-paip-pjb/ERRATA
--- norvig/ERRATA	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/ERRATA	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,553 @@
+		  "Paradigms of AI Programming" Errata Sheet
+
+				 Peter Norvig
+
+
+The following bugs and typos have been discovered so far, and will be
+fixed in the next printing of the book.  If you discover any additional
+errors, please send them to me, so that we can make the next printing as
+error-free as possible.  Many thanks to all those who have contributed
+so far, and thanks in advance to those who will add to this list.
+
+Peter Norvig				Tel: (508) 671-0508
+Sun Microsystems Laboratories		Fax: (508) 671-0624
+Two Federal Street			Email: Peter.Norvig@East.Sun.COM
+Billerica MA 01821 USA
+
+==============================================================================
+
+Page 5: Line -2: Change "y = a * x + 3" ==> "y=a*x+3"  that is, remove spaces.
+
+Page 9: Paragraph 3: "In evaluating an to" ==> "In evaluating an"
+
+Page 29: "forseen" ==> "foreseen"
+
+Page 39: Line -11: "grammers" ==> "grammars"
+
+Page 57: x++ ==> ++x
+
+Page 69: Change "T" to "t" two times:
+	"(null nil) => T"	==>  "(null nil) => t"
+	"(listp x) => T"	==>  "(listp x) => t"
+
+Page 70: In the diagram, change "(ONE TWO)" ==> "(ONE . TWO)"
+
+Page 87: (end pp 2) "cerrer" ==> "cerror"
+
+Page 90: A parenthesis is in the wrong place in test-ex:
+
+	(assert (equal (ex 'x 0)) 0))	==> (assert (equal (ex 'x 0) 0)))
+
+Page 96: (middle)  "inobtrusive" -> "unobtrusive"
+
+Page 99: line 5: "signifigance" ==> "significance"
+
+Page 102: Could use more space after exercise 3.8
+
+Page 106: (defun length-r ...) should be in typewriter font.
+
+Page 130: pp 1: line 11: change "eventualy" ==> "eventually"
+
+Page 166: (line -5) "remains" ==> "remains an"
+
+Page 159 and 182:  
+           change
+           "(if (and (eq bindings no-bindings))
+                nil
+                bindings)"
+           ==>
+           "(if (eq bindings no-bindings)
+                nil
+                bindings)"
+
+Page 169: Exercise 5.18 is actually the answer to exercise 5.17.
+
+Page 185: "succesful" ==> "successful"
+
+Page 186: middle: change "making the substitutions implied by the binding list
+into the code and then evaluating it"  ==> "evaluating the code with the
+bindings implied by the binding list."
+
+[bug] Also replace definition of match-if with:
+
+(defun match-if (pattern input bindings)
+  "Test an arbitrary expression involving variables.
+  The pattern looks like ((?if code) . rest)."
+  (and (progv (mapcar #'car bindings)
+              (mapcar #'cdr bindings)
+          (eval (second (first pattern))))
+       (pat-match (rest pattern) input bindings)))
+
+Page 197: (footnote) "any integration problem" ==> "the same class of
+	 integration problems"
+
+Page 198: Map needs route from K to I.
+
+Page 198/199: Sentence ends in the middle.  Add "successors to a state.  The
+cost for a state is the air distance to the destination city."
+
+Page 202: Missing text at bottom of page:
+
+(defun is (value &key (key #'identity) (test #'eql))
+  "Returns a predicate that tests for a given value."
+  #'(lambda (path) (funcall test value (funcall key path))))
+
+The {\tt path-saver} function returns a function that will take a path as an
+argument and generate successors paths.  {\tt path-saver} takes as an argument
+a successor function that
+
+Page 204 (middle)  "exitting" == "exiting"
+
+Page 206: should have an arrow from 2 -> 3.
+
+Page 207: Tree should have arrows, not undirected lines
+
+Page 209: (old) ==> (old nil)      			
+
+Page 212: Two arrows missing in diagram:
+
+           A     A              C
+	  BC <-> BC    and     AB
+                               ^
+                               |
+                               v
+                               C
+                               AB
+
+Page 215: Exercise 6.10[h] ==> Exercise 6.10[m]
+	  Exercise 6.13[m] ==> Exercise 6.13[d]
+	  Exercise 6.14[m] ==> Exercise 6.14[d]
+	(line -1) remove the two commas after "answer" and "found"
+
+Page 219: Epigraph goes into roman font.
+
+Page 225:  Line 2: change "exercise 7.5"  ==>  "exercise 7.3"
+           Also Section 7.2 Line 2: 
+           change "it is good example"  ==>  "it is a good example"
+
+Page 234: Exercise 7.2[h] ==> Exercise 7.2[d]
+
+Page 228:  Line 5,6: change "The datastructure op"  ==>  "The datastructure exp"
+
+	   change "like isolate, it assumes"  ==>
+                  "unlike isolate, it assumes"
+
+           and in the definition of in-exp
+           change "(listp exp)"  ==>  "(exp-p exp)"
+		   
+Page 245: (end of pp 1) After "(an inexact number)." add
+         "Another problem is that -2 is also a square root of 4, and in some 
+	contexts it is the correct one to use."
+
+Page 248: (pp 2) Change "and we could not use a single equality" to
+	  "and it would be wrong to arbitrarily choose one of these values."
+
+Page 257:  change "for n/=1" ==> "for n /= -1
+           change "for n=1"  ==> "for n = -1"
+
+           and change "but it is log(u) for n = 1.
+           ==>        "but it is log(u) for n = -1."
+
+Page 274:  "Exercise 9.8" ==> "Exercise 9.4"
+           Change $n+1$ ==> n+1 (in math mode).
+
+Page 277:  Change "compiler!versus ... versus compiler." ==>
+	   "compiler versus interpreter."
+
+Page 280:  Change "field in undefined" ==> "field is undefined" 
+
+Page 293:  correct the indentation of profiled-fn, i.e. shift the
+           "multiple-value-prog1" form 2 spaces to the left
+		   
+Page 295:  correct the indentation of test-it, i.e. shift the
+           "time" form 1 space to the left
+
+Page 299:  Second text line: Change "exxpression" ==> "expression"
+
+Page 301:  line 3:
+           change "and a list of variable bindings."
+           ==> "and a continuation for generating the code 
+                if the test passes.  The list of current variable
+                bindings is held in the special variable *bindings*."
+
+Page 309: Exercise 9.11[d] ==> Exercise 9.11[h]
+
+Page 310: (answer 9.4)  Two uses of "100" should be subscripts:
+	In LaTeX, change  $T_100$ ==> $T_{100}$  and $F_100$ ==> $F_{100}$  
+        Also, change "Knuth'sKnuth" ==> "Knuth"
+	Also, in Answer 9.4: "(fib n)" ==> typewriter font
+
+Page 314: computaion ==> computation
+
+Page 329: 2nd pp: "parts of the answer" ==> "part of the answer"
+
+Page 367: end 1st pp: Change "which searches for solutions breadth-first."
+	==> "which must keep all solutions in memory at once."
+
+Page 391: "binsings" ==> "bindings"
+
+Page 401: Change:
+
+	(IF (UNIFY! ?ARG1 ?ITEM)
+	    (IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))
+ 	       (FUNCALL CONT))))
+
+	instead of:
+
+	(LET ((?ITEM (?)))
+	  (IF (UNIFY! ?ARG1 ?ITEM)
+	      (IF (UNIFY! ?ARG2 (CONS ?ITEM (?)))
+	          (FUNCALL CONT))))
+
+==change-to==>
+
+
+	(LET ((?ITEM (?)))
+	  (IF (UNIFY! ?ARG1 ?ITEM)
+	      (IF (UNIFY! ?ARG2 (CONS ?ITEM (?)))
+ 	          (FUNCALL CONT))))
+
+	when it could compile to the more efficient:
+
+	(IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))
+	    (FUNCALL CONT))
+
+Page 417: [bug]	change "(cons var (?))" ==> "(cons (deref var) (?))"    
+
+Page 429: (defmacro with-compilation-unit (&body body)  ==>
+          (defmacro with-compilation-unit (options &body body)
+
+	  And 11 lines down, change:
+
+          (with-compilation-unit ==> (with-compilation-unit ()
+
+	  Also, add 429 to the index entry for with-compilation-unit
+
+Page 435: Delete "once and for all" from 1st pp, section 13.1
+
+Page 443: box could be better
+
+Page 452: [bug] change to:					
+
+(defmethod problem-combiner :around ((prob beam-problem) new old)
+  (let ((combined (call-next-method)))
+    (subseq combined 0 (min (problem-beam-width prob) 
+                            (length combined)))))
+
+Page 461: 3rd pp, line 5: "paricular" ==> "particular"
+
+Page 463: line -1: change the double arrow "<=>" to a right arrow "=>"
+
+Page 464: under "Decidability" bullet: change "follows from the axioms" ==>
+          "can be derived from the axioms"
+
+Page 482: 10 lines from the top, (?fn (subst-bindings #:bindings6369 `?fn)))
+	  should be indented 8 spaces further:
+     (let ((?x (subst-bindings #:bindings6369 '?x))
+           (?fn (subst-bindings #:bindings6369 `?fn)))
+
+Page 529: [bug] The Lines beginning "(b " and "(c " in rat+rat should be:
+
+	(b (rat-denominator x))
+	(c (rat-numerator y))
+
+Page 533: The table does not fit on the page; the entries below
+"Previously Defined Functions" have been left out.  Since this
+section is not crucial, I recommend just deleting the "Previously Defined
+Functions" line.
+
+Page 544: (temp patient> 98.6) ==> (temp patient > 98.6)
+That is, add a space before the >.
+
+Page 549: In fourth line of check-conditions, change conditions ==> kind
+That is, (warn "Rule ~a: Missing ~a" rule-num conditions) ==>
+	 (warn "Rule ~a: Missing ~a" rule-num kind)
+
+
+Page 558: "Pearl 1989/1978" ==> "Pearl 1989"
+
+Page 564:  Change "ouput" ==> "output"
+
+Page 585/586: "After constraint propagation ... ZV=[-]"
+	should be in monospace font.
+
+Page 596: Add epigraph:
+
+"In the beginner's mind there are endless possibilities; in the
+expert's there are few." -- Suzuki Roshi, Zen master
+
+Page 633:  Change  "In this, case..." ==> "In this case"
+
+Page 637: middle of page: Add more space after italic "mobility", i.e.
+	  "mobilityand" ==> "mobility and"
+
+Page 638: line -2: "depends is evaluated" ==> "is evaluated"
+
+Page 644: "lay" ==> "lie"
+
+Page 676: [bug] In the definition of "meaning", change
+
+        (best-score (tree-score (first trees)))
+	==>
+        (best-score (if trees (tree-score (first trees)) 0))
+
+Page 680: line 1: "defintion" ==> "definition"
+
+Page 685: line 9: "that is noun phrase" ==> "that is a noun phrase"
+
+Page 700 and 932: change "Natassja Kinski"  ==>  "Nastassja Kinski"
+
+Page 748: line -3: "Svartik" ==> "Svartvik"
+
+Page 758: [bug] (interp (fourth x)) env ==> (interp (fourth x) env) 
+
+Page 763: [bug] (interp (fourth x)) env ==> (interp (fourth x) env) 
+
+[bug] also change to: 
+(defun scheme-macro (symbol)
+  (and (symbolp symbol) (get symbol 'scheme-macro)))    
+
+Page 778: Part of answer to 22.6 appears in wrong place.
+Should be on page 781.
+
+Page 785:  In table, add new line (at end):
+	   FN	   fn	   Create a closure from argument and current
+			   environment, and push it on the stack
+	   Also, add to description of CALL (on new line) the text:
+	   n is the number of arguments passed.
+
+Page 787:  Change (gen 'call (length (rest x)))))))))  ==>
+		  (gen 'CALL (length (rest x)))))))))
+
+Page 789:  Change
+	   (let ((a 0.0)
+		 (b 0.1))
+	     (let ((c 1.0)
+		   (d 1.1))
+	       (let ((e 2.0)
+		     (f 2.1))
+		 (+ a b c d e f)))) 	==>
+
+	   (let ((a 2.0)
+		 (b 2.1))
+	     (let ((c 1.0)
+		   (d 1.1))
+	       (let ((e 0.0)
+		     (f 0.1))
+		 (+ a b c d e f))))
+      
+
+Page 796:  Change "CALL  1"  ==>  "CALLJ 1"
+
+Page 822: 1st line of text: "unforgable" ==> "unforgeable"
+
+Page 823: [bug] change to:					
+
+(defparameter *primitive-fns*
+  '((+ 2 + true nil) (- 2 - true nil) (* 2 * true nil) (/ 2 / true nil)
+    (< 2 < nil nil) (> 2 > nil nil) (<= 2 <= nil nil) (>= 2 >= nil nil)
+    (/= 2 /= nil nil) (= 2 = nil nil)
+    (eq? 2 eq nil nil) (equal? 2 equal nil nil) (eqv? 2 eql nil nil)
+    (not 1 not nil nil) (null? 1 not nil nil) (cons 2 cons true nil)
+    (car 1 car nil nil) (cdr 1 cdr nil nil)  (cadr 1 cadr nil nil) 
+    (list 1 list1 true nil) (list 2 list2 true nil) (list 3 list3 true nil)
+    (read 0 read nil t) (write 1 write nil t) (display 1 display nil t)
+    (newline 0 newline nil t) (compiler 1 compiler t nil) 
+    (name! 2 name! true t) (random 1 random true nil)))
+
+Page 838: line -1: change "transformaing" ==> "transforming"
+
+Page 839: change the two lines:
+
+	> (div xyzzy 1)
+	Error: XYZZY is not a bound variable
+==>
+	> (div 'xyzzy 1)
+	Error: The value of NUMBER, XYZZY, should be a number
+
+Page 843: fill-loop-template has two extra )'s at end
+
+Page 862: [bug] In reduce-list, change the loop to:
+
+(loop repeat (- end (if init-p 1 2)) while seq
+      do (setf result
+	       (funcall
+		fn result
+		(funcall-if key (pop seq)))))		
+
+Page 881: defmacro binding-of ==> defun binding-of
+
+Page 890: top line "preferably" ==> "preferable"
+
+Page 893: insert "()" in				
+
+(with-compilation-unit () (sys-action module system action))
+
+Page 897,898: In "mget *", the space is too small
+
+Page 899/900: Add:
+Case-Based Reasoning	cs.umd.edu	   /pub/schank/icbr
+Blackboard System Shell dime.cs.umass.edu  /gbb/
+Scheme			ftp.cs.umb.edu	   /pub/scheme/umb-scheme-2.5.tar.Z
+
+Page 913: line 1:  "Svartik" ==> "Svartvik"
+
+Page 918:  In Winston and Horn, change "(1988)" ==> "(1989)"
+
+Page 921:  delete the line "M, 60, 678"
+
+Page 929, 942:
+It would be nice (but not essential) if the following 2 lines could be added
+to the index:
+
+global variable, see special variable
+special variable, 51, 93, 888, 889
+
+Page 930: put handler-case index entry on separate line
+
+Page Back cover:
+
+(University of California at Berkeley) ==> (Sun Microsystems Laboratories)
+
+Page In general: several people have complained about the "computer" font.
+	Here are two of the comments:
+
+	"The san-serif font that you use for computer printout does not mix
+	well with the font for the body of the book.  The spacing between
+	normal text and computer text is comparable to the gaps between
+	adjacent computer-text characters, and is confusing on first reading.
+	The most telling example I've seen so far is the last line of p 53 where
+	it seems there are words like explicitnil  overwhen .."
+	
+	"There seems to be a problem with the spacing of in-text
+	mono-space font (TeX's \tt), see the lists on page 220 
+	for example."
+
+==============================================================================
+
+The following have been reported, but have not been incorporated for one
+of two reasons. (1) Some I consider too unimportant to fix.  I may
+change my mind if others have the same complaints.  (2) Others are too
+expensive to fix.  There is a cost for each page that is changed; it is
+not possible to just add new material without figuring how to change the
+surrounding pages.  Certainly if there is a 2nd edition (as opposed to a
+2nd printing), then some of these should be addressed.
+
+Page 13: "The last expression" ==> "The value of the last expression"
+
+Page 52: (if ...) "is the value." Also Page 53.
+
+Page 55: /* Pascal */ ==> { Pascal } or (* Pascal *)
+
+Page 68: dot notation used before explained.
+
+Page 74: gethash references get, which was not introduced.
+
+Page 92: incf, decf could be used in the definition of bank-account
+
+Page 114, 129: Change doc string for appropriate-p to:
+	  "An op is appropriate to a goal if the goal is in the op's add-list."
+
+Page 146: 2nd para in 4.20 is probably not what you want to say about NP.
+          at least add "as the size of the problem grows LINEARLY."
+
+Page 182:  change "of symbols like ?*"  ==>  "of symbols like ?is"
+
+Page 230:  change "~%~a~{~% ~{ ~a~}~}~%"  ==>
+                  "~%~a~{~% ~{  ~a~}~}~%"
+           i.e. two blanks instead of one 
+				  
+Page 234: line -3 n unknowns   ==> $m \le n$ unknowns.
+
+Page 239: Para 4: survive ==> survived.
+
+Page 259: section 8.7  cite with  name (..) consistently..
+          e.g. Moses (1975) ==> Moses 1975
+          There is a better book by Geddes Labahn and Czapor (1992) that covers
+          this stuff.  
+
+Page 285:  in the definition of "sieve"
+           change "(mod x (headpipe))"  ==>  "(mod x (head pipe))"
+
+Page 315:  perhaps remove "the following"  since you have another sentence
+	   next..
+
+Page 437: Need some guard against depositing a negative amount.
+
+Page 465: 2nd pp, line 2: "was" ==> "is"
+
+Page 466: "1982" ==> "(1982)"
+
+Page 734: "present-plural" in the call to verb might be
+	  better named  "3rd-person-sing"
+
+Page 811: line -11: "less" ==> "fewer"
+
+Page 826: Deutsch 1980 ==> Deutsch (1980).
+
+Page Chapter 1: Certain basic functions (listp, atom) are not presented.
+
+Page 919: I'd prefer for index entries like *state* to sort under S.
+
+Page 924: the entry for "Common Lisp" could be omitted.
+
+Page Bibliography: The editor tag is missing on various "Readings in" entries
+
+Whenever there's a label including an "et al." a backslash
+is missing after it in the source making TeX to produce an
+inter-sentence spacing.
+Probably this is just an error in the BibTeX-style.
+See pages 234, 382, and 383 for example.
+
+3.  In section 25.14 about "Problems with Macros" your example pop-end
+    is probably better written as a function.  It does not violate
+    the usual evaluation rules, and this was just explained to be 
+    a mistake, so it's probably not a padagogically valuable 
+    example.
+
+4.  Its great to have some examples for setf methods included in
+    section 25.14, but the transition from the pop-end macro to
+    a setf method for last on page 883 is not very obvious.  
+    In addition, it would be nice to shed some more light on 
+    setf methods:  they are called methods but actually they are macros.
+    In ANSI Common Lisp the confusion is even greater:  Now there
+    are 4 ways to define setf "methods"
+      (defsetf ...)
+      (define-setf-method ...)
+      (defmethod setf ...)
+      (defun (setf ...) ...)
+    Why not including an extra section on setf methods?
+
+3.  On page 272 your write:
+    "The trick is that memoize takes this new function and 
+    makes it the symbol-function value of the function name.  This 
+    means that all the references in the original function will 
+    now go to the new function ..."
+  
+    Essentially, this is the trick, but someone who is not that 
+    familiar with closures and the difference between symbols and 
+    local variables might wonder how the memoized version of fib 
+    does call the unmemoized version of fib.  As you explained, 
+    the recursive call to fib in the definition of fib uses the 
+    symbol fib, so this compiles into a fetch of the 
+    symbol-function of fib (which results in the memoized 
+    version), but the call "(funcall fn x)" in the memoized version
+    uses the function bound to the local (lexical) variable fn 
+    which is the original version.
+    I think you should explicitly explain this, and maybe add a 
+    reference to section 3.16 (closures) and to the end of section 
+    3.17 (special variables) which explains symbol-value which is 
+    analog to symbol-function.
+
+4.  Unfortunately, in the subsection about Queues (Page 341ff) 
+    you haven't given a concise and abstract definition of Queues, 
+    and your implementation of ``dequeue is a bit awkward in that
+    it returns the queue instead of the dequeued element.  I suggest
+    changing this to be consistent with the operation ``pop'' for
+    stacks which is nothing but a ``dequeue'' for LIFO-Queues
+    (see the article from Norvig and Waters in LISP Pointers).
+	
+    In addition, at least give a hint that it might be more efficient
+    to use vectors instead of lists for implementing queues -- after
+    all it is a chapter about efficiency issues.  A reference to
+    your LISP Pointer article might be useful too.
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/examples.lisp norvig-paip-pjb/examples.lisp
--- norvig/examples.lisp	2002-04-10 01:48:38.000000000 +0200
+++ norvig-paip-pjb/examples.lisp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1651 +0,0 @@
-;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
-;;;; Code from Paradigms of AI Programming
-;;;; Copyright (c) 1991, 1996 Peter Norvig
-
-(requires "tutor")
-
-(defexamples 1 "Introduction to Lisp"
-  "This chapter is for people with little or no experince in Lisp."
-  "Intermediate or advanced readers can skim or skip this chapter."
-  ""
-  "Lisp expressions are in prefix notation: the operator first."
-  ((+ 2 2) => 4 @ 4)
-  ((+ 1 2 3 4 5 6 7 8 9 10) => 55 @ 5)
-  "This is Lisp for (900 + 900 + 90 + 9) - (5000 + 500 + 50 + 5)"
-  ((- (+ 9000 900 90 9) (+ 5000 500 50 5)) => 4444)
-  (:section "1.1 Symbolic Computation")
-  "This is an example of computation on lists:"
-  ((append '(Pat Kim) '(Robin Sandy)) => (PAT KIM ROBIN SANDY) @ 6)
-  "The quote mark instructs Lisp to treat the list as data."
-  ('(pat Kim) => (PAT KIM))
-  "Let's look at some more list processing functions"
-  (:section "1.4 Lists")
-  ((setf p '(John Q Public)) @ 10)
-  ((first p))
-  ((rest p))
-  ((second p))
-  ((third p))
-  ((fourth p))
-  ((length p))
-  "It is also possible to build up new lists"
-  (p @ 11)
-  ((cons 'Mr p))
-  ((cons (first p) (rest p)))
-  ((setf town (list 'Anytown 'USA)))
-  ((list p 'of town 'may 'have 'already 'won!))
-  ((append p '(of) town '(may have already won)))
-  (p)
-  (:section "1.5 Defining New Functions")
-  "The special form DEFUN stands for 'define function.'"
-  "It is used here to define a new function called last-name:"
-  ((requires "intro"))
-  ((last-name p) => PUBLIC @ 13)
-  ((last-name '(Rex Morgan MD)) => MD)
-  ((last-name '(Spot)) => SPOT)
-  ((last-name '(Aristotle)) => ARISTOTLE)
-  "We can also define the function first-name."
-  "Even though the definition is trivial (it is the same as FIRST),"
-  "it is good practice to define first-name explicitly."
-  (p)
-  ((first-name p) => JOHN)
-  ((first-name '(Wilma Flintstone)) => WILMA)
-  ((setf names '((John Q Public) (Malcolm X)
-              (Admiral Grace Murray Hopper) (Spot) 
-              (Aristotle) (A A Milne) (Z Z Top)
-              (Sir Larry Olivier) (Miss Scarlet))) @ 14)
-  ((first-name (first names)) => JOHN)
-  (:section "1.6 Using Functions")
-  "Consider the following expression, which can be used to test LAST-NAME:"
-  ((mapcar #'last-name names))
-  "The #' notation maps the name of a function to the function itself."
-  ((mapcar #'- '(1 2 3 4)) @ 15)
-  ((mapcar #'+ '(1 2 3 4) '(10 20 30 40)))
-  "Now that we understand mapcar, let's use it to test FIRST-NAME:"
-  ((mapcar #'first-name names))
-  "Suppose we wanted a version of FIRST-NAME that ignored titles like Miss:"
-  ((defparameter *titles*
-     '(Mr Mrs Miss Ms Sir Madam Dr Admiral Major General)
-     "A list of titles that can appear at the start of a name."))
-  ((defun first-name (name)
-     "Select the first name from a name represented as a list."
-     (if (member (first name) *titles*)
-	 (first-name (rest name))
-       (first name))) @ 16)
-  ((mapcar #'first-name names))
-  ((first-name '(Madam Major General Paula Jones)) => PAULA)
-  "We can see how this works by tracing the execution of first-name:"
-  ((trace first-name))
-  ((first-name '(John Q Public)) => JOHN @ 17)
-  ((first-name '(Madam Major General Paula Jones)) => PAULA)
-  ((untrace first-name))
-  (:section "1.7 Higher-Order Functions")
-  ((apply #'+ '(1 2 3 4)) => 10)
-  ((apply #'append '((1 2 3) (a b c))))
-  "Now we define a new function, self-and-double, and apply it to arguments."
-  ((defun self-and-double (x) (list x (+ x x))))
-  ((self-and-double 3) => (3 6))
-  ((apply #'self-and-double '(3)) => (3 6))
-  "Now let's return to the mapping functions:"
-  ((mapcar #'self-and-double '(1 10 300)))
-  ((mappend #'self-and-double '(1 10 300)))
-  "FUNCALL is similar to APPLY; it too takes a function as its"
-  "first argument and applies the function to a list of arguments,"
-  "but in the case of FUNCALL, the arguments are listed separately:"
-  ((funcall #'+ 2 3) => 5 @ 20)
-  ((apply #'+ '(2 3)) => 5)
-  )
-
-(defexamples 2 "A Simple Lisp Program"
-  "This chapter shows how to combine the basic functions and"
-  "special forms of Lisp into a complete program"
-  "The program generates random English sentences."
-  (:section "2.2 A Straightforward Solution")
-  "We can test the program by generating a few random sentences."
-  "(Note that since these are random, you won't get the same ones"
-  "as in the book.)"
-  ((requires "simple"))
-  ((sentence) @ 36)
-  ((sentence) @ 36)
-  ((sentence) @ 36)
-  ((noun-phrase))
-  ((verb-phrase))
-  ((trace sentence noun-phrase verb-phrase article noun verb) @ 37)
-  ((sentence))
-  ((untrace))
-  (:section "2.3 A Rule-Based Solution")
-  "An alternative implementation concentrates on making it easy"
-  "to write grammar rules."
-  ((generate 'sentence) @ 41)
-  ((generate 'sentence) @ 41)
-  ((generate 'noun-phrase) @ 41)
-  ((generate 'verb-phrase) @ 41)
-  "One advantage of this approach is its easier to change grammars."
-  ((setf *grammar* *bigger-grammar*) @ 43)
-  ((generate 'sentence))
-  ((generate 'sentence))
-  "Another advantage is that the same data (grammar) can be used"
-  "for more than one purpose.  Consider generate-tree:"
-  ((generate-tree 'sentence) @ 45))
-
-
-(defexamples 3 "Overview of Lisp"
-  "This chapter briefly covers the most important special forms and"
-  "functions in Lisp."
-  (:section "3.2 Special Forms")
-  "Start with functions and special forms for repetition:"
-  "First, functions like MAPCAR can apply to any number of lists:" 
-  ((mapcar #'- '(1 2 3)) => (-1 -2 -3) @ 61)
-  ((mapcar #'+ '(1 2) '(10 20) '(100 200)) => (111 222))
-  "Second, many of the functions accept keywords:"
-  ((remove 1 '(1 2 3 2 1 0 -1)) => (2 3 2 0 -1) @ 61)
-  ((remove 1 '(1 2 3 2 1 0 -1) :key #'abs) => (2 3 2 0) @ 61)
-  ((remove 1 '(1 2 3 2 1 0 -1) :test #'<) => (1 1 0 -1) @ 61)
-  ((remove 1 '(1 2 3 2 1 0 -1) :start 4) => (1 2 3 2 0 -1) @ 61)
-  "Third, some have corresponding -IF or -IF-NOT versions:"
-  ((remove-if #'oddp '(1 2 3 2 1 0 -1)) => (2 2 0))
-  ((remove-if-not #'oddp '(1 2 3 2 1 0 -1)) => (1 3 1 -1))
-  "The forms TRACE and UNTRACE are used to control debugging info:"
-  ((requires "overview"))
-  ((trace length9) @ 65)
-  ((length9 '(1 b c)) => 3)
-  ((untrace length9))
-  ((length9 '(1 b c)) => 3)
-  (:section "3.7 Functions on Trees")
-  ((setf tree '((a b) ((c)) (d e))) @ 76)
-  ((tree-equal tree (copy-tree tree)) => t)
-  ((same-shape-tree tree '((1 2) ((3)) (4 5))) => t)
-  ((same-shape-tree tree '((1 2) (3) (4 5))) => nil)
-  "There are two functions for substituting a new expression into a tree:"
-  ((subst 'new 'old '(old ((very old)))) => (NEW ((VERY NEW))))
-  ((sublis '((old . new)) '(old ((very old)))) => (NEW ((VERY NEW))))
-  ((subst 'new 'old 'old) => NEW)
-  "Here is an example:"
-  ((english->french '(hello my friend - how are you today?))
-   => (bonjour mon ami - comment va tu today?) @ 77)
-  (:section "3.10 Destructive Functions")
-  "Consider the following:"
-  ((setq x '(a b c)) @ 80)
-  ((setq y '(1 2 3)))
-  ((nconc x y) => (a b c 1 2 3))
-  (x => (a b c 1 2 3))
-  (y => (1 2 3))
-  "NCONC computes the same result as APPEND, but it alters the first argument."
-  "It is called a 'destructive' function."
-  "There is quite a conceptual load on the programmer who uses NCONC."
-  "The advantage of NCONC is that it doesn't use any storage."
-  ""
-  (:section "3.11 Overview of Data Types")
-  "The function TYPE-OF returns the type of its argument."
-  ((type-of 123) => fixnum @ 82)
-  ((typep 123 'fixnum) => t)
-  ((typep 123 'integer) => t)
-  ((typep 123.0 'integer) => nil)
-  ((subtypep 'fixnum 'integer) => t)
-  (:section "3.12 Input/Output")
-  "FORMAT is the main function for formatted output:"
-  ((format t "hello, world") @ 84)
-  ((format t "~&~a plus ~s is ~f" "two" "two" 4))
-  ((let ((numbers '( 1 2 3 4 5)))
-     (format t "~&~{~r~^ plus ~} is ~@r"
-	     numbers (apply #'+ numbers))))
-  (:section "3.13 Debugging tools")
-  ((documentation 'first 'function) @ 87)
-  ((documentation 'pi 'variable))
-  (:section "3.14 Antibugging Tools")
-  ((defun f (n) (dotimes (i n) nil)) @ 90)
-  ((time (f 10000)))
-  ((compile 'f))
-  ((time (f 10000)))
-  (:section "3.15 Evaluation")
-  "The following five forms are equivalent:"
-  ((+ 1 2 3 4) => 10 @ 91)
-  ((funcall #'+ 1 2 3 4) => 10 @ 91)
-  ((apply #'+ '(1 2 3 4)) => 10 @ 91)
-  ((apply #'+ 1 2 '(3 4)) => 10 @ 91)
-  ((eval '(+ 1 2 3 4)) => 10 @ 91)
-  (:section "3.16 Closures")
-  "In the general case, a function consists of the body of the function"
-  "coupled with any free lexical variables that the function references."
-  "Consider the example:"
-  ((mapcar (adder 3) '(1 3 10)) => (4 6 13) @ 92)
-  ((mapcar (adder 10) '(1 3 10)) => (11 13 20) @ 92)
-  "In the following, two calls to BANK-ACCOUNT create two different closures,"
-  "each with a separate value for the lexical variable BALANCE."
-  ((setf my-account (bank-account 500.00)) @ 92)
-  ((setf your-account (bank-account 250.00)) @ 93)
-  ((funcall my-account 'withdraw 75.00) => 425.0)
-  ((funcall your-account 'deposit 250.00) => 500.0)
-  ((funcall your-account 'withdraw 100.00) => 400.0)
-  ((funcall my-account 'withdraw 25.00) => 400.0)
-  "This style of programming is covered in more detail in chapter 13."
-  )
-
-(defexamples 4 "GPS: The General Problem Solver" 
-  "The General problem Solver, developed in 1957 by Alan Newell and Herbert"
-  "Simon, embodied a grandiose vision: a single computer program that could"
-  "solve ANY problem.  GPS caused quite a stir ..."
-  (:section "4.4 Stage 4: test")
-  ((requires "gps1"))
-  "Here are some examples of using GPS"
-  "The first example works with a complex chain of steps."
-  ((gps '(son-at-home car-needs-battery have-money have-phone-book)
-       '(son-at-school)
-       *school-ops*) => SOLVED @ 118)
-  "The next example fails because there is no way to make the car work,"
-  "because we can't contact the shop to get the battery fixed."
-  ((gps '(son-at-home car-needs-battery have-money)
-       '(son-at-school)
-       *school-ops*) => NIL)
-  "The third example is easy, because the car is currently working."
-  ((gps '(son-at-home car-works)
-       '(son-at-school)
-       *school-ops*) => SOLVED)
-
-  (:section "4.7 The Clobbered Sibling Goal Problem")
-  "In the next example, GPS incorrectly reports success, when in fact it has"
-  "spent the money on the battery, and thus should fail."
-  ((gps '(son-at-home have-money car-works)
-       '(have-money son-at-school)
-       *school-ops*) => SOLVED @ 120)
-  "The bug is that when (EVERY #'ACHIEVE GOALS) returns true, it means all the"
-  "goals were achieved in turn, but they might not still be all true."
-
-  (:section "4.8 The Leaping before You Look Problem") 
-  "What happens if we move the HAVE-MONEY goal to the end?"
-  ((gps '(son-at-home car-needs-battery have-money have-phone-book)
-       '(have-money son-at-school)
-       *school-ops*) => SOLVED @ 121)
-  "GPS returns nil, but only after executing all the actions."
-  "I call this the 'leaping before you look' problem, because if you asked"
-  "the program to solve for the two goals (JUMP-OFF-CLIFF LAND-SAFELY) it"
-  "would happily jump first, only to discover that it had no operator to land"
-  "safely.  This is less than prudent behavior."
-
-  (:section "4.9 The Recursive Subgoal Problem")
-  "We won't show the problem (because it gets into an infinite loop),"
-  "but we will add the new operator to the *school-ops*; we'll use it later."
-  ((push (make-op :action 'ask-phone-number
-               :preconds '(in-communication-with-shop)
-               :add-list '(know-phone-number))
-	 *school-ops*) @ 122)
-
-  (:section "4.11 GPS Version 2: A More General problem Solver")
-  "At this point we are ready to put together a new version of GPS with"
-  "solutions for the 'running around the block,' 'prerequisite clobbers"
-  "sibling goal,' 'leaping before you look,' and 'recursive subgoal' problems."
-  "The most important change is that, instead of printing a message when each"
-  "operator is applied, we will instead have GPS return the resulting state."
-  ((requires "gps"))
-  "We use the list of operators that includes the 'asking the shop their"
-  "phone number' operator." 
-  ((push (make-op :action 'ask-phone-number
-               :preconds '(in-communication-with-shop)
-               :add-list '(know-phone-number))
-      *school-ops*))
-  ((use *school-ops*) => 7 @ 130)
- "First we make sure the new version works on some of the examples that"
- "version 1 worked on:"
-  ((gps '(son-at-home car-needs-battery have-money have-phone-book)
-	'(son-at-school)) =>
-	((START)
-	 (EXECUTING LOOK-UP-NUMBER) 
-	 (EXECUTING TELEPHONE-SHOP)
-	 (EXECUTING TELL-SHOP-PROBLEM)
-	 (EXECUTING GIVE-SHOP-MONEY)
-	 (EXECUTING SHOP-INSTALLS-BATTERY)
-	 (EXECUTING DRIVE-SON-TO-SCHOOL)) @ 131)
-  "We can see what is going on here by turning on debugging temporarily:"
-  ((debug :gps))
-  ((gps '(son-at-home car-needs-battery have-money have-phone-book)
-	'(son-at-school)) =>
-	((START)
-	 (EXECUTING LOOK-UP-NUMBER) 
-	 (EXECUTING TELEPHONE-SHOP)
-	 (EXECUTING TELL-SHOP-PROBLEM)
-	 (EXECUTING GIVE-SHOP-MONEY)
-	 (EXECUTING SHOP-INSTALLS-BATTERY)
-	 (EXECUTING DRIVE-SON-TO-SCHOOL)) @ 131)
-  ((undebug))
-  "Here is another old example:"
-  ((gps '(son-at-home car-works)
-       '(son-at-school)) =>
-       ((START)
-	(EXECUTING DRIVE-SON-TO-SCHOOL)) @ 132)
-  "Now we see that version 2 can handle the three cases version 1 got wrong."
-  "In each case the program avoids an infinite loop, and also avoids leaping"
-  "before it looks."
-  ((gps '(son-at-home car-needs-battery have-money have-phone-book)
-       '(have-money son-at-school)) => NIL)
-  ((gps '(son-at-home car-needs-battery have-money have-phone-book)
-       '(son-at-school have-money)) => NIL)
-  ((gps '(son-at-home car-needs-battery have-money)
-       '(son-at-school)) => NIL)
-  "Finally, we see the new GPS also works on trivial problems:"
-  ((gps '(son-at-home) '(son-at-home)) => ((START)))
-
-  (:section "4.12 The New Domain Problem: Monkey and Bananas")
-  "To show that GPS is at all general, we have to make it work in different"
-  "domains.  We start with a 'classic' AI problem: Monkey and Bananas"
-  ((use *banana-ops*) => 6 @ 133)
-  "We pose the problem of becoming not-hungry, given an initial state."
-  "GPS can find a solution to this problem:"
-  ((GPS '(at-door on-floor has-ball hungry chair-at-door)
-	'(not-hungry)) =>
-	((START)
-	 (EXECUTING PUSH-CHAIR-FROM-DOOR-TO-MIDDLE-ROOM)
-	 (EXECUTING CLIMB-ON-CHAIR)
-	 (EXECUTING DROP-BALL)
-	 (EXECUTING GRASP-BANANAS)
-	 (EXECUTING EAT-BANANAS)) @ 133)
-  "Notice we did not need to make any changes at all to the GPS program."
-  "We just used a different set of operators."
-
-  (:section "4.13 The Maze Searching Domain")
-  "Next we will consider another 'classic' problem, maze searching."
-  "We will assume a particular maze, diagrammed on page 134."
-  ((use *maze-ops*) => 48 @ 134)
-  ((gps '((at 1)) '((at 25))) @ 135)
-
-  "We can define FIND-PATH to use the results of a GPS search:"
-  ((find-path 1 25) @ 136 => 
-   (1 2 3 4 9 8 7 12 11 16 17 22 23 24 19 20 25))
-  ((find-path 1 1) => (1))
-  ((equal (find-path 1 25) (reverse (find-path 25 1))) => T)
-
-  (:section "4.14 The Blocks World Domain")
-  "Another domain that has attracted more than its share of attention in AI"
-  "circles is the blocks world domain."
-  ((use (make-block-ops '(a b))) => 4 @ 137)
-  "The simplest possible problem is stacking one block on another."
-  ((gps '((a on table) (b on table) (space on a) (space on b)
-         (space on table))
-       '((a on b) (b on table))) =>
-       ((START)
-	(EXECUTING (MOVE A FROM TABLE TO B))))
-  "Here is a slightly more complex problem: inverting a stack of two blocks."
-  "This time we show the debugging output:"
-  ((debug :gps) @ 138)
-  ((gps '((a on b) (b on table) (space on a) (space on table))
-       '((b on a))) =>
-       ((START)
-	(EXECUTING (MOVE A FROM B TO TABLE))
-	(EXECUTING (MOVE B FROM TABLE TO A))))
-  ((undebug))
-  "Now we move on to the three block world."
-  ((use (make-block-ops '(a b c))) => 18)
-  "We try some problems:"
-  ((gps '((a on b) (b on c) (c on table) (space on a) (space on table))
-       '((b on a) (c on b))) =>
-       ((START)
-	(EXECUTING (MOVE A FROM B TO TABLE))
-	(EXECUTING (MOVE B FROM C TO A))
-	(EXECUTING (MOVE C FROM TABLE TO B))))
-  ((gps '((c on a) (a on table) (b on table)
-         (space on c) (space on b) (space on table))
-       '((c on table) (a on b))) =>
-       ((START)
-	(EXECUTING (MOVE C FROM A TO TABLE))
-	(EXECUTING (MOVE A FROM TABLE TO B))) @ 141)
-  ((gps '((a on b) (b on c) (c on table) (space on a) (space on table))
-	'((b on a) (c on b))) @ 141 =>
-	((START)
-	 (EXECUTING (MOVE A FROM B TO TABLE))
-	 (EXECUTING (MOVE B FROM C TO A))
-	 (EXECUTING (MOVE C FROM TABLE TO B))))
-
-  ((gps '((a on b) (b on c) (c on table) (space on a) (space on table))
-	'((c on b) (b on a))) =>
-	((START)
-	 (EXECUTING (MOVE A FROM B TO TABLE))
-	 (EXECUTING (MOVE B FROM C TO A))
-	 (EXECUTING (MOVE C FROM TABLE TO B))))
-  "The Sussman Anomaly"
-  ((setf start '((c on a) (a on table) (b on table) (space on c)
-                (space on b) (space on table))) @ 142)
-  ((gps start '((a on b) (b on c))) => NIL)
-  ((gps start '((b on c) (a on b))) => NIL)
-
-  (:section "4.16 The Not Looking after You Don't Leap Problem")
-  ((use (push (op 'taxi-son-to-school
-               :preconds '(son-at-home have-money)
-               :add-list '(son-at-school)
-               :del-list '(son-at-home have-money))
-           *school-ops*)) @ 143)
-  ((debug :gps))
-  ((gps '(son-at-home have-money car-works)
-       '(son-at-school have-money)) => NIL)
-  ((undebug))
-  )
-
-(defexamples 5 "Eliza: Dialog with a Machine"
-  "ELIZA was one of the first programs to feature English output as well as input."
-  "The program was named after the heroine of Pygmalion, who was taught to"
-  "speak proper English by a dedicated teacher."
-  (:section "5.2 Pattern Matching")
-  ((requires "eliza1"))
-  "The hard part is the notion of pattern matching and transformation."
-  "All symbols beginning with ? are variables for the pattern matcher."
-  "First we see how to substitute variable/value pairs into expressions:"
-  ((sublis '((?X . vacation)) '(what would it mean to you if you got a ?X ?))
-   => (what would it mean to you if you got a VACATION ?) @ 156)
-  "Now a version of pat-match that works with such pairs:"
-  ((pat-match '(I need a ?x) '(I need a vacation))  @ 158)
-  "Showing how to plug it in:"
-  ((sublis (pat-match '(I need a ?x) '(I need a vacation)) 
-	   '(what would it mean to you if you got a ?X ?))
-   => (what would it mean to you if you got a VACATION ?) @ 159)
-  ((pat-match '(I need a ?x) '(I really need a vacation)) => nil)
-  ((pat-match '(this is easy) '(this is easy)) => ((t . t)))
-  ((pat-match '(?x is ?x) '((2 + 2) is 4)) => nil)
-  ((pat-match '(?x is ?x) '((2 + 2) is (2 + 2))) => ((?x 2 + 2)))
-  ((pat-match '(?P need . ?X) '(I need a long vacation))
-   => ((?X a long vacation) (?P . I)))
-
-  (:section "5.3 Segment Pattern Matching")
-  "We show how to have a variable that will match more than one element."
-  "We call these segment variables, and denote them (?* name)."
-  ((pat-match '((?* ?p) need (?* ?x))
-	      '(Mr Hulot and I need a vacation)) @ 160)
-  (:section "5.4 The Eliza Program: A Rule-Based Translator")
-  ((requires "eliza"))
-  "We can't show you an interactive ELIZA session, because the replies are"
-  "random, and thus change every time.  You can experiment on your own by"
-  "evaluating (ELIZA) and typing in your end of the conversation.
-  Type (good bye) when you are done."
-  )
-
-(defexamples 6 "Building Software Tools"
-  "In chapters 4 and 5 we were concerned with buildinng two particular"
-  "programs, GPS and ELIZA.  In this chapter, we will reexamine those"
-  "two programs to discover some common patterns.  Those patterns will be"
-  "abstracted out to form reusable software tools."
-  (:section "6.2 A Pattern-Matching tool")
-  ((requires "patmatch"))
-  ((pat-match '(x = (?is ?n numberp)) '(x = 34)) => ((?n . 34)) @ 179)
-  ((pat-match '(x = (?is ?n numberp)) '(x = x)) => NIL)
-  ((pat-match '(?x (?or < = >) ?y) '(3 < 4)) => ((?Y . 4) (?X . 3)))
-  ((pat-match '(x = (?and (?is ?n numberp) (?is ?n oddp))) '(x = 3)) 
-   => ((?N . 3)))
-  ((pat-match '(?x /= (?not ?x)) '(3 /= 4)) => ((?X . 3)) @ 180)
-  ((pat-match '(?x > ?y (?if (> ?x ?y))) '(4 > 3)) => ((?Y . 3) (?X . 4)))
-  ((pat-match '(a (?* ?x) d) '(a b c d)) => ((?X B C)) @ 185)
-  ((pat-match '(a (?* ?x) (?* ?y) d) '(a b c d)) => ((?Y B C) (?X)))
-  ((pat-match '(a (?* ?x) (?* ?y) ?x ?y) '(a b c d (b c) (d))) 
-   => ((?Y D) (?X B C)) @ 186)
-  ((pat-match '(?x ?op ?y is ?z (?if (eql (funcall ?op ?x ?y) ?z))) 
-	      '(3 + 4 is 7))
-   => ((?Z . 7) (?Y . 4) (?OP . +) (?X . 3)))
-  ((pat-match '(?x ?op ?y (?if (funcall ?op ?x ?y))) '(3 > 4)) => NIL)
-  ((pat-match-abbrev '?x* '(?* ?x)) => (?* ?X) @ 187)
-  ((pat-match-abbrev '?y* '(?* ?y)) => (?* ?Y))
-  ((setf axyd (expand-pat-match-abbrev '(a ?x* ?y* d)))
-   => (A (?* ?X) (?* ?Y) D))
-  ((pat-match axyd '(a b c d)) => ((?Y B C) (?X)))
-  ((pat-match '(((?* ?x) (?* ?y)) ?x ?y) '((a b c d) (a b) (c d))) 
-   => NIL)
-  ((requires "eliza-pm"))
-
-  (:section "6.4 A Set of Searching Tools")
-  ((requires "search"))
-  ((debug :search) @ 192)
-  "We can search through the binary tree, looking for, say, 12 as the goal."
-  "With breadth-first search this would yield an infinite loop, so we won't"
-  "do it.  Breadth-first search works better:"
-  ((breadth-first-search 1 (is 12) 'binary-tree) => 12 @ 193)
-  ((depth-first-search 1 (is 12) (finite-binary-tree 15)) => 12 @ 193)
-  "Guiding the Search"
-  "Best-first search takes an additional argument which estimates how close"
-  "we are to the goal.  We call this the cost function."
-  ((best-first-search 1 (is 12) #'binary-tree (diff 12)) => 12 @ 195)
-  ((best-first-search 1 (is 12) #'binary-tree (price-is-right 12)) => 12)
-  "The function beam-search is just like best-first-search, except that after"
-  "we sort the states, we then take only the first beam-width states."
-  ((beam-search 1 (is 12) #'binary-tree (price-is-right 12) 2) => 12)
-  "As a concrete example of a problem that can be solved by search,"
-  "consider planning a flight across North America in a plane whose range is"
-  "limited to 1000 kilometers.  Here we plan a trip from SF to Boston."
-  ((path-state (trip (city 'san-francisco) (city 'boston)))
-   => (BOSTON 71.05 42.21) @ 199)
-  ((path-state (trip (city 'boston) (city 'san-francisco)))
-   => (SAN-FRANCISCO 122.26 37.47))
-  ((undebug :search))
-  ((show-city-path (trip (city 'san-francisco) (city 'boston) 1)) @ 201)
-  ((show-city-path (trip (city 'boston) (city 'san-francisco) 1)))
-  ((show-city-path (trip (city 'boston) (city 'san-francisco) 3)) @ 202)
-  ((iter-wide-search 1 (is 12) (finite-binary-tree 15) (diff 12))  => 12 @ 205)
-  ((tree-search '(1) (is 6) #'next2 #'prepend) => 6 @ 208)
-  ((graph-search '(1) (is 6) #'next2 #'prepend) => 6)
-  ((path-states
-    (a*-search (list (make-path :state 1)) (is 6) 
-               #'next2 #'(lambda (x y) 1) (diff 6))) => (6 5 3 1) @ 210)
-  (:section "6.5 GPS as Search")
-  ((requires "gps-srch"))
-  ((setf start '((c on a) (a on table) (b on table) (space on c)
-                 (space on b) (space on table))) @ 213)
-  ((use (make-block-ops '(a b c))) => 18)
-  ((search-gps start '((a on b) (b on c)))
-   => ((START)
-       (EXECUTING (MOVE C FROM A TO TABLE))
-       (EXECUTING (MOVE B FROM TABLE TO C))
-       (EXECUTING (MOVE A FROM TABLE TO B))) @ 213)
-  ((search-gps start '((b on c) (a on b)))
-   => ((START)
-       (EXECUTING (MOVE C FROM A TO TABLE))
-       (EXECUTING (MOVE B FROM TABLE TO C))
-       (EXECUTING (MOVE A FROM TABLE TO B))))
-  )
-
-(defexamples 7 "STUDENT: Solving Algebra Word Problems"
-  "STUDENT was another early language understanding program, written by Daniel"
-  "Bobrow in 1964.  It was designed to read and solve the kind of word"
-  "problems found in high school algebra books."
-  (:section "7.1 Translating English into Equations")
-  ((requires "student"))
-  ((translate-to-expression '(if z is 3 |,| what is twice z))
-   => ((= z 3) (= what (* 2 z))) @ 222)
-  (:section "7.2 Solving Algebra Equations")
-  ((trace isolate solve) @ 229)
-  ((solve-equations '((= (+ 3 4) (* (- 5 (+ 2 x)) 7))
-                   (= (+ (* 3 x) y) 12))) => nil)
-  ((untrace isolate solve))
-  (:section "7.3 Examples")
-  ((student '(If the number of customers Tom gets is twice the square of
-           20 % of the number of advertisements he runs |,| 
-           and the number of advertisements is 45 |,|
-           then what is the number of customers Tom gets ?)) => nil @ 231)
-  ((student '(The daily cost of living for a group is the overhead cost plus 
-           the running cost for each person times the number of people in 
-           the group |.|  This cost for one group equals $ 100 |,|
-           and the number of people in the group is 40 |.|
-           If the overhead cost is 10 times the running cost |,|
-           find the overhead and running cost for each person |.|)))
-  ((student '(Fran's age divided by Robin's height is one half Kelly's IQ |.|
-           Kelly's IQ minus 80 is Robin's height |.|
-           If Robin is 4 feet tall |,| how old is Fran ?)))
-  ((student '(Fran's age divided by Robin's height is one half Kelly's IQ |.|
-           Kelly's IQ minus 80 is Robin's height |.|
-           If Robin is 0 feet tall |,| how old is Fran ?)))
-  )
-
-(defexamples 8 "Symbolic Mathematics: A Simplification Program"
-  "'Symbolic mathematics' is to numerical mathematics as algebra is to"
-  "arithmetic: it deals with variables and expressions, not just numbers."
-  "This chapter develops a program that simplifies algebraic expressions."
-  "We then show that differentiation and even integration can be seen as"
-  "special cases of 'simplification.'  (Note that we replace calls to the"
-  "interactive function SIMPLIFIER with calls to the function SIMP.)"
-  (:section "8.2 Simplification Rules")
-  ((requires "macsymar"))
-  ((simp '(2 + 2)) => 4 @ 245)
-  ((simp '(5 * 20 + 30 + 7)) => 137 )
-  ((simp '(5 * x - (4 + 1) * x)) => 0 )
-  ((simp '(y / z * (5 * x - (4 + 1) * x))) => 0 )
-  ((simp '((4 - 3) * x + (y / y - 1) * z)) => X )
-  ((simp '(1 * f(x) + 0)) => (F X) )
-
-  (:section "8.3 Associativity and Commutativity")
-  ((simp '(3 * 2 * x)) => (6 * X) @ 247)
-  ((simp '(2 * x * x * 3)) => (6 * (X ^ 2)) )
-  ((simp '(2 * x * 3 * y * 4 * z * 5 * 6)) => (720 * (X * (Y * Z))) )
-  ((simp '(3 + x + 4 + x)) => ((2 * X) + 7) )
-  ((simp '(2 * x * 3 * x * 4 * (1 / x) * 5 * 6)) => (720 * X))
-
-  (:section "8.4 Logs, Trig, and Differentiation")
-  ((simp '(d (x + x) / d x)) => 2 @ 250)
-  ((simp '(d (a * x ^ 2 + b * x + c) / d x)) => ((2 * (A * X)) + B) )
-  "For the next one, note we had an error in the first printing of the book;"
-  "the sign was reversed on the (d (u / v) ...) rule."
-  ((simp '(d ((a * x ^ 2 + b * x + c) / x) / d x)) 
-   => (((X * ((2 * (A * X)) + B)) - ((A * (X ^ 2)) + ((B * X) + C))) /
-       (X ^ 2)))
-  ((simp '(log ((d (x + x) / d x) / 2))) => 0 )
-  ((simp '(log(x + x) - log x)) => (LOG 2))
-  ((simp '(x ^ cos pi)) => (1 / X) )
-  "These next two examples were also affected by the (d (u / v) ...) rule."
-  ((simp '(d (3 * x + (cos x) / x) / d x)) 
-   => ((((X * (- (SIN X))) - (COS X)) / (X ^ 2)) + 3))
-  ((simp '(d ((cos x) / x) / d x)) 
-   => (((X * (- (SIN X))) - (COS X)) / (X ^ 2)))
-  ((simp '(d (3 * x ^ 2 + 2 * x + 1) / d x)) => ((6 * X) + 2))
-  ((simp '(sin(x + x) ^ 2 + cos(d x ^ 2 / d x) ^ 2)) => 1 )
-  ((simp '(sin(x + x) * sin(d x ^ 2 / d x) +
-	      cos(2 * x) * cos(x * d 2 * y / d y))) => 1 )
-
-  (:section "8.5 Limits of Rule-Based Approaches")
-  "In this section we return to some examples that pose problems."
-  "For the following, we would prefer (2 * (x + y))"
-  ((simp '(x + y + y + x)) => (X + (Y + (Y + X))))
-  "For the following, we would prefer (7 * X) and (Y + (8 * X)), respectively:"
-  ((simp '(3 * x + 4 * x)) => ((3 * X) + (4 * X)))
-  ((simp '(3 * x + y + x + 4 * x)) => ((3 * X) + (Y + (X + (4 * X)))) )
-  "In chapter 15, we develop a new version of the program that handles this problem."
-
-  (:section "8.6 Integration")
-  ((set-simp-fn 'Int #'(lambda (exp) 
-			(integrate (exp-lhs exp) (exp-rhs exp)))) @ 258)
-  ((simp '(Int x * sin(x ^ 2) d x)) => (1/2 * (- (COS (X ^ 2)))) )
-  ((simp '(Int ((3 * x ^ 3) - 1 / (3 * x ^ 3)) d x)) 
-   => ((3 * ((X ^ 4) / 4)) - (1/3 * ((X ^ -2) / -2))) )
-  ((simp '(Int (3 * x + 2) ^ -2/3 d x)) => (((3 * X) + 2) ^ 1/3) )
-  ((simp '(Int sin(x) ^ 2 * cos(x) d x)) => (((SIN X) ^ 3) / 3) )
-  ((simp '(Int sin(x) / (1 + cos(x)) d x)) => (-1 * (LOG ((COS X) + 1))) )
-  ((simp '(Int (2 * x + 1) / (x ^ 2 + x - 1) d x)) 
-   => (LOG ((X ^ 2) + (X - 1))) )
-  ((simp '(Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)) 
-   => (8 * ((1/3 * (((X ^ 3) + 2) ^ -2)) / -2)) )
-  ((set-simp-fn 'Int 
-	       #'(lambda (exp)
-		   (unfactorize
-		    (factorize
-		     (integrate (exp-lhs exp) (exp-rhs exp)))))) @ 259)
-  ((simp '(Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)) 
-   => (-4/3 * (((X ^ 3) + 2) ^ -2)) )
-  )
-
-(defexamples 9 "Efficiency Issues"
-  "One of the reasons Lisp has enjoyed a long history is because it is an"
-  "ideal language for what is called rapid-prototyping or rapid development."
-  "Most real AI programs deal with large amounts of data.  Thus, efficiency"
-  "is important.  This chapter shows some ways to make programs efficient."
-  (:section "9.1 Caching Results of Previous Computations: Memoization")
-  ((defun fib (n) (if (<= n 1) 1 (+ (fib (- n 1)) (fib (- n 2))))) @ 269)
-  ((setf memo-fib (memo #'fib)) @ 270)
-  ((trace fib))
-  ((funcall memo-fib 3) => 3 @ 270)
-  ((funcall memo-fib 3) => 3)
-  ((untrace fib))
-  ((memoize 'fib) @ 272)
-  ((trace fib))
-  ((fib 5) => 8)
-  ((fib 5) => 8)
-  ((fib 6) => 13)
-  ((untrace fib))
-)
-
-(defexamples 10 "Low-Level Efficiency Issues"
-  "The efficiency techniques of the previous chapter all involved fairly"
-  "significant changes to an algorithm.  But what happens when you are already"
-  "using the best imaginable algorithms, and performance is still a problem?"
-  (:section "10.1 Use Declarations")
-  "Compare these functions with and without declarations:"
-  ((defun f (x y)
-     (declare (fixnum x y) (optimize (safety 0) (speed 3)))
-     (the fixnum (+ x y))) @ 318)
-  ((defun g (x y) (+ x y)))
-  "Here is the disassembled code for f and g:"
-  ((disassemble 'f))
-  ((disassemble 'g) @ 319)
-)
-
-(defexamples 11 "Logic Programming"
-  "The idea behind logic programming is that the programmer should state the"
-  "relationships that describe a problem and its solution."
-  "In this chapter we develop an interpreter for the Prolog language."
-
-  (:section "11.1 Idea 1: A Uniform Data Base")
-  ((requires "prolog1"))
-  "First let's make sure we're dealing with a brand new database."
-  ((clear-db))
-  "Facts are entered into the data base with the <- macro"
-  ((<- (likes Kim Robin)) @ 350)
-  ((<- (likes Sandy Lee)))
-  ((<- (likes Sandy Kim)))
-  ((<- (likes Robin cats)))
-  "We can also enter rules, which state contingent facts."
-  ((<- (likes Sandy ?x) (likes ?x cats)) @ 351)
-  ((<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim)))
-
-  (:section "11.2 Idea 2: Unification of Logic Variables")
-  ((requires "unify"))
-  ((pat-match '(?x + ?y) '(2 + 1)) => ((?y . 1) (?x . 2)) @ 352)
-  ((unify '(?x + 1) '(2 + ?y)) => ((?y . 1) (?x . 2)))
-  ((unify '(f ?x) '(f ?y)) => ((?x . ?y)))
-  ((unify '(?a + ?a = 0) '(?x + ?y = ?y)) => ((?y . 0) (?x . ?y) (?a . ?x)))
-  ((unifier '(?a + ?a = 0) '(?x + ?y = ?y)) => (0 + 0 = 0))
-  "Let's try UNIFY on some (more) examples:"
-  ((unify '(?x ?y a) '(?y ?x ?x)) => ((?y . a) (?x . ?y)) @ 357)
-  ((unify '?x '(f ?x)) => nil)
-  ((unify 'a 'a) => ((t . t)))
-  "Here are some examples of UNIFIER:"
-  ((unifier '(?x ?y a) '(?y ?x ?x)) => (a a a))
-  ((unifier '((?a * ?x ^ 2) + (?b * ?x) + ?c) 
-	    '(?z + (4 * 5) + 3))
-   => ((?a * 5 ^ 2) + (4 * 5) + 3))
-
-  "Programming with Prolog"
-  "First we define the MEMBER relation in Prolog:"
-  ((<- (member ?item (?item . ?rest))) @ 358)
-  ((<- (member ?item (?x . ?rest)) (member ?item ?rest)))
-  "Now we can make some queries:"
-  ((?- (member 2 (1 2 3))))
-  ((?- (member 2 (1 2 3 2 1))))
-  ((?- (member ?x (1 2 3))))
-  "Let's add one more rule to the Sandy and the cats facts:"
-  ((<- (likes ?x ?x)) @ 363)
-  "Now we can ask some queries:"
-  ((?- (likes Sandy ?who)) @ 365)
-  ((?- (likes ?who Sandy)))
-  ((?- (likes Robin Lee)))
-  ((?- (likes ?x ?y) (likes ?y ?x)) @ 366)
-
-  (:section "11.3 Idea 3: Automatic Backtracking")
-  "Now we load the version that does automatic backtracking one step at a time"
-  "as opposed to the previous version, which collects all answers at once."
-  "Since we don't want to involve you, the user, in typing input to move on"
-  "to the next step, we supply the input (a ; or a .) as in the book."
-  "Unfortunately, it is not specified in Common Lisp whether read-char echoes"
-  "the character it reads, so you may or may not see the ; and . characters."
-  ((requires "prolog"))
-  "Let's add the definition of the relation LENGTH:"
-  ((<- (length () 0)) @ 370)
-  ((<- (length (?x . ?y) (1+ ?n)) (length ?y ?n)))
-  "Here are some queries:"
-  ((?- (length (a b c d) ?n)) :input ";")
-  ((?- (length ?list (1+ (1+ 0)))) :input ";")
-  ((?- (length ?list ?n)) :input ";;.")
-  ((?- (length ?l (1+ (1+ 0))) (member a ?l)) :input ";;")
-  "(We won't try the example that leads to an infinite loop.)"
-  (:section "11.4 The Zebra Puzzle")
-  "First we define the NEXTO and IRIGHT (to the immediate right) relations:"
-  ((<- (nextto ?x ?y ?list) (iright ?x ?y ?list)) @ 374)
-  ((<- (nextto ?x ?y ?list) (iright ?y ?x ?list)))
-  ((<- (iright ?left ?right (?left ?right . ?rest))))
-  ((<- (iright ?left ?right (?x . ?rest)) 
-       (iright ?left ?right ?rest)))
-  ((<- (= ?x ?x)))
-  "Now we define the zebra puzzle:"
-  ((<- (zebra ?h ?w ?z)
-       ;; Each house is of the form:
-       ;; (house nationality pet cigarette drink house-color)
-       (= ?h ((house norwegian ? ? ? ?)	;1,10
-	      ? 
-	      (house ? ? ? milk ?) ? ?)) ; 9
-       (member (house englishman ? ? ? red) ?h)	; 2
-       (member (house spaniard dog ? ? ?) ?h) ; 3
-       (member (house ? ? ? coffee green) ?h) ; 4
-       (member (house ukrainian ? ? tea ?) ?h) ; 5
-       (iright (house ? ? ? ? ivory)	; 6
-	       (house ? ? ? ? green) ?h)
-       (member (house ? snails winston ? ?) ?h)	; 7
-       (member (house ? ? kools ? yellow) ?h) ; 8
-       (nextto (house ? ? chesterfield ? ?) ;11
-	       (house ? fox ? ? ?) ?h)
-       (nextto (house ? ? kools ? ?)	;12
-	       (house ? horse ? ? ?) ?h)
-       (member (house ? ? luckystrike oj ?) ?h)	;13
-       (member (house japanese ? parliaments ? ?) ?h) ;14
-       (nextto (house norwegian ? ? ? ?) ;15
-	       (house ? ? ? ? blue) ?h)
-       (member (house ?w ? ? water ?) ?h) ;Q1
-       (member (house ?z zebra ? ? ?) ?h))) ;Q2
-  "If you want to test this out, run the following query:"
-  "   ((?- (zebra ?houses ?water-drinker ?zebra-owner)))"
-  "It is not included as an example because it takes a minute or so to run."
-  )
-
-
-(defexamples 12 "Compiling Logic Programs"
-  "This chapter presents a compiler that translates from Prolog to Lisp."
-  "Unfortunatley, there's not much to see in terms of examples."
-  "But we load the files for you, in case you want to play with them."
-  ((requires "prologc1" "prologc2" "prologcp"))
-  ((prolog-compile 'likes) @ 389)
-  ((prolog-compile 'member))
-  )
-
-(defexamples 13 "Object Oriented Programming"
-  "It is only natural that a wide range of programming styles have been"
-  "introduced to attack the wide range of problems in this book."
-  "One style not yet covered is 'object-oriented programming'."
-  "Peter Wegner (1987) proposes the following formula as a definition:"
-  "Object-orientation = Objects + Classes + Inheritance"
-
-  (:section "13.2 Objects")
-  "Now we're ready to get started."
-  ((requires "clos"))
-  ((setf acct (new-account "J. Random Customer" 1000.00)) @ 438)
-  ((send acct 'withdraw 500.00) => 500.0)
-  ((send acct 'deposit 123.45) => 623.45)
-  ((send acct 'name) => "J. Random Customer")
-  ((send acct 'balance) => 623.45)
-
-  (:section "13.4 Classes")
-  "Now we define the class ACCOUNT with the define-class macro."
-  ((define-class account (name &optional (balance 0.00))
-        ((interest-rate .06))
-     (withdraw (amt) (if (<= amt balance)
-                       (decf balance amt)
-                       'insufficient-funds))
-     (deposit  (amt) (incf balance amt))
-     (balance  ()    balance)
-     (name     ()    name)
-     (interest ()    (incf balance (* interest-rate balance)))) @ 440)
-  "Here are the generic functions defined by this macro:"
-  ((setf acct2 (account "A. User" 2000.00)))
-  ((deposit acct2 42.00) => 2042.0)
-  ((interest acct2) => 2164.52)
-  ((balance acct2) => 2164.52 @ 441)
-  ((balance acct) => 623.45)
-
-  (:section "13.5 Delegation")
-  ((define-class password-account (password acct) ()
-     (change-password (pass new-pass)
-                      (if (equal pass password)
-                        (setf password new-pass)
-                        'wrong-password))
-     (otherwise (pass &rest args)
-                (if (equal pass password)
-                  (apply message acct args)
-                  'wrong-password))))
-  "Now we see how the class PASSWORD-ACCOUNT can be used to provide protection"
-  "for an existing account:"
-  ((setf acct3 (password-account "secret" acct2)) @ 441)
-  ((balance acct3 "secret") => 2164.52)
-  ((withdraw acct3 "guess" 2000.00) => WRONG-PASSWORD)
-  ((withdraw acct3 "secret" 2000.00) => 164.52)
-
-  (:section "13.7 CLOS: The Common Lisp Object System")
-  "Because some Lisp implementations can't convert a structure class into"
-  "a CLOS class, nor convert a regular function into a generic function,"
-  "we use the names account*, name*, balance*, interest-rate*.  If you were"
-  "doing a real application, not just some examples, you would choose one"
-  "implementation and get to use the regular names."
-  ; ?????? some problems here
-  ((defclass account* ()
-     ((name :initarg :name :reader name*)
-      (balance :initarg :balance :initform 0.00 :accessor balance*)
-      (interest-rate :allocation :class :initform .06 
-                     :reader interest-rate*))) @ 445)
-  ((setf a1 (make-instance 'account* :balance 5000.00
-                          :name "Fred")) @ 446)
-  ((name* a1) => "Fred")
-  ((balance* a1) => 5000.0)
-  ((interest-rate* a1) => 0.06)
-  ((defmethod withdraw* ((acct account*) amt)
-     (if (< amt (balance* acct))
-       (decf (balance* acct) amt)
-       'insufficient-funds)) @ 446)
-  ((defclass limited-account (account*)
-     ((limit :initarg :limit :reader limit))))
-  ((defmethod withdraw* ((acct limited-account) amt)
-     (if (> amt (limit acct))
-       'over-limit
-       (call-next-method))))
-  ((setf a2 (make-instance 'limited-account
-                          :name "A. Thrifty Spender"
-                          :balance 500.00 :limit 100.00)) @ 447)
-  ((name* a2) => "A. Thrifty Spender")
-  ((withdraw* a2 200.00) => OVER-LIMIT)
-  ((withdraw* a2 20.00) => 480.0)
-
-  (:section "13.8 A CLOS Example: Searching Tools")
-  ((defclass problem ()
-     ((states :initarg :states :accessor problem-states))) @ 449)
-  ((defmethod searcher ((prob problem))
-  "Find a state that solves the search problem."
-  (cond ((no-states-p prob) fail)
-        ((goal-p prob) (current-state prob))
-        (t (let ((current (pop-state prob)))
-             (setf (problem-states prob)
-                   (problem-combiner
-                     prob
-                     (problem-successors prob current)
-                     (problem-states prob))))
-           (searcher prob)))))
-  ((defmethod current-state ((prob problem))
-    "The current state is the first of the possible states."
-    (first (problem-states prob))))
-
-  ((defmethod pop-state ((prob problem))
-  "Remove and return the current state."
-  (pop (problem-states prob))))
-
-  ((defmethod no-states-p ((prob problem))
-  "Are there any more unexplored states?"
-  (null (problem-states prob))))
-
-  ((defmethod searcher :before ((prob problem))
-     (dbg 'search "~&;; Search: ~a" (problem-states prob))) @ 450)
-
-  ((defclass eql-problem (problem)
-     ((goal :initarg :goal :reader problem-goal))))
-
-  ((defmethod goal-p ((prob eql-problem))
-  (eql (current-state prob) (problem-goal prob))))
-
-  ((defclass dfs-problem (problem) ()
-     (:documentation "Depth-first search problem.")))
-
-  ((defclass bfs-problem (problem) ()
-     (:documentation "Breadth-first search problem.")))
-
-  ((defmethod problem-combiner ((prob dfs-problem) new old)
-     "Depth-first search looks at new states first."
-     (append new old)))
-
-  ((defmethod problem-combiner ((prob bfs-problem) new old)
-     "Depth-first search looks at old states first."
-     (append old new)))
-
-  ((defclass binary-tree-problem (problem) ()) @ 451)
-
-  ((defmethod problem-successors ((prob binary-tree-problem) state)
-     (let ((n (* 2 state)))
-       (list n (+ n 1)))))
-
-  ((defclass binary-tree-eql-bfs-problem
-     (binary-tree-problem eql-problem bfs-problem) ()))
-
-  ((setf p1 (make-instance 'binary-tree-eql-bfs-problem 
-                          :states '(1) :goal 12)))
-  ((searcher p1) => 12)
-
-  ((defclass best-problem (problem) ()
-     (:documentation "A Best-first search problem.")) @ 452)
-
-  ((defmethod problem-combiner ((prob best-problem) new old)
-     "Best-first search sorts new and old according to cost-fn."
-     (sort (append new old) #'<
-           :key #'(lambda (state) (cost-fn prob state)))))
-
-  ((defmethod cost-fn ((prob eql-problem) state)
-     (abs (- state (problem-goal prob)))))
-
-  ((defclass beam-problem (problem)
-     ((beam-width :initarg :beam-width :initform nil
-                  :reader problem-beam-width))))
-
-  ((defmethod problem-combiner :around ((prob beam-problem) new old)
-     (let ((combined (call-next-method)))
-       (subseq combined 0 (min (problem-beam-width prob) 
-                               (length combined))))))
-
-  ((defclass binary-tree-eql-best-beam-problem
-     (binary-tree-problem eql-problem best-problem beam-problem) 
-     ()))
-
-  ((setf p3 (make-instance 'binary-tree-eql-best-beam-problem 
-                          :states '(1) :goal 12 :beam-width 3)))
-
-  ((searcher p3) => 12)
-
-  ((defclass trip-problem (binary-tree-eql-best-beam-problem) 
-     ((beam-width :initform 1))) @ 453)
-
-  ((defmethod cost-fn ((prob trip-problem) city)
-     (air-distance (problem-goal prob) city)))
-
-  ((defmethod problem-successors ((prob trip-problem) city)
-     (neighbors city)))
-
-  ((setf p4 (make-instance 'trip-problem 
-                          :states (list (city 'new-york)) 
-                          :goal (city 'san-francisco))))
-
-  ((searcher p4) =>
-   (SAN-FRANCISCO 122.26 37.47))
-
-  (:section "13.9 Is CLOS Object-oriented?")
-  ((defmethod conc ((x null) y) y) @ 454)
-
-  ((defmethod conc (x (y null)) x))
-
-  ((defmethod conc ((x list) (y list))
-     (cons (first x) (conc (rest x) y))))
-
-  ((defmethod conc ((x vector) (y vector))
-     (let ((vect (make-array (+ (length x) (length y)))))
-       (replace vect x)
-       (replace vect y :start1 (length x)))))
-
-  ((conc nil '(a b c)) => (A B C) @ 455)
-  ((conc '(a b c) nil) => (A B C))
-  ((conc '(a b c) '(d e f)) => (A B C D E F))
-  ((conc '#(a b c) '#(d e f)) => #(A B C D E F))
-  )
-
-(defexamples 14 "Knowledge Representation and Reasoning"
-  "In this chapter we explore means of indexing facts so that they can be"
-  "retrieved and reasoned with efficiently."
-  "Section 14.1 to 14.7 discuss problems with logical reasoning systems"
-  "such as Prolog."
-  (:section "14.8 A Solution to the Indexing Problem")
-  "Here we show how to index facts in a kind of table that makes it easy to"
-  "add, delete, and retrieve entries.  We will develop an extension of the"
-  "trie or discrimination tree data structure built in section 10.5 (page 344)."
-  ((requires "krep1"))
-  "Now we define a function to test the indexing routine.  Compare the output"
-  "with figure 14.1 on page 474."
-  ((test-index) @ 478)
-  "Here is an example of fetching from the index"
-  ((fetch '(p ? c)) @ 480 =>
-   (((P B C) (P A C))
-    ((P A ?X))))
-  "We can make a change to rename variables before indexing facts."
-  ((defun index (key)
-     "Store key in a dtree node.  Key must be (predicate . args);
-  it is stored in the predicate's dtree."
-     (dtree-index key (rename-variables key) ; store unique vars
-		  (get-dtree (predicate key)))) @ 481)
-  "We have to reindex:"
-  ((test-index))
-  "We are now ready to test the retrieval mechanism:"
-  ((fetch '(p ?x c)) @ 481)
-  ((retrieve '(p ?x c)) @ 481)
-  ((retrieve-matches '(p ?x c)) =>
-   ((P A C) (P A C) (P B C)))
-  ((retrieve-matches '(p ?x (?fn c))) =>
-   ((P A (?FN C)) (P A (F C)) (P B (F C))))
-  ((query-bind (?x ?fn) '(p ?x (?fn c))
-	       (format t "~&P holds between ~a and ~a of c." ?x ?fn)) @ 482)
-
-  (:section "14.10 Solutions to the Expressiveness Problems")
-  "In this section we introduce a frame-like language, using the primitives"
-  "sub, rel, ind, val, and and."
-  ((requires "krep"))
-  "We add some facts about dogs and bears, both as individuals and species:"
-  ((add-fact '(sub dog animal)) @ 488)
-  ((add-fact '(sub bear animal)))
-  ((add-fact '(ind Fido dog)))
-  ((add-fact '(ind Yogi bear)))
-  ((add-fact '(val color Yogi brown)))
-  ((add-fact '(val color Fido golden)))
-  ((add-fact '(val latin-name bear ursidae)))
-  ((add-fact '(val latin-name dog canis-familiaris)))
-  "Now retrieve-fact is used to answer three questions: What kinds of animals"
-  "are there?"
-  ((retrieve-fact '(sub ?kind animal)) =>
-   (((?KIND . DOG))
-    ((?KIND . BEAR))))
-  "What are the Latin names of each kind of animal?"
-  ((retrieve-fact '(and (sub ?kind animal)
-                       (val latin-name ?kind ?latin))) =>
-   (((?LATIN . CANIS-FAMILIARIS) (?KIND . DOG))
-    ((?LATIN . URSIDAE) (?KIND . BEAR))))
-  "What are the colors of each individual bear?"
-  ((retrieve-fact '(and (ind ?x bear) (val color ?x ?c))) @ 489 =>
-   (((?C . BROWN) (?X . YOGI))))
-  ((test-bears) @ 492)
-  )
-
-(defexamples 15 "Symbolic Mathematics with Canonical Forms"
-  "This chapter uses a canonical representation for polynomials"
-  "to achieve a more efficient program than the rules-based one in Chapter 8."
-  (:section "15.1 A Canonical Form for Polynomials")
-  ((requires "cmacsyma"))
-  "We represent polynomials as vectors, with the variable in element 0,"
-  "and the coefficients starting in element 1 and going up from there."
-  "Here is the representation of 5x^3 + 10x^2 + 20x + 30"
-  ('#(x 30 20 10 5) @ 511)
-  "Here are some examples (without the interactive loop):"
-  ((canon '(3 + x + 4 - x)) => 7 @ 521)
-  ((canon '(x + y + y + x)) => ((2 * x) + (2 * y)))
-  ((canon '(3 * x + 4 * x)) => (7 * x))
-  ((canon '(3 * x + y + x + 4 * x)) => ((8 * x) + y))
-  ((canon '((x + 1) ^ 10)) =>
-   ((x ^ 10) + (10 * (x ^ 9)) + (45 * (x ^ 8)) + (120 * (x ^ 7))
-    + (210 * (x ^ 6)) + (252 * (x ^ 5)) + (210 * (x ^ 4))
-    + (120 * (x ^ 3)) + (45 * (x ^ 2)) + (10 * x) + 1))
-  ((canon '((x + 1) ^ 10 - (x - 1) ^ 10)) =>
-   ((20 * (x ^ 8)) + (240 * (x ^ 7)) + (504 * (x ^ 5))
-    + (240 * (x ^ 3)) + (20 * x)))
-  ((canon '(d (3 * x ^ 2 + 2 * x + 1) / d x)) @ 522 =>
-   ((6 * x) + 2))
-  ((canon '(d (z + 3 * x + 3 * z * x ^ 2 + z ^ 2 * x ^ 3) / d z)) =>
-   (((2 * z) * (x ^ 3)) + (3 * (x ^ 2)) + 1)))
-
-
-(defexamples 16 "Expert Systems"
-  "In this chapter we develop an expert system shell, and give it a few rules"
-  "about infectious disease, thus duplicating some of the Mycin system."
-  ((requires "mycin-r"))
-  "Because this is an interactive system, we can't show the interaction here."
-  "You can try it yourself by evaluating (mycin)"
-  )
-
-(defexamples 17 "Line Diagram Labelling by Constraint Satisfaction"
-  "In this chapter we look at the line-diagram labeling problem: Given a list"
-  "of lines and the vertexes at which they intersect, how can we determine"
-  "what the lines represent?"
-  ((requires "waltz"))
-  (:section "17.2 Combining Constraints and Searching")
-  "First let's test that we can find the possible labelings for a vertex class:"
-  ((possible-labelings 'Y) @ 574 =>
-   ((+ + +) (- - -) (L R -) (- L R) (R - L)))
-  "Notice how matrix-transpose works:"
-  ((matrix-transpose (possible-labelings 'Y)) =>
-   ((+ - L - R)
-    (+ - R L -)
-    (+ - - R L)))
-  ((defdiagram cube
-     (a Y b c d)
-     (b W g e a)
-     (c W e f a)
-     (d W f g a)
-     (e L c b)
-     (f L d c)
-     (g L b d)) @ 575)
-  (:section "17.3 Labelling Diagrams")
-  "We are now ready to try labelling diagrams.  First the cube:"
-  ((print-labelings (diagram 'cube)) @ 577)
-  "The cube should have given four solutions."
-  "We can get down to one solution by grounding line GD:"
-  ((print-labelings (ground (diagram 'cube) 'g 'd)) @ 580)
-  "For the more complex cube on a plate, we get similar results;"
-  "Four interpretations, which turn to one after grounding line KM:"
-  ((defdiagram cube-on-plate
-     (a Y b c d)
-     (b W g e a)
-     (c W e f a)
-     (d W f g a)
-     (e L c b)
-     (f Y d c i)
-     (g Y b d h)
-     (h W l g j)
-     (i W f m j)
-     (j Y h i k)
-     (k W m l j)
-     (l L h k)
-     (m L k i)) @ 581)
-  ((print-labelings (ground (diagram 'cube-on-plate) 'k 'm)) @ 582)
-  "It is interesting to try the algorithm on an 'impossible' diagram."
-  "It turns out the algorithm correctly finds no interpretation for this"
-  "well-known illusion:"
-  ((defdiagram poiuyt
-     (a L b g)
-     (b L j a)
-     (c L d l)
-     (d L h c)
-     (e L f i)
-     (f L k e)
-     (g L a l)
-     (h L l d)
-     (i L e k)
-     (j L k b)
-     (k W j i f)
-     (l W h g c)) @ 583)
-  ((print-labelings (diagram 'poiuyt)) @ 583)
-  "Now we try a more complex diagram:"
-  ((defdiagram tower
-     (a Y b c d)    (n L q o) 
-     (b W g e a)    (o W y j n)
-     (c W e f a)    (p L r i)
-     (d W f g a)    (q W n s w)
-     (e L c b)      (r W s p x)
-     (f Y d c i)    (s L r q)
-     (g Y b d h)    (t W w x z)
-     (h W l g j)    (u W x y z)
-     (i W f m p)    (v W y w z)
-     (j Y h o k)    (w Y t v q)
-     (k W m l j)    (x Y r u t)
-     (l L h k)      (y Y v u o)
-     (m L k i)      (z Y t u v)) @ 584)
-  ((print-labelings (ground (diagram 'tower) 'l 'k)) @ 584))
-  
-(defexamples 18 "Search and the Game of Othello"
-  "In this chapter we will develop a simplified Othello-playing program."
-  "It will not be a champion, but is much better than beginning players."
-  (:section "18.2 Representation Choices")
-  ((requires "othello"))
-  "First, we see that our choices for representing the board seem to work:"
-  ((print-board (initial-board)) @ 604)
-  "Now we can compare the weighted squares and count difference strategies"
-  "by playing two games, alternating who goes first.  The NIL as third argument"
-  "means don't print the board after each move."
-  ((othello (maximizer #'weighted-squares) 
-         (maximizer #'count-difference) nil) @ 610)
-  ((othello (maximizer #'count-difference)
-            (maximizer #'weighted-squares) nil))
-
-  (:section "18.4 Searching Ahead: Minimax")
-  "We can test the minimax strategy, and see that searching ahead 3 ply is"
-  "indeed better than looking at only 1 ply.  We can follow the whole game"
-  ((othello (minimax-searcher 3 #'count-difference)
-            (maximizer #'count-difference)) @ 614 => 53)
-
-  (:section "18.5 Smarter Searching: Alpha-Beta Search")
-  "The following should produce the same result, only faster:"
-  ((othello (alpha-beta-searcher 3 #'count-difference)
-	 (maximizer #'count-difference) nil) => 53)
-
-  (:section "18.8 Playing a Series of Games")
-  "A single game is not enough to establish that one strategy is better than"
-  "another.  The function RANDOM-OTHELLO-SERIES allows two strategies to"
-  "compete in a series of games."
-  ((requires "othello2"))
-  ((random-othello-series 
-    (alpha-beta-searcher 2 #'weighted-squares)
-    (alpha-beta-searcher 2 #'modified-weighted-squares)
-    5) @ 628)
-  "Here is a comparison of five strategies that search only 1 ply."
-  "To save time, we run 2 pairs of games each, not 5 pairs."
-  ((round-robin
-   (list (maximizer #'count-difference)
-         (maximizer #'mobility)
-         (maximizer #'weighted-squares)
-         (maximizer #'modified-weighted-squares)
-         #'random-strategy)
-   2 10
-   '(count-difference mobility weighted modified-weighted random)) @ 629)
-  "Now we compare alpha-beta searchers at 3 ply for 1 pair of games each."
-  "In the book it was 4 ply for 5 pairs each, but that takes too long."
-  ((round-robin
-   (list (alpha-beta-searcher 3 #'count-difference)
-         (alpha-beta-searcher 3 #'weighted-squares)
-         (alpha-beta-searcher 3 #'modified-weighted-squares)
-         #'random-strategy)
-   1 10 
-   '(count-difference weighted modified-weighted random)))
-  )
-
-(defexamples 19 "Introduction to Natural Language"
-  "This chapter is a brief introduction to natural language processing."
-  (:section "19.1 Parsing with a Phrase-Structure Grammar")
-  "We start with the grammar defined on page 39 for the GENERATE program."
-  "I include 'noun' and 'verb' as nouns in the grammar *grammar3*"
-  ((requires "syntax1"))
-  (*grammar3* @ 657)
-  ((use *grammar3*))
-  ((parser '(the table)) => ((NP (ART THE) (NOUN TABLE))))
-  ((parser '(the ball hit the table)) =>
-   ((SENTENCE (NP (ART THE) (NOUN BALL))
-	      (VP (VERB HIT)
-		  (NP (ART THE) (NOUN TABLE))))))
-  ((parser '(the noun took the verb)) =>
-   ((SENTENCE (NP (ART THE) (NOUN NOUN))
-	      (VP (VERB TOOK)
-		  (NP (ART THE) (NOUN VERB))))))
-  "The range of sentences we can parse is quite limited."
-  "The following grammar includes a wider variety."
-  (*grammar4* @ 661)
-  ((use *grammar4*))
-  ((parser '(The man hit the table with the ball)) =>
-   ((S (NP (D THE) (N MAN))
-       (VP (VP (V HIT) (NP (D THE) (N TABLE)))
-	   (PP (P WITH) (NP (D THE) (N BALL)))))
-    (S (NP (D THE) (N MAN))
-       (VP (V HIT)
-	   (NP (NP (D THE) (N TABLE))
-	       (PP (P WITH) (NP (D THE) (N BALL))))))))
-  "Here we see a phrase that is ambiguous between a sentence and a noun phrase:"
-  ((parser '(the orange saw)) @ 662 =>
-   ((S (NP (D THE) (N ORANGE)) (VP (V SAW)))
-    (NP (D THE) (A+ (A ORANGE)) (N SAW))))
-
-  (:section "19.4 The Unknown-Word Problem")
-  "As it stands, the parser cannot deal with unknown words."
-  "One way of treating unknown words is to allow them to be any of the"
-  "'open-class' categories--nouns, verbs, adjectives, and names."
-  ((parser '(John liked Mary)) @ 664 =>
-   ((S (NP (NAME JOHN))
-       (VP (V LIKED) (NP (NAME MARY))))))
-  ((parser '(Dana liked Dale)) @ 665 =>
-   ((S (NP (NAME DANA))
-       (VP (V LIKED) (NP (NAME DALE))))))
-  "We see the parser works as well with words it knows (John and Mary)"
-  "as with new words (Dana and Dale), which it can recognize as names"
-  "because of their position in the sentence."
-  ((parser '(the rab zaggled the woogly quax)) =>
-   ((S (NP (D THE) (N RAB))
-       (VP (V ZAGGLED) (NP (D THE) (A+ (A WOOGLY)) (N QUAX))))))
-  ((parser '(the slithy toves gymbled)) =>
-   ((S (NP (D THE) (N SLITHY)) (VP (V TOVES) (NP (NAME GYMBLED))))
-    (S (NP (D THE) (A+ (A SLITHY)) (N TOVES)) (VP (V GYMBLED)))
-    (NP (D THE) (A+ (A SLITHY) (A+ (A TOVES))) (N GYMBLED))))
-  ((parser '(the slithy toves gymbled on the wabe)) =>
-   ((S (NP (D THE) (N SLITHY))
-       (VP (VP (V TOVES) (NP (NAME GYMBLED)))
-	   (PP (P ON) (NP (D THE) (N WABE)))))
-    (S (NP (D THE) (N SLITHY))
-       (VP (V TOVES) (NP (NP (NAME GYMBLED))
-			 (PP (P ON) (NP (D THE) (N WABE))))))
-    (S (NP (D THE) (A+ (A SLITHY)) (N TOVES))
-       (VP (VP (V GYMBLED)) (PP (P ON) (NP (D THE) (N WABE)))))
-    (NP (NP (D THE) (A+ (A SLITHY) (A+ (A TOVES))) (N GYMBLED))
-	(PP (P ON) (NP (D THE) (N WABE))))))
-  (:section "19.5 Parsing into a Semantic Representation")
-  ((requires "syntax2"))
-  "Syntactic parse trees of a sentence may be interesting, but by themselves"
-  "they're not very useful.  We use sentences to communicate ideas, not to"
-  "display grammatical structures."
-  ""
-  "Imagine a compact disc player for which you can punch buttons like"
-  "'play 1 to 5 without 3'.  We will define such a language."
-  "The meaning of a sentence in the language is the list of tracks played."
-  (*grammar5* @ 667)
-  ((use *grammar5*))
-  ((meanings '(1 to 5 without 3)) @ 669 => ((1 2 4 5)))
-  ((meanings '(1 to 4 and 7 to 9)) => ((1 2 3 4 7 8 9)))
-  ((meanings '(1 to 6 without 3 and 4)) => ((1 2 4 5 6) (1 2 5 6)))
-  "The example '1 to 6 without 3 and 4' is ambiguous."
-  "The syntactic ambiguity leads to a semantic ambiguity."
-  "We can define a new grammar that eliminates some ambiguities:"
-  (*grammar6* @ 669)
-  ((use *grammar6*))
-  "With this new grammar, we can get single interpretations out of most inputs"
-  ((meanings '(1 to 6 without 3 and 4)) => ((1 2 5 6)))
-  ((meanings '(1 and 3 to 7 and 9 without 5 and 6)) => ((1 3 4 7 9)))
-  ((meanings '(1 and 3 to 7 and 9 without 5 and 2)) => ((1 3 4 6 7 9 2)))
-  ((meanings '(1 9 8 to 2 0 1)) => ((198 199 200 201)))
-  ((meanings '(1 2 3)) => (123 (123)))
-
-  (:section "19.6 Parsing with Preferences")
-  ((requires "syntax3"))
-  "We need some compromise between the permissive grammar, which generated"
-  "all possible parses, and the restrictive grammar, which eliminates too"
-  "many parses.  To get the 'best' interpretation we will need not only a"
-  "new grammar, we will also need to modify the program to compare the"
-  "relative worth of candidate interpretations."
-  (*grammar7* @ 673)
-  ((use *grammar7*))
-  "We will need a way to show off the prefernce rankings:"
-  ((all-parses '(1 to 6 without 3 and 4)) @ 675)
-  ((all-parses '(1 and 3 to 7 and 9 without 5 and 6)))
-  ((all-parses '(1 and 3 to 7 and 9 without 5 and 2)) @ 676)
-  "In each case, the preference rules are able to assign higher scores to"
-  "more reasonable interpretations.  What we really want is to pick the best."
-  "Here we see some examples:"
-  ((meaning '(1 to 5 without 3 and 4)) => (1 2 5))
-  ((meaning '(1 to 5 without 3 and 6)) => (1 2 4 5 6))
-  ((meaning '(1 to 5 without 3 and 6 shuffled)))
-  ((meaning '([ 1 to 5 without [ 3 and 6 ] ] reversed)) => (5 4 2 1))
-  ((meaning '(1 to 5 to 9)) => NIL)
-  )
-
-
-(defexamples 20 "Unification Grammars"
-  "Prolog was invented as a formalism to describe the grammar of French."
-  "It is still useful to view a grammar as a set of logic programming clauses."
-  "This chapter describes how that can be done."
-  ((requires "unifgram"))
-  (:section "20.3 A Simple Grammar in DCG Format")
-  "Here is the trivial grammar from page 688 in DCG format:"
-  ((clear-db))
-  ((rule (S (?pred ?subj)) -->
-	 (NP ?agr ?subj)
-	 (VP ?agr ?pred)) @ 692)
-  ((rule (NP ?agr (?det ?n)) -->
-	 (Det ?agr ?det)
-	 (N ?agr ?n)))
-  ((rule (NP 3sg (the male))          --> (:word he)) @ 693)
-  ((rule (NP ~3sg (some objects))     --> (:word they)))
-  ((rule (VP 3sg sleep)               --> (:word sleeps)))
-  ((rule (VP ~3sg sleep)              --> (:word sleep)))
-  ((rule (Det ?any the)               --> (:word the)))
-  ((rule (N 3sg (young male human))   --> (:word boy)))
-  ((rule (N 3sg (young female human)) --> (:word girl)))
-  "We can parse some of the sentences from page 689 (but in DCG format)."
-  "Parsing:"
-  ((?- (S ?sem (He sleeps) ())) :input ".")
-  "Generating:"
-  ((?- (S (sleep (the male)) ?words  ())) :input ".")
-  "Enumerating:"
-  ((?- (S ?sem ?words ())) :input ";;;;")
-  "If we want the interpretation of 'Terry kisses Jean' to be"
-  "(kiss Terry Jean) not ((lambda (x) (kiss x Jean)) Terry), then we need"
-  "a way to unify semantic components together.  Here's one way:"
-  ((clear-db))
-  ((rule (S ?pred) -->
-	 (NP ?agr ?subj)
-	 (VP ?agr ?subj ?pred)) @ 694)
-  ((rule (VP ?agr ?subj ?pred) -->
-	 (Verb/tr ?agr ?subj ?pred ?obj)
-	 (NP ?any-agr ?obj)))
-  ((rule (VP ?agr ?subj ?pred) -->
-	 (Verb/intr ?agr ?subj ?pred)))
-
-  ((rule (Verb/tr ~3sg ?x (kiss ?x ?y) ?y) --> (:word kiss)))
-  ((rule (Verb/tr 3sg ?x (kiss ?x ?y) ?y) --> (:word kisses)))
-  ((rule (Verb/tr ?any  ?x (kiss ?x ?y) ?y) --> (:word kissed)))
-
-  ((rule (Verb/intr ~3sg ?x (sleep ?x)) --> (:word sleep)))
-  ((rule (Verb/intr 3sg ?x (sleep ?x)) --> (:word sleeps)))
-  ((rule (Verb/intr ?any  ?x (sleep ?x)) --> (:word slept)))
-
-  "Here are the rules for noun phrases and nouns"
-  ((rule (NP ?agr ?sem) -->
-	 (Name ?agr ?sem)))
-  ((rule (NP ?agr (?det-sem ?noun-sem)) -->
-	 (Det ?agr ?det-sem)
-	 (Noun ?agr ?noun-sem)))
-
-  ((rule (Name 3sg Terry) --> (:word Terry)))
-  ((rule (Name 3sg Jean)  --> (:word Jean)))
-
-  ((rule (Noun 3sg (young male human))           --> (:word boy)) @ 695)
-  ((rule (Noun 3sg (young female human))         --> (:word girl)))
-  ((rule (Noun ~3sg (group (young male human)))   --> (:word boys)))
-  ((rule (Noun ~3sg (group (young female human))) --> (:word girls)))
-
-  ((rule (Det ?any the)  --> (:word the)))
-  ((rule (Det 3sg a) --> (:word a)))
-
-  "This grammar and lexicon generates more sentences, although it is still"
-  "rather limited.  Here are some examples:"
-
-  ((?- (S ?sem (The boys kiss a girl) ())) @ 695 :input ";.")
-  ((?- (S ?sem (The girls kissed the girls) ())) :input ";.")
-  ((?- (S ?sem (Terry kissed the girl) ())) :input ";.")
-  ((?- (S ?sem (The girls kisses the boys) ())) :input ";.")
-  ((?- (S ?sem (Terry kissed a girls) ())) :input ";.")
-  ((?- (S ?sem (Terry sleeps Jean) ())) :input ";.")
-
-  (:section "20.4 A DCG Grammar with Quantifiers")
-  ((clear-db))
-  ((rule (Det ?any ?x ?p ?q (the ?x (and ?p ?q)))    --> (:word the)) @ 697)
-  ((rule (Det 3sg  ?x ?p ?q (exists ?x (and ?p ?q))) --> (:word a)))
-  ((rule (Det 3sg  ?x ?p ?q (all    ?x (-> ?p ?q)))  --> (:word every)))
-
-  ((rule (Noun 3sg ?x (picture ?x)) --> (:word picture)) @ 698)
-  ((rule (Noun 3sg ?x (story ?x)) --> (:word story)))
-  ((rule (Noun 3sg ?x (and (young ?x) (male ?x) (human ?x))) -->
-	 (:word boy)))
-
-  ((rule (NP ?agr ?x ?pred ?pred) -->
-	 (Name ?agr ?name)))
-
-  ((rule (NP ?agr ?x ?pred ?np) -->
-	 (Det ?agr ?x ?noun&rel ?pred ?np)
-	 (Noun ?agr ?x ?noun)
-	 (rel-clause ?agr ?x ?noun ?noun&rel)))
-
-  ((rule (rel-clause ?agr ?x ?np ?np) --> ))
-  ((rule (rel-clause ?agr ?x ?np (and ?np ?rel)) -->
-	 (:word that)
-	 (VP ?agr ?x ?rel)))
-
-  ((rule (Verb/tr ~3sg ?x ?y (paint ?x ?y)) --> (:word paint)) @ 699)
-  ((rule (Verb/tr 3sg  ?x ?y (paint ?x ?y)) --> (:word paints)))
-  ((rule (Verb/tr ?any ?x ?y (paint ?x ?y)) --> (:word painted)))
-
-  ((rule (Verb/intr ~3sg ?x (sleep ?x)) --> (:word sleep)))
-  ((rule (Verb/intr 3sg  ?x (sleep ?x)) --> (:word sleeps)))
-  ((rule (Verb/intr ?any ?x (sleep ?x)) --> (:word slept)))
-
-  ((rule (Verb/intr 3sg  ?x (sells ?x)) --> (:word sells)))
-  ((rule (Verb/intr 3sg  ?x (stinks ?x)) --> (:word stinks)))
-
-  ((rule (VP ?agr ?x ?vp) -->
-	 (Verb/tr ?agr ?x ?obj ?verb)
-	 (NP ?any-agr ?obj ?verb ?vp)))
-
-  ((rule (VP ?agr ?x ?vp) -->
-	 (Verb/intr ?agr ?x ?vp)))
-
-  ((rule (S ?np) -->
-	 (NP ?agr ?x ?vp ?np)
-	 (VP ?agr ?x ?vp)))
-
-  "Now we define a function to show the output from a query."
-  "In the book, you just saw the output of such a function."
-  ((defun do-s (words)
-     (top-level-prove `((S ?sem ,words ())))))
-
-  ((do-s '(Every picture paints a story)) :input "." @ 699)
-  ((do-s '(Every boy that paints a picture sleeps)) :input ".")
-  ((do-s '(Every boy that sleeps paints a picture)) :input ".")
-  ((do-s '(Every boy that paints a picture that sells paints a picture 
-		 that stinks)) :input "." @ 700)
-
-  (:section "20.5 Preserving Quantifier Scope Ambiguity")
-  ((clear-db))
-  ((rule (S (and ?np ?vp)) -->
-	 (NP ?agr ?x ?np)
-	 (VP ?agr ?x ?vp)) @ 701)
-
-  ((rule (VP ?agr ?x (and ?verb ?obj)) -->
-	 (Verb/tr ?agr ?x ?o ?verb)
-	 (NP ?any-agr ?o ?obj)))
-
-  ((rule (VP ?agr ?x ?verb) -->
-	 (Verb/intr ?agr ?x ?verb)))
-
-  ((rule (NP ?agr ?name t) -->
-	 (Name ?agr ?name)))
-
-  ((rule (NP ?agr ?x ?det) -->
-	 (Det ?agr ?x (and ?noun ?rel) ?det)
-	 (Noun ?agr ?x ?noun)
-	 (rel-clause ?agr ?x ?rel)))
-
-  ((rule (rel-clause ?agr ?x t) --> ))
-  ((rule (rel-clause ?agr ?x ?rel) -->
-	 (:word that)
-	 (VP ?agr ?x ?rel)))
-
-  ((rule (Name 3sg Terry)                     --> (:word Terry)))
-  ((rule (Name 3sg Jean)                      --> (:word Jean)))
-  ((rule (Det 3sg  ?x ?restr (all ?x ?restr)) --> (:word every)))
-  ((rule (Noun 3sg ?x (man ?x))               --> (:word man)))
-  ((rule (Verb/tr 3sg ?x ?y (love ?x ?y))     --> (:word loves)))
-  ((rule (Verb/intr 3sg ?x (lives ?x))        --> (:word lives)))
-  ((rule (Det 3sg  ?x ?res (exists ?x ?res))  --> (:word a)))
-  ((rule (Noun 3sg ?x (woman ?x))             --> (:word woman)))
-
-  "Here is an example of the new representation:"
-  ((do-s '(every man loves a woman)) :input "." @ 701)
-  )
-
-(defexamples 21 "A Grammar of English"
-  ((if (boundp 'clear-db) (clear-db)) @ 715)
-  ((requires "grammar" "lexicon"))
-  ((prolog-compile-symbols))
-  (:section "21.10 Word Categories")
-  ((?- (word sees verb ?infl ?senses)) :input ".")
-  ((try S John promised Kim to persuade Lee to sleep) :input ";;;.")
-  (:section "21.14 Examples")
-  ((try S When did John promise Kim to persuade Lee to sleep) 
-   @ 746 :input ";;;.")
-  ((try S Kim would not have been looking for Lee) @ 747 :input ";;;.")
-  ((try s It should not surprise you that Kim does not like Lee) :input ";;;.")
-  )
-
-(defexamples 22 "Scheme: An Uncommon Lisp"
-  "This chapter presents the Scheme dialect of Lisp and an interpreter for it."
-  "Understanding the interpreter can give you a better appreciation of Lisp."
-  (:section "22.1 A Scheme Interpreter")
-  ((requires "interp1"))
-  "We're ready to try out the interpreter.  Note we provide an argument"
-  "to avoid going into a read-eval-print loop with SCHEME.  This is a new"
-  "functionality, no in the book, added to make these examples easier."
-  ((scheme '(+ 2 2)) @ 760 => 4 )
-  ((scheme '((if (= 1 2) * +) 3 4)) => 7) 
-  ((scheme '((if (= 1 1) * +) 3 4)) => 12 @ 761) 
-  ((scheme '(set! fact (lambda (n) (if (= n 0) 1
-				     (* n (fact (- n 1))))))))
-  ((scheme '(fact 5)) => 120) 
-  ((scheme '(set! table (lambda (f start end)
-			  (if (<= start end)
-			      (begin
-			       (write (list start (f start)))
-			       (newline)
-			       (table f (+ start 1) end)))))))
-
-  ((scheme '(table fact 1 10)) => NIL )
-  ((scheme '(table (lambda (x) (* x x x)) 5 10)) => NIL)
-
-  (:section "22.2 Syntactic Extension with Macros")
-  "Scheme has a number of special forms that were not listed above."
-  "These can be implemented by macros (although macros are not officially"
-  "part of Scheme).  We can test out the macro facility:"
-  ((scheme-macro-expand '(and p q)) => (IF P (AND Q)) @ 765)
-  ((scheme-macro-expand '(and q)) => Q)
-  ((scheme-macro-expand '(let ((x 1) (y 2)) (+ x y))) =>
-   ((LAMBDA (X Y) (+ X Y)) 1 2))
-  ((scheme-macro-expand
-    '(letrec 
-      ((even? (lambda (x) (or (= x 0) (odd? (- x 1)))))
-       (odd?  (lambda (x) (even? (- x 1)))))
-      (even? z))))
-  "Now let's look at uses of the macros DEFINE and LET*"
-  ((scheme '(define (reverse l)
-	      (if (null? l) nil
-		(append (reverse (cdr l)) (list (car l)))))) => REVERSE)
-  ((scheme '(reverse '(a b c d))) => (D C B A))
-  ((scheme '(let* ((x 5) (y (+ x x)))
-	      (if (or (= x 0) (and (< 0 y) (< y 20)))
-		  (list x y)
-		(+ y x)))) => (5 10))
-
-
-  (:section "22.4 Throw, Catch, and Call/cc")
-  ((requires "interp3"))
-  "Non-local flow of control is provided in Scheme with a very general and"
-  "powerful procedure, CALL-WITH-CURRENT-CONTINUATION, which is often"
-  "abbreviated CALL/CC.  Here are some examples:"
-  ((scheme '(+ 1 (call/cc (lambda (cc) (+ 20 300))))) @ 770 => 321)
-  "The above example ignores CC and computes (+ 1 (+ 20 300))"
-  "The next example does make use of CC:"
-  ((scheme '(+ 1 (call/cc (lambda (cc) (+ 20 (cc 300)))))) => 301)
-  "The above passes 300 to CC, thus bypassing the addition of 20."
-  "It effectively throws 300 out to the catch point established by call/cc."
-  )
-
-(defexamples 23 "Compiling Lisp"
-  "Compilers are simple to write and useful to know about."
-  "In this chapter we develop a simple compiler for Scheme."
-  ""
-  ((requires "compile1"))
-  "Now we are ready to show the simple compiler at work:"
-  ((comp-show '(if (= x y) (f (g x)) (h x y (h 1 2)))) @ 791)
-  "Here are some places where a compiler could do better than an interpreter"
-  "(although our compiler currently does not):"
-  ((comp-show '(begin "doc" (write x) y)) @ 792)
-  "We should not have to push 'doc' on the stack just to pop it off."
-  "Here's another example:"
-  ((comp-show '(begin (+ (* a x) (f x)) x)))
-  "Here's an example using local variables:"
-  ((comp-show '((lambda (x) ((lambda (y z) (f x y z)) 3 x)) 4)) @ 794)
-  (:section "23.1 A Properly Tail-Recursive Compiler")
-  "Notice the two new instructions, CALLJ and SAVE"
-  ((requires "compile2"))
-  "First we see how nested function calls work:"
-  ((comp-show '(f (g x))) @ 796)
-  "In the next example we see that unneeded constants and variables in BEGIN"
-  "expressions are ignored:"
-  ((comp-show '(begin "doc" x (f x) y)) @ 797)
-  ((comp-show '(begin (+ (* a x) (f x)) x)))
-  "Here are some examples of IF expressions:"
-  ((comp-show '(if p (+ x y) (* x y))) @ 801)
-  "If we put the same code inside a BEGIN we get something quite different:"
-  ((comp-show '(begin (if p (+ x y) (* x y)) z)) @ 802)
-  "Here are some more examples of the compiler at work:"
-  ((comp-show '(if (null? (car l)) (f (+ (* a x) b))
-                  (g (/ x 2)))) @ 806)
-  ((comp-show '(define (last1 l)
-                (if (null? (cdr l)) (car l)
-                    (last1 (cdr l))))) @ 807)
-  ((comp-show '(define (length l)
-                (if (null? l) 0 (+ 1 (length (cdr l)))))) @ 808)
-  "Of course, it is possible to write LENGTH in tail-recursive fashion:"
-  ((comp-show '(define (length l)
-                (letrec ((len (lambda (l n)
-                                (if (null? l) n
-                                    (len (rest l) (+ n 1))))))
-                  (len l 0)))))
-  (:section "23.4 A Peephole Optimizer")
-  "In this section we investigate a simple technique that will generate"
-  "slightly better code in cases where the compiler is less than perfect."
-  ((requires "compile3"  "compopt"))
-  ((comp-show '(begin (if (if t 1 (f x)) (set! x 2)) x)) @ 818)
-  )
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/gps1.dat norvig-paip-pjb/gps1.dat
--- norvig/gps1.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/gps1.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,46 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+> (gps '(son-at-home car-needs-battery have-money have-phone-book)
+       '(son-at-school)
+       *school-ops*)
+(EXECUTING LOOK-UP-NUMBER) 
+(EXECUTING TELEPHONE-SHOP) 
+(EXECUTING TELL-SHOP-PROBLEM) 
+(EXECUTING GIVE-SHOP-MONEY) 
+(EXECUTING SHOP-INSTALLS-BATTERY) 
+(EXECUTING DRIVE-SON-TO-SCHOOL) 
+SOLVED
+
+> (gps '(son-at-home car-needs-battery have-money)
+       '(son-at-school)
+       *school-ops*)
+NIL 
+
+> (gps '(son-at-home car-works)
+       '(son-at-school)
+       *school-ops*)
+(EXECUTING DRIVE-SON-TO-SCHOOL) 
+SOLVED
+
+;;; ==============================
+
+> (gps '(son-at-home have-money car-works)
+       '(have-money son-at-school)
+       *school-ops*)
+(EXECUTING DRIVE-SON-TO-SCHOOL) 
+SOLVED
+
+;;; ==============================
+
+> (gps '(son-at-home car-needs-battery have-money have-phone-book)
+       '(have-money son-at-school)
+       *school-ops*)
+(EXECUTING LOOK-UP-NUMBER) 
+(EXECUTING TELEPHONE-SHOP) 
+(EXECUTING TELL-SHOP-PROBLEM) 
+(EXECUTING GIVE-SHOP-MONEY) 
+(EXECUTING SHOP-INSTALLS-BATTERY) 
+(EXECUTING DRIVE-SON-TO-SCHOOL) 
+SOLVED
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/gps1.lisp norvig-paip-pjb/gps1.lisp
--- norvig/gps1.lisp	1997-02-05 07:39:50.000000000 +0100
+++ norvig-paip-pjb/gps1.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -58,3 +58,4 @@
          :preconds '(have-money)
          :add-list '(shop-has-money)
          :del-list '(have-money))))
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/gps.dat norvig-paip-pjb/gps.dat
--- norvig/gps.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/gps.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,263 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+;;; ==============================
+
+(push (make-op :action 'ask-phone-number
+               :preconds '(in-communication-with-shop)
+               :add-list '(know-phone-number))
+      *school-ops*)
+
+> (use *school-ops*) -> 7
+
+> (gps '(son-at-home car-needs-battery have-money have-phone-book)
+       '(son-at-school))
+((START)
+ (EXECUTING LOOK-UP-NUMBER) 
+ (EXECUTING TELEPHONE-SHOP)
+ (EXECUTING TELL-SHOP-PROBLEM)
+ (EXECUTING GIVE-SHOP-MONEY)
+ (EXECUTING SHOP-INSTALLS-BATTERY)
+ (EXECUTING DRIVE-SON-TO-SCHOOL))
+
+> (debug :gps) -> (:GPS)
+
+> (gps '(son-at-home car-needs-battery have-money have-phone-book)
+       '(son-at-school))
+Goal: SON-AT-SCHOOL
+Consider: DRIVE-SON-TO-SCHOOL
+  Goal: SON-AT-HOME
+  Goal: CAR-WORKS
+  Consider: SHOP-INSTALLS-BATTERY
+    Goal: CAR-NEEDS-BATTERY
+    Goal: SHOP-KNOWS-PROBLEM
+    Consider: TELL-SHOP-PROBLEM
+      Goal: IN-COMMUNICATION-WITH-SHOP
+      Consider: TELEPHONE-SHOP
+        Goal: KNOW-PHONE-NUMBER
+        Consider: ASK-PHONE-NUMBER
+          Goal: IN-COMMUNICATION-WITH-SHOP
+        Consider: LOOK-UP-NUMBER
+          Goal: HAVE-PHONE-BOOK
+        Action: LOOK-UP-NUMBER
+      Action: TELEPHONE-SHOP
+    Action: TELL-SHOP-PROBLEM
+    Goal: SHOP-HAS-MONEY
+    Consider: GIVE-SHOP-MONEY
+      Goal: HAVE-MONEY
+    Action: GIVE-SHOP-MONEY
+  Action: SHOP-INSTALLS-BATTERY
+Action: DRIVE-SON-TO-SCHOOL
+((START)
+ (EXECUTING LOOK-UP-NUMBER)
+ (EXECUTING TELEPHONE-SHOP)
+ (EXECUTING TELL-SHOP-PROBLEM)
+ (EXECUTING GIVE-SHOP-MONEY)
+ (EXECUTING SHOP-INSTALLS-BATTERY)
+ (EXECUTING DRIVE-SON-TO-SCHOOL))
+
+> (undebug) -> NIL
+
+> (gps '(son-at-home car-works)
+       '(son-at-school))
+((START)
+ (EXECUTING DRIVE-SON-TO-SCHOOL))
+
+;;; ==============================
+
+> (gps '(son-at-home car-needs-battery have-money have-phone-book)
+       '(have-money son-at-school))
+NIL
+
+> (gps '(son-at-home car-needs-battery have-money have-phone-book)
+       '(son-at-school have-money))
+NIL
+
+> (gps '(son-at-home car-needs-battery have-money)
+       '(son-at-school))
+NIL
+
+;;; ==============================
+
+> (gps '(son-at-home) '(son-at-home)) -> ((START))
+
+;;; ==============================
+
+> (use *banana-ops*) -> 6
+
+> (GPS '(at-door on-floor has-ball hungry chair-at-door)
+       '(not-hungry))
+((START)
+ (EXECUTING PUSH-CHAIR-FROM-DOOR-TO-MIDDLE-ROOM)
+ (EXECUTING CLIMB-ON-CHAIR)
+ (EXECUTING DROP-BALL)
+ (EXECUTING GRASP-BANANAS)
+ (EXECUTING EAT-BANANAS))
+
+;;; ==============================
+
+> (use *maze-ops*) -> 48
+
+> (gps '((at 1)) '((at 25)))
+((START)
+ (EXECUTING (MOVE FROM 1 TO 2))
+ (EXECUTING (MOVE FROM 2 TO 3))
+ (EXECUTING (MOVE FROM 3 TO 4))
+ (EXECUTING (MOVE FROM 4 TO 9))
+ (EXECUTING (MOVE FROM 9 TO 8))
+ (EXECUTING (MOVE FROM 8 TO 7))
+ (EXECUTING (MOVE FROM 7 TO 12))
+ (EXECUTING (MOVE FROM 12 TO 11))
+ (EXECUTING (MOVE FROM 11 TO 16))
+ (EXECUTING (MOVE FROM 16 TO 17))
+ (EXECUTING (MOVE FROM 17 TO 22))
+ (EXECUTING (MOVE FROM 22 TO 23))
+ (EXECUTING (MOVE FROM 23 TO 24))
+ (EXECUTING (MOVE FROM 24 TO 19))
+ (EXECUTING (MOVE FROM 19 TO 20))
+ (EXECUTING (MOVE FROM 20 TO 25))
+ (AT 25))
+
+;;; ==============================
+
+> (use *maze-ops*) -> 48
+
+> (find-path 1 25) -> 
+(1 2 3 4 9 8 7 12 11 16 17 22 23 24 19 20 25)
+
+> (find-path 1 1) -> (1)
+
+> (equal (find-path 1 25) (reverse (find-path 25 1))) -> T
+
+;;; ==============================
+
+> (use (make-block-ops '(a b))) -> 4
+
+> (gps '((a on table) (b on table) (space on a) (space on b)
+         (space on table))
+       '((a on b) (b on table)))
+((START)
+ (EXECUTING (MOVE A FROM TABLE TO B)))
+
+;;; ==============================
+
+> (debug :gps) -> (:GPS)
+
+> (gps '((a on b) (b on table) (space on a) (space on table))
+       '((b on a)))
+Goal: (B ON A)
+Consider: (MOVE B FROM TABLE TO A)
+  Goal: (SPACE ON B)
+  Consider: (MOVE A FROM B TO TABLE)
+    Goal: (SPACE ON A)
+    Goal: (SPACE ON TABLE)
+    Goal: (A ON B)
+  Action: (MOVE A FROM B TO TABLE)
+  Goal: (SPACE ON A)
+  Goal: (B ON TABLE)
+Action: (MOVE B FROM TABLE TO A)
+((START)
+ (EXECUTING (MOVE A FROM B TO TABLE))
+ (EXECUTING (MOVE B FROM TABLE TO A)))
+
+> (undebug) -> NIL
+
+;;; ==============================
+
+> (use (make-block-ops '(a b c))) -> 18
+
+> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))
+       '((b on a) (c on b)))
+((START)
+ (EXECUTING (MOVE A FROM B TO TABLE))
+ (EXECUTING (MOVE B FROM C TO A))
+ (EXECUTING (MOVE C FROM TABLE TO B)))
+
+> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))
+       '((c on b) (b on a)))
+NIL
+
+;;; ==============================
+
+> (gps '((c on a) (a on table) (b on table)
+         (space on c) (space on b) (space on table))
+       '((c on table)))
+((START)
+ (EXECUTING (MOVE C FROM A TO B))
+ (EXECUTING (MOVE C FROM B TO TABLE)))
+
+;;; ==============================
+
+> (gps '((c on a) (a on table) (b on table)
+         (space on c) (space on b) (space on table))
+       '((c on table) (a on b)))
+((START)
+ (EXECUTING (MOVE C FROM A TO B))
+ (EXECUTING (MOVE C FROM B TO TABLE))
+ (EXECUTING (MOVE A FROM TABLE TO C))
+ (EXECUTING (MOVE A FROM C TO B)))
+
+;;; ==============================
+
+> (gps '((c on a) (a on table) (b on table)
+         (space on c) (space on b) (space on table))
+       '((c on table) (a on b)))
+((START)
+ (EXECUTING (MOVE C FROM A TO TABLE))
+ (EXECUTING (MOVE A FROM TABLE TO B)))
+
+;;; ==============================
+
+> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))
+       '((b on a) (c on b)))
+((START)
+ (EXECUTING (MOVE A FROM B TO TABLE))
+ (EXECUTING (MOVE B FROM C TO A))
+ (EXECUTING (MOVE C FROM TABLE TO B)))
+
+> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))
+       '((c on b) (b on a)))
+((START)
+ (EXECUTING (MOVE A FROM B TO TABLE))
+ (EXECUTING (MOVE B FROM C TO A))
+ (EXECUTING (MOVE C FROM TABLE TO B)))
+
+;;; ==============================
+
+> (setf start '((c on a) (a on table) (b on table) (space on c)
+                (space on b) (space on table)))
+((C ON A) (A ON TABLE) (B ON TABLE) (SPACE ON C) 
+ (SPACE ON B) (SPACE ON TABLE))
+
+> (gps start '((a on b) (b on c))) -> NIL
+
+> (gps start '((b on c) (a on b))) -> NIL
+
+;;; ==============================
+
+(use (push (op 'taxi-son-to-school
+               :preconds '(son-at-home have-money)
+               :add-list '(son-at-school)
+               :del-list '(son-at-home have-money))
+           *school-ops*))
+
+(debug :gps)
+
+;;; ==============================
+
+> (gps '(son-at-home have-money car-works)
+       '(son-at-school have-money))
+Goal: SON-AT-SCHOOL
+Consider: TAXI-SON-TO-SCHOOL
+  Goal: SON-AT-HOME
+  Goal: HAVE-MONEY
+Action: TAXI-SON-TO-SCHOOL
+Goal: HAVE-MONEY
+Goal: HAVE-MONEY
+Goal: SON-AT-SCHOOL
+Consider: TAXI-SON-TO-SCHOOL
+  Goal: SON-AT-HOME
+  Goal: HAVE-MONEY
+Action: TAXI-SON-TO-SCHOOL
+NIL
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/gps.lisp norvig-paip-pjb/gps.lisp
--- norvig/gps.lisp	1997-02-05 07:39:50.000000000 +0100
+++ norvig-paip-pjb/gps.lisp	2008-03-18 02:23:26.000000000 +0100
@@ -233,7 +233,7 @@
 (defun appropriate-ops (goal state)
   "Return a list of appropriate operators, 
   sorted by the number of unfulfilled preconditions."
-  (sort (copy-list (find-all goal *ops* :test #'appropriate-p)) #'<
+  (sort (find-all goal *ops* :test #'appropriate-p) #'<
         :key #'(lambda (op) 
                  (count-if #'(lambda (precond)
                                (not (member-equal precond state)))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/gps-srch.dat norvig-paip-pjb/gps-srch.dat
--- norvig/gps-srch.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/gps-srch.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,22 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(setf start '((c on a) (a on table) (b on table) (space on c)
+              (space on b) (space on table)))
+
+(use (make-block-ops '(a b c)))
+;;;; -> 18
+
+(search-gps start '((a on b) (b on c)))
+;;;; -> ((START)
+;;;;     (EXECUTING (MOVE C FROM A TO TABLE))
+;;;;     (EXECUTING (MOVE B FROM TABLE TO C))
+;;;;     (EXECUTING (MOVE A FROM TABLE TO B)))
+
+(search-gps start '((b on c) (a on b)))
+;;;; -> ((START)
+;;;;     (EXECUTING (MOVE C FROM A TO TABLE))
+;;;;     (EXECUTING (MOVE B FROM TABLE TO C))
+;;;;     (EXECUTING (MOVE A FROM TABLE TO B)))
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/grammar.dat norvig-paip-pjb/grammar.dat
--- norvig/grammar.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/grammar.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,111 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+> (?- (word sees verb ?infl ?senses))
+?INFL = (FINITE (- - + -) PRESENT)
+?SENSES = ((UNDERSTAND ((AGT 1 (NP ?3)))
+                       ((EXP 1 (NP ?4))
+                        (CON 2 (CLAUSE (THAT) (FINITE ?5 ?6)))))
+           (LOOK ((AGT 1 (NP ?7)) (OBJ 2 (NP ?8))))
+           (DATING ((AGT 1 (NP ?9)) (OBJ 2 (NP ?10)))))
+
+;;; ==============================
+
+> (try S John promised Kim to persuade Lee to sleep)
+?SEM = (AND (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)
+            (PAST ?P) (PROMISE ?P)
+            (GOAL ?P ?K) (THE ?K (NAME KIM ?K))
+            (CON ?P ?PER) (PERSUADE ?PER) (GOAL ?PER ?L)
+            (THE ?L (NAME LEE ?L)) (CON ?PER ?S) (SLEEP ?S));
+
+> (try S Who did John promise Kim to persuade to sleep)
+?SEM = (AND (WH ?W (PERSON ?W)) (PAST ?P)
+            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)
+            (PROMISE ?P) (GOAL ?P ?K)
+            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)
+            (PERSUADE ?PER) (GOAL ?PER ?W)
+            (CON ?PER ?S) (SLEEP ?S));
+
+;;; ==============================
+
+> (try S When did John promise Kim to persuade Lee to sleep)
+?SEM = (AND (WH ?W (TIME ?S ?W)) (PAST ?P)
+            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)
+            (PROMISE ?P) (GOAL ?P ?K)
+            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)
+            (PERSUADE ?PER) (GOAL ?PER ?L)
+            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)
+            (SLEEP ?S));
+
+?SEM = (AND (WH ?W (TIME ?PER ?W)) (PAST ?P)
+            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)
+            (PROMISE ?P) (GOAL ?P ?K)
+            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)
+            (PERSUADE ?PER) (GOAL ?PER ?L)
+            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)
+            (SLEEP ?S));
+
+?SEM = (AND (WH ?W (TIME ?P ?W)) (PAST ?P)
+            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)
+            (PROMISE ?P) (GOAL ?P ?K)
+            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)
+            (PERSUADE ?PER) (GOAL ?PER ?L)
+            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)
+            (SLEEP ?S)).
+
+;;; ==============================
+
+> (try S Kim would not have been looking for Lee)
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?S ?K)
+            (EXPECTED ?S) (NOT ?S) (PAST-PARTICIPLE ?S)
+            (PROGRESSIVE ?S) (SEARCH ?S) (PAT ?S ?L)
+            (PAT ?S ?L) (THE ?L (NAME LEE ?L)));
+
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?2 ?K)
+            (EXPECTED ?2) (NOT ?2) (PAST-PARTICIPLE ?LOOK)
+            (PROGRESSIVE ?LOOK) (LOOK ?LOOK) (FOR ?LOOK ?L)
+            (THE ?L (NAME LEE ?L)));
+
+;;; ==============================
+
+> (try s It should not surprise you that Kim does not like Lee)
+?SEM = (AND (MANDATORY ?2) (NOT ?2) (SURPRISE ?2) (EXP ?2 ?YOU)
+            (PRO ?YOU (LISTENER ?YOU)) (CON ?2 ?LIKE)
+            (THE ?K (NAME KIM ?K)) (AGT ?LIKE ?K)
+            (PRESENT ?LIKE) (NOT ?LIKE) (LIKE-1 ?LIKE)
+            (OBJ ?LIKE ?L) (THE ?L (NAME LEE ?L)));
+
+> (try s Kim did not want Lee to know that the man knew her)
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?W ?K) (PAST ?W)
+            (NOT ?W) (DESIRE ?W) (GOAL ?W ?L)
+            (THE ?L (NAME LEE ?L)) (CON ?W ?KN)
+            (KNOW-THAT ?KN) (CON ?KN ?KN2)
+            (THE ?M (MAN ?M)) (AGT ?KN2 ?M) (PAST ?KN2)
+            (KNOW-OF ?KN2) (OBJ ?KN2 ?HER)
+            (PRO ?HER (FEMALE ?HER))).
+
+;;; ==============================
+
+> (try s That kim looked her up quickly surprised me)
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU1 ?K) (PAST ?LU1)
+            (LOOK-UP ?LU1) (PAT ?LU1 ?H) (PRO ?H (FEMALE ?H))
+            (QUICKLY ?LU1) (CON ?S ?LU1) (PAST ?S) (SURPRISE ?S)
+            (EXP ?S ?ME1) (PRO ?ME1 (SPEAKER ?ME1)));
+
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU2 ?K) (PAST ?LU2)
+            (LOOK-UP ?LU2) (PAT ?LU2 ?H) (PRO ?H (FEMALE ?H))
+            (CON ?S ?LU2) (QUICKLY ?S) (PAST ?S) (SURPRISE ?S)
+            (EXP ?S ?ME2) (PRO ?ME2 (SPEAKER ?ME2)));
+
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU3 ?K) (PAST ?LU3)
+            (LOOK-UP ?LU3) (PAT ?LU3 ?H) (PRO ?H (FEMALE ?H))
+            (QUICKLY ?LU3) (CON ?S ?LU3) (PAST ?S) (SURPRISE ?S)
+            (EXP ?S ?ME3) (PRO ?ME3 (SPEAKER ?ME3)));
+
+?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU4 ?K) (PAST ?LU4)
+            (LOOK-UP ?LU4) (PAT ?LU4 ?H) (PRO ?H (FEMALE ?H))
+            (CON ?S ?LU4) (QUICKLY ?S) (PAST ?S) (SURPRISE ?S)
+            (EXP ?S ?ME4) (PRO ?ME4 (SPEAKER ?ME4)));
+
+;;; ==============================
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/interp1.dat norvig-paip-pjb/interp1.dat
--- norvig/interp1.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/interp1.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,88 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+> (scheme)
+==> (+ 2 2)
+4 
+
+==> ((if (= 1 2) * +) 3 4)
+7 
+
+==> ((if (= 1 1) * +) 3 4)
+12 
+
+==> (set! fact (lambda (n)
+                 (if (= n 0) 1
+                     (* n (fact (- n 1))))))
+#<DTP-LEXICAL-CLOSURE 36722615> 
+
+==> (fact 5)
+120 
+
+==> (set! table (lambda (f start end)
+                  (if (<= start end)
+                      (begin
+                        (write (list start (f start)))
+                        (newline)
+                        (table f (+ start 1) end)))))
+#<DTP-LEXICAL-CLOSURE 41072172> 
+
+==> (table fact 1 10)
+(1 1) 
+(2 2) 
+(3 6) 
+(4 24) 
+(5 120) 
+(6 720) 
+(7 5040) 
+(8 40320) 
+(9 362880) 
+(10 3628800) 
+NIL 
+
+==> (table (lambda (x) (* x x x)) 5 10)
+(5 125) 
+(6 216) 
+(7 343) 
+(8 512) 
+(9 729) 
+(10 1000) 
+NIL 
+
+==> [ABORT]
+
+;;;; Test data for macros:
+
+> (scheme-macro-expand '(and p q)) -> (IF P (AND Q))
+
+> (scheme-macro-expand '(and q)) -> Q
+
+> (scheme-macro-expand '(let ((x 1) (y 2)) (+ x y))) ->
+((LAMBDA (X Y) (+ X Y)) 1 2)
+
+> (scheme-macro-expand
+    '(letrec 
+       ((even? (lambda (x) (or (= x 0) (odd? (- x 1)))))
+        (odd?  (lambda (x) (even? (- x 1)))))
+       (even? z))) ->
+(LET ((EVEN? NIL)
+      (ODD? NIL))
+  (SET! EVEN? (LAMBDA (X) (OR (= X 0) (ODD? (- X 1)))))
+  (SET! ODD? (LAMBDA (X) (EVEN? (- X 1))))
+  (EVEN? Z))
+
+> (scheme)
+==> (define (reverse l)
+      (if (null? l) nil
+          (append (reverse (cdr l)) (list (car l)))))
+REVERSE
+
+==> (reverse '(a b c d))
+(D C B A) 
+
+==> (let* ((x 5) (y (+ x x)))
+      (if (or (= x 0) (and (< 0 y) (< y 20)))
+          (list x y)
+          (+ y x)))
+(5 10)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/interp1.lisp norvig-paip-pjb/interp1.lisp
--- norvig/interp1.lisp	1997-02-05 07:39:51.000000000 +0100
+++ norvig-paip-pjb/interp1.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -73,15 +73,11 @@
       (set-global-var! (first f) (symbol-function (second f)))
       (set-global-var! f (symbol-function f))))
 
-(defun scheme (&optional x)
+(defun scheme ()
   "A Scheme read-eval-print loop (using interp)"
-  ;; Modified by norvig Jun 11 96 to handle optional argument
-  ;; instead of always going into a loop.
   (init-scheme-interp)
-  (if x
-      (interp x nil)
-    (loop (format t "~&==> ")
-      (print (interp (read) nil)))))
+  (loop (format t "~&==> ")
+        (print (interp (read) nil))))
 
 ;;;; The following version handles macros:
 
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/interp3.dat norvig-paip-pjb/interp3.dat
--- norvig/interp3.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/interp3.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,109 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+> (scheme)
+=> (+ 1 (call/cc (lambda (cc) (+ 20 300))))
+321
+
+;;; ==============================
+
+((lambda (val) (+ 1 val)) 
+ (+ 20 300))
+
+;;; ==============================
+
+=> (+ 1 (call/cc (lambda (cc) (+ 20 (cc 300)))))
+301
+
+;;; ==============================
+
+((lambda (val) (+ 1 val))
+ 300)
+
+;;; ==============================
+
+(define (print-table l)
+  (call/cc
+    (lambda (escape)
+      (set! not-a-number escape)
+      (map print-sqrt-abs l))))
+
+(define (print-sqrt-abs x)
+  (write (sqrt (abs (must-be-number x)))))
+
+(define (must-be-number x)
+  (if (numberp x) x
+      (not-a-number "huh?")))
+
+(define (map fn l)
+  (if (null? l)
+      '()
+      (cons (fn (first l))
+            (map fn (rest l)))))
+
+;;; ==============================
+
+=> (+ 1 (call/cc (lambda (cc)
+                   (set! old-cc cc)
+                   (+ 20 (cc 300)))))
+301
+
+=> (old-cc 500)
+501
+
+;;; ==============================
+
+> (+ 1 (catch 'tag (+ 20 (throw 'tag 300))))
+301
+
+> (throw 'tag 500)
+Error: there was no pending CATCH for the tag TAG
+
+;;; ==============================
+
+(define (integer) (amb 1 (+ 1 (integer))))
+
+;;; ==============================
+
+(define (prime)
+  (let ((n (integer)))
+    (if (prime? n) n (fail))))
+
+;;; ==============================
+
+(def-scheme-macro amb (x y)
+  `(random-choice (lambda () ,x) (lambda () ,y))))
+
+;;; ==============================
+
+(define backtrack-points nil)
+
+(define (fail)
+  (let ((last-choice (car backtrack-points)))
+    (set! backtrack-points (cdr backtrack-points))
+    (last-choice)))
+
+(define (random-choice f g)
+  (if (= 1 (random 2))
+      (choose-first f g)
+      (choose-first g f)))
+
+(define (choose-first f g)
+  (call/cc
+    (lambda (k)
+      (set! backtrack-points
+            (cons (lambda () (k (g))) backtrack-points))
+      (f))))
+
+;;; ==============================
+
+(call/cc (lambda (cc) (set! reset (lambda () 
+                                    (cc "Back to top level")))))
+
+;;; ==============================
+
+(defun call/cc (computation)
+  "Call computation, passing it the current continuation.
+  The continuation has only dynamic extent."
+  (funcall computation #'(lambda (x) (return-from call/cc x))))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/interp3.lisp norvig-paip-pjb/interp3.lisp
--- norvig/interp3.lisp	1997-02-05 07:39:52.000000000 +0100
+++ norvig-paip-pjb/interp3.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -4,8 +4,6 @@
 
 ;;; File interp3.lisp: Scheme interpreter with explicit continuations
 
-;;; One bug fix by Cheng Lu Hsu, hsuc@cory.Berkeley.EDU
-
 (requires "interp1")
 
 (defun interp (x env cc)
@@ -39,23 +37,19 @@
 
 ;;; ==============================
 
-(defun scheme (&optional x)
+(defun scheme ()
   "A Scheme read-eval-print loop (using interp).
   Handles call/cc by explicitly passing continuations."
-  ;; Modified by norvig Jun 11 96 to handle optional argument
-  ;; instead of always going into a loop.
   (init-scheme-interp)
-  (if x
-      (interp x nil #'print)
-    (loop (format t "~&==> ")
-      (interp (read) nil #'print))))
+  (loop (format t "~&==> ")
+        (interp (read) nil #'print)))
 
 (defun interp-begin (body env cc)
   "Interpret each element of BODY, passing the last to CC."
   (interp (first body) env
           #'(lambda (val)
               (if (null (rest body))
-                  (funcall cc val) ;; fix, hsuc 2/20/93; forgot to call cc
+                  val
                   (interp-begin (rest body) env cc)))))
 
 (defun interp-call (call env cc)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/intro.lisp norvig-paip-pjb/intro.lisp
--- norvig/intro.lisp	1997-02-05 07:39:52.000000000 +0100
+++ norvig-paip-pjb/intro.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -47,6 +47,17 @@
 
 ;;; ==============================
 
+(defun mappend (fn the-list)
+  "Apply fn to each element of list and append the results."
+  (if (null the-list)
+      nil
+      (append (funcall fn (first the-list))
+              (mappend fn (rest the-list)))))
+
+;;; ==============================
+
+;;; ==============================
+
 (defun atomprint (exp &optional (depth 0))
   "Print each atom in exp, along with its depth of nesting."
   (if (atom exp)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/krep1.dat norvig-paip-pjb/krep1.dat
--- norvig/krep1.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/krep1.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,43 @@
+;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;; Code from Paradigms of Artificial Intelligence Programming
+;;; Copyright (c) 1991 Peter Norvig
+
+> (test-index)
+((#1=(P A B)
+  #2=(P A C)
+  #3=(P A ?X)
+  #4=(P B C)
+  #5=(P B (F C))
+  #6=(P A (F . ?X)))
+ #(#(NIL NIL (P (6 #6# #5# #4# #3# #2# #1#)) (0))
+   #(#(NIL NIL (B (2 #5# #4#) A (4 #6# #3# #2# #1#)) (0))
+     #(#(#(NIL NIL (F (2 #6# #5#)) (0))
+         #(#(NIL NIL (C (1 #5#)) (0))
+           #(NIL NIL NIL (0)) NIL (1 #6#))
+         (C (2 #4# #2#) B (1 #1#))
+         (1 #3#))
+       #(NIL NIL NIL (0))
+       NIL (0))
+     NIL (0))
+   NIL (0)))
+
+> (fetch '(p ? c))
+(((P B C) (P A C))
+ ((P A ?X)))
+3
+
+> (fetch '(p ?x c))
+(((P B C) (P A C))
+ ((P A ?X3408)))
+3
+
+> (retrieve '(p ?x c))
+(((?X3408 . C) (?X . A))
+ ((?X . A))
+ ((?X . B)))
+
+> (retrieve-matches '(p ?v c))
+((P A C) (P A C) (P B C))
+
+> (retrieve-matches '(p ?w (?fn c)))
+((P A (?FN C)) (P A (F C)) (P B (F C)))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/krep1.lisp norvig-paip-pjb/krep1.lisp
--- norvig/krep1.lisp	1997-02-05 07:39:52.000000000 +0100
+++ norvig-paip-pjb/krep1.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -29,21 +29,19 @@
 
 ;;; ==============================
 
-;; Not all Lisps handle the closure properly, so change the local PREDICATES
-;; to a global *predicates* - norvig Jun 11 1996
-(defvar *predicates* nil)
-
-(defun get-dtree (predicate)
-  "Fetch (or make) the dtree for this predicate."
-  (cond ((get predicate 'dtree))
-	(t (push predicate *predicates*)
-	   (setf (get predicate 'dtree) (make-dtree)))))
-
-(defun clear-dtrees ()
-  "Remove all the dtrees for all the predicates."
-  (dolist (predicate *predicates*)
-    (setf (get predicate 'dtree) nil))
-  (setf *predicates* nil))
+(let ((predicates nil))
+
+  (defun get-dtree (predicate)
+    "Fetch (or make) the dtree for this predicate."
+    (cond ((get predicate 'dtree))
+          (t (push predicate predicates)
+             (setf (get predicate 'dtree) (make-dtree)))))
+
+  (defun clear-dtrees ()
+    "Remove all the dtrees for all the predicates."
+    (dolist (predicate predicates)
+      (setf (get predicate 'dtree) nil))
+    (setf predicates nil)))
 
 ;;; ==============================
 
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/krep.lisp norvig-paip-pjb/krep.lisp
--- norvig/krep.lisp	1997-02-05 07:39:52.000000000 +0100
+++ norvig-paip-pjb/krep.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -124,26 +124,23 @@
                        (replace-?-vars (rest exp))
                        exp))))
 
-;;;; Support for Multiple Worlds
-
-;; In the book, we redefine index, but that screws up other things,
-;; so we'll define index-in-world instead of index.
+;;; ==============================
 
 (defvar *world* 'W0 "The current world used by index and fetch.")
 
-(defun index-in-world (key &optional (world *world*))
+(defun index (key &optional (world *world*))
   "Store key in a dtree node.  Key must be (predicate . args);
   it is stored in the dtree, indexed by the world."
-  (dtree-index-in-world key key world (get-dtree (predicate key))))
+  (dtree-index key key world (get-dtree (predicate key))))
 
-(defun dtree-index-in-world (key value world dtree)
+(defun dtree-index (key value world dtree)
   "Index value under all atoms of key in dtree."
   (cond
     ((consp key)                ; index on both first and rest
-     (dtree-index-in-world (first key) value world
+     (dtree-index (first key) value world
                   (or (dtree-first dtree)
                       (setf (dtree-first dtree) (make-dtree))))
-     (dtree-index-in-world (rest key) value world
+     (dtree-index (rest key) value world
                   (or (dtree-rest dtree)
                       (setf (dtree-rest dtree) (make-dtree)))))
     ((null key))                ; don't index on nil
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/lexicon.lisp norvig-paip-pjb/lexicon.lisp
--- norvig/lexicon.lisp	1997-02-05 07:39:53.000000000 +0100
+++ norvig-paip-pjb/lexicon.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -83,7 +83,7 @@
   "Add a noun and its plural to the lexicon."
   `(add-noun-form ',base ,@(mapcar #'kwote args)))
 
-(defun add-noun-form (base &optional (plural (symbol base 's))
+(defun add-noun-form (base &optional (plural (simbol base 's))
                       (sem base) &rest slots)
   (if (eq plural '*)
       (add-word base 'noun '? slots sem)
@@ -96,10 +96,10 @@
   `(add-verb ',senses ',base ,@(mapcar #'kwote (mklist forms))))
 
 (defun add-verb (senses base &optional
-                 (past (symbol (strip-vowel base) 'ed))
+                 (past (simbol (strip-vowel base) 'ed))
                  (past-part past)
-                 (pres-part (symbol (strip-vowel base) 'ing))
-                 (plural (symbol base 's)))
+                 (pres-part (simbol (strip-vowel base) 'ing))
+                 (plural (simbol base 's)))
   "Enter a verb into the lexicon."
   (add-word base 'verb 'nonfinite senses)
   (add-word base 'verb '(finite ~3sing present) senses)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/macsyma.dat norvig-paip-pjb/macsyma.dat
--- norvig/macsyma.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/macsyma.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,100 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+> (simplifier)
+SIMPLIFIER> (2 + 2)
+4 
+SIMPLIFIER> (5 * 20 + 30 + 7)
+137 
+SIMPLIFIER> (5 * x - (4 + 1) * x)
+0 
+SIMPLIFIER> (y / z * (5 * x - (4 + 1) * x))
+0 
+SIMPLIFIER> ((4 - 3) * x + (y / y - 1) * z)
+X 
+SIMPLIFIER> (1 * f(x) + 0)
+(F X) 
+SIMPLIFIER> (3 * 2 * X)
+(3 * (2 * X))
+SIMPLIFIER> [Abort]
+
+> (simplifier)
+SIMPLIFIER> (3 * 2 * x)
+(6 * X) 
+SIMPLIFIER> (2 * x * x * 3)
+(6 * (X ^ 2)) 
+SIMPLIFIER> (2 * x * 3 * y * 4 * z * 5 * 6)
+(720 * (X * (Y * Z))) 
+SIMPLIFIER> (3 + x + 4 + x)
+((2 * X) + 7) 
+SIMPLIFIER> (2 * x * 3 * x * 4 * (1 / x) * 5 * 6)
+(720 * X)
+
+SIMPLIFIER> (3 + x + 4 - x)
+((X + (4 - X)) + 3) 
+SIMPLIFIER> (x + y + y + x)
+(X + (Y + (Y + X)))
+SIMPLIFIER> (3 * x + 4 * x)
+((3 * X) + (4 * X)) 
+
+SIMPLIFIER> (d (x + x) / d x)
+2 
+SIMPLIFIER> (d (a * x ^ 2 + b * x + c) / d x)
+((2 * (A * X)) + B) 
+SIMPLIFIER> (d ((a * x ^ 2 + b * x + c) / x) / d x)
+((((A * (X ^ 2)) + ((B * X) + C)) - (X * ((2 * (A * X)) + B)))
+ / (X ^ 2))
+SIMPLIFIER> (log ((d (x + x) / d x) / 2))
+0 
+SIMPLIFIER> (log(x + x) - log x)
+(LOG 2)
+SIMPLIFIER> (x ^ cos pi)
+(1 / X) 
+SIMPLIFIER> (d (3 * x + (cos x) / x) / d x)
+((((COS X) - (X * (- (SIN X)))) / (X ^ 2)) + 3)
+SIMPLIFIER> (d ((cos x) / x) / d x)
+(((COS X) - (X * (- (SIN X)))) / (X ^ 2))
+SIMPLIFIER> (d (3 * x ^ 2 + 2 * x + 1) / d x)
+((6 * X) + 2)
+SIMPLIFIER> (sin(x + x) ^ 2 + cos(d x ^ 2 / d x) ^ 2)
+1 
+SIMPLIFIER> (sin(x + x) * sin(d x ^ 2 / d x) +
+             cos(2 * x) * cos(x * d 2 * y / d y))
+1 
+
+SIMPLIFIER> (x + y + y + x)
+(X + (Y + (Y + X)))
+
+SIMPLIFIER> (3 * x + 4 * x)
+((3 * X) + (4 * X))
+SIMPLIFIER> (3 * x + y + x + 4 * x) 
+((3 * X) + (Y + (X + (4 * X)))) 
+
+(set-simp-fn 'Int #'(lambda (exp) 
+                      (integrate (exp-lhs exp) (exp-rhs exp))))
+
+SIMPLIFIER> (Int x * sin(x ^ 2) d x)
+(1/2 * (- (COS (X ^ 2)))) 
+SIMPLIFIER> (Int ((3 * x ^ 3) - 1 / (3 * x ^ 3)) d x)
+((3 * ((X ^ 4) / 4)) - (1/3 * ((X ^ -2) / -2))) 
+SIMPLIFIER> (Int (3 * x + 2) ^ -2/3 d x)
+(((3 * X) + 2) ^ 1/3) 
+SIMPLIFIER> (Int sin(x) ^ 2 * cos(x) d x)
+(((SIN X) ^ 3) / 3) 
+SIMPLIFIER> (Int sin(x) / (1 + cos(x)) d x)
+(-1 * (LOG ((COS X) + 1))) 
+SIMPLIFIER> (Int (2 * x + 1) / (x ^ 2 + x - 1) d x)
+(LOG ((X ^ 2) + (X - 1))) 
+SIMPLIFIER> (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)
+(8 * ((1/3 * (((X ^ 3) + 2) ^ -2)) / -2)) 
+
+(set-simp-fn 'Int 
+  #'(lambda (exp)
+      (unfactorize
+       (factorize
+        (integrate (exp-lhs exp) (exp-rhs exp))))))
+
+SIMPLIFIER> (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)
+(-4/3 * (((X ^ 3) + 2) ^ -2)) 
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/macsyma.lisp norvig-paip-pjb/macsyma.lisp
--- norvig/macsyma.lisp	1997-02-05 07:39:53.000000000 +0100
+++ norvig-paip-pjb/macsyma.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -6,11 +6,6 @@
 
 (requires "patmatch")
 
-(defun variable-p (exp)
-  "Variables are the symbols M through Z."
-  ;; put x,y,z first to find them a little faster
-  (member exp '(x y z m n o p q r s t u v w)))
-
 ;;; From student.lisp:
 (defstruct (rule (:type list)) pattern response)
 (defstruct (exp (:type list)
@@ -31,15 +26,6 @@
                   (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))
                   exp))))
 
-;; Define x+ and y+ as a sequence:
-(pat-match-abbrev 'x+ '(?+ x))
-(pat-match-abbrev 'y+ '(?+ y))
-
-;; Define n and m as numbers; s as a non-number:
-(pat-match-abbrev 'n '(?is n numberp))
-(pat-match-abbrev 'm '(?is m numberp))
-(pat-match-abbrev 's '(?is s not-numberp))
-
 (defparameter *infix->prefix-rules*
   (mapcar #'expand-pat-match-abbrev
     '(((x+ = y+) (= x y))
@@ -72,7 +58,15 @@
          (list (first exp) (infix->prefix (rest exp))))
         (t (error "Illegal exp"))))
 
-(defvar *simplification-rules* nil) ;Rules are in file macsymar.lisp
+(defun variable-p (exp)
+  "Variables are the symbols M through Z."
+  ;; put x,y,z first to find them a little faster
+  (member exp '(x y z m n o p q r s t u v w)))
+
+(pat-match-abbrev 'x+ '(?+ x))
+(pat-match-abbrev 'y+ '(?+ y))
+
+(defparameter *simplification-rules* nil) ; Rules are in file macsyma-rules.lisp
 
 (defun ^ (x y) "Exponentiation" (expt x y))
 
@@ -89,15 +83,14 @@
   (if (atom exp) exp
       (simplify-exp (mapcar #'simplify exp))))
 
-;;; simplify-exp is redefined below
-;(defun simplify-exp (exp)
-;  "Simplify using a rule, or by doing arithmetic."
-;  (cond ((rule-based-translator exp *simplification-rules*
-;           :rule-if #'exp-lhs :rule-then #'exp-rhs
-;           :action #'(lambda (bindings response)
-;                       (simplify (sublis bindings response)))))
-;        ((evaluable exp) (eval exp))
-;        (t exp)))
+(defun simplify-exp (exp)
+  "Simplify using a rule, or by doing arithmetic."
+  (cond ((rule-based-translator exp *simplification-rules*
+           :rule-if #'exp-lhs :rule-then #'exp-rhs
+           :action #'(lambda (bindings response)
+                       (simplify (sublis bindings response)))))
+        ((evaluable exp) (eval exp))
+        (t exp)))
 
 (defun evaluable (exp)
   "Is this an arithmetic expression that can be evaluated?"
@@ -106,13 +99,18 @@
            (and (eq (exp-op exp) '^)
                 (integerp (second (exp-args exp)))))))
 
+;; Define n and m as numbers; s as a non-number:
+(pat-match-abbrev 'n '(?is n numberp))
+(pat-match-abbrev 'm '(?is m numberp))
+(pat-match-abbrev 's '(?is s not-numberp))
+
 (defun not-numberp (x) (not (numberp x)))
 
 (defun simp-rule (rule)
   "Transform a rule into proper format."
   (let ((exp (infix->prefix rule)))
     (mkexp (expand-pat-match-abbrev (exp-lhs exp))
-	   (exp-op exp) (exp-rhs exp))))
+           (exp-op exp) (exp-rhs exp))))
 
 (defun simp-fn (op) (get op 'simp-fn))
 (defun set-simp-fn (op fn) (setf (get op 'simp-fn) fn))
@@ -263,8 +261,7 @@
 
 (defun integration-table (rules)
   (dolist (i-rule rules)
-    ;; changed infix->prefix to simp-rule - norvig Jun 11 1996
-    (let ((rule (simp-rule i-rule)))
+    (let ((rule (infix->prefix i-rule)))
       (setf (get (exp-op (exp-lhs (exp-lhs rule))) 'int)
             rule))))
 
@@ -274,8 +271,3 @@
 (defun integrate-from-table (op arg)
   (let ((rule (get op 'int)))
     (subst arg (exp-lhs (exp-lhs (exp-lhs rule))) (exp-rhs rule))))
-
-(set-simp-fn 'Int #'(lambda (exp)
-		      (unfactorize
-		       (factorize
-			(integrate (exp-lhs exp) (exp-rhs exp))))))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/macsymar.lisp norvig-paip-pjb/macsymar.lisp
--- norvig/macsymar.lisp	1997-02-05 07:39:53.000000000 +0100
+++ norvig-paip-pjb/macsymar.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -6,7 +6,7 @@
 
 (requires "macsyma")
 
-(setf *simplification-rules* (mapcar #'simp-rule '(
+(setf *simplification-rules* (mapcar #'infix->prefix '(
   (x + 0  = x)
   (0 + x  = x)
   (x + x  = 2 * x)
@@ -77,15 +77,15 @@
   (d (u - v) / d x = (d u / d x) - (d v / d x))
   (d (- u) / d x   = - (d u / d x))
   (d (u * v) / d x = u * (d v / d x) + v * (d u / d x))
-  (d (u / v) / d x = (v * (d u / d x) - u * (d v / d x)) 
-                     / v ^ 2) ; [This corrects an error in the first printing]
+  (d (u / v) / d x = (u * (d v / d x) - v * (d u / d x)) 
+                     / v ^ 2)
   (d (u ^ n) / d x = n * u ^ (n - 1) * (d u / d x))
   (d (u ^ v) / d x = v * u ^ (v - 1) * (d u / d x)
                    + u ^ v * (log u) * (d v / d x))
   (d (log u) / d x = (d u / d x) / u)
   (d (sin u) / d x = (cos u) * (d u / d x))
   (d (cos u) / d x = - (sin u) * (d u / d x))
-  (d (e ^ u) / d x = (e ^ u) * (d u / d x))
+  (d (exp u) / d x = (exp u) * (d u / d x))
   (d u / d x       = 0)))))
 
         
@@ -99,14 +99,3 @@
     (Int cosh(x) d x = sinh(x))
     (Int tanh(x) d x = log(cosh(x)))
     ))
-
-;;; Some examples to try (from an integration table):
-
-; (simp '(int sin(x) / cos(x) ^ 2 d x))
-; (simp '(int sin(x / a) d x))
-; (simp '(int sin(a + b * x) d x))
-; (simp '(int sin x * cos x d x))
-; (simp '(Int log x / x d x))
-; (simp '(Int 1 / (x * log x) d x))
-; (simp '(Int (log x) ^ 3 / x d x))
-; (simp '(Int exp(a * x) d x))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/mycin.dat norvig-paip-pjb/mycin.dat
--- norvig/mycin.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/mycin.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,82 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+> (mycin)
+------ PATIENT-1 ------
+Patient's name: Sylvia Fischer
+Sex: female
+Age: 27
+------ CULTURE-1 ------
+From what site was the specimen for CULTURE-1 taken? blood
+How many days ago was this culture (CULTURE-1) obtained? 3
+------ ORGANISM-1 ------
+Enter the identity (genus) of ORGANISM-1: unknown
+The gram stain of ORGANISM-1: ?
+A GRAM must be of type (MEMBER ACID-FAST POS NEG)
+The gram stain of ORGANISM-1: neg
+
+Is ORGANISM-1 a rod or coccus (etc.): rod
+What is the AEROBICITY of ORGANISM-1? why
+[Why is the value of AEROBICITY being asked for?]
+It is known that:
+    1) THE GRAM OF THE ORGANISM IS NEG
+    2) THE MORPHOLOGY OF THE ORGANISM IS ROD
+Therefore,
+Rule 107:
+  If
+    1) THE AEROBICITY OF THE ORGANISM IS AEROBIC
+  Then there is suggestive evidence (0.8) that
+    1) THE IDENTITY OF THE ORGANISM IS ENTEROBACTERIACEAE 
+
+What is the AEROBICITY of ORGANISM-1? aerobic
+Is Sylvia Fischer a compromised host? yes
+Is Sylvia Fischer a burn patient?  If so, mild or serious? why
+[Why is the value of BURN being asked for?]
+It is known that:
+    1) THE SITE OF THE CULTURE IS BLOOD
+    2) THE GRAM OF THE ORGANISM IS NEG
+    3) THE MORPHOLOGY OF THE ORGANISM IS ROD
+Therefore,
+Rule 52:
+  If
+    1) THE BURN OF THE PATIENT IS SERIOUS
+  Then there is weakly suggestive evidence (0.4) that
+    1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS 
+Is Sylvia Fischer a burn patient?  If so, mild or serious? serious
+Findings for ORGANISM-1:
+ IDENTITY: ENTEROBACTERIACEAE (0.800)   PSEUDOMONAS (0.760)  
+
+Is there another ORGANISM? (Y or N) Y
+------ ORGANISM-2 ------
+Enter the identity (genus) of ORGANISM-2: unknown
+The gram stain of ORGANISM-2: (neg .8 pos .2)
+Is ORGANISM-2 a rod or coccus (etc.): rod
+What is the AEROBICITY of ORGANISM-2?  anaerobic
+
+Findings for ORGANISM-2:
+ IDENTITY: BACTEROIDES (0.720)   PSEUDOMONAS (0.646)  
+
+Is there another ORGANISM? (Y or N) N
+Is there another CULTURE? (Y or N) N
+Is there another PATIENT? (Y or N) N
+
+;;;; If you add the following rules, then rerun the last case above,
+;;;; MYCIN will do backward chaining.  See section 16.8.
+
+(defparm wbc patient number
+  "What is ~a's white blood cell count?")
+
+(defrule 1
+  if (immunosuppressed patient is yes)
+  then 1.0 (compromised-host patient is yes))
+
+(defrule 2
+  if (leukopenia patient is yes)
+  then 1.0 (immunosuppressed patient is yes))
+
+(defrule 3
+  if (wbc patient < 2.5)
+  then .9 (leukopenia patient is yes))
+
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/mycin-r.lisp norvig-paip-pjb/mycin-r.lisp
--- norvig/mycin-r.lisp	1997-02-05 07:39:54.000000000 +0100
+++ norvig-paip-pjb/mycin-r.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -4,8 +4,6 @@
 
 ;;;; File mycin-r.lisp: Sample parameter list and rulebase for mycin.
 
-(requires "mycin")
-
 ;;; Parameters for patient:
 (defparm name patient t "Patient's name: " t read-line)
 (defparm sex patient (member male female) "Sex:" t)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/ORDERING norvig-paip-pjb/ORDERING
--- norvig/ORDERING	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/ORDERING	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,55 @@
+
+	      Paradigms of Artificial Intelligence Programming:
+			 Case Studies in Common Lisp
+
+			       by Peter Norvig
+
+Published Oct. 1991, ISBN 1-55860-191-0, 946 pages, paper.
+
+The book can be ordered by calling the publisher or by filling in the 
+order form below and mailing, FAXing, or Emailing it to:
+
+	Morgan Kaufmann Publishers, Inc.	Tel: 	   (415) 578-9928
+	2929 Campus Drive, Suite 260		Toll-free: (800) 745-7323
+	San Mateo, CA 94403 USA			FAX:	   (415) 578-0672
+						Email:	   morgan@unix.sri.com
+
+The software from the book is available by anonymous ftp on the Internet
+from unix.sri.com (128.18.10.3), in directory pub/norvig.  If you do not
+have access to the Internet, the software can be ordered from the
+publisher, in either Apple Macintosh or IBM DOS format.
+
+
+#Copies	Title                                   	  Price      Subtotal
+_____________________________________________________________________________
+
+______  Paradigms of AI Programming             	  $39.95     ________
+
+______  Paradigms of AI Programming w/software  	  $54.95     ________
+	Disk: ___ Mac / ___ 5.25" DOS / ___ 3.5" DOS 
+
+______	California Residents add sales tax                  	     ________
+		
+______	Shipping (US/Canada) $3.50 first copy, $2.50 addtl.  	     ________
+
+______	Shipping (Intrntnl.) $6.50 first copy, $3.50 addtl. 	     ________
+
+
+						TOTAL       	     ________
+
+
+
+Payment by:  ___ US $ check / ___ VISA / ___ MCard / ___ Amex 
+
+			    Card # __________________________
+
+                            Signature _______________________
+
+
+Name:   ____________________________________________
+
+Address: ___________________________________________
+
+         ___________________________________________
+
+         ___________________________________________
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/othello2.lisp norvig-paip-pjb/othello2.lisp
--- norvig/othello2.lisp	1997-02-05 07:39:55.000000000 +0100
+++ norvig-paip-pjb/othello2.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -12,10 +12,11 @@
 
 (requires "othello")
 
-(defconstant all-squares
-  (sort (loop for i from 11 to 88 
-	      when (<= 1 (mod i 10) 8) collect i)
-        #'> :key #'(lambda (sq) (elt *weights* sq))))
+;;; Already defined in othello:
+;;; (defconstant all-squares
+;;;   (sort (loop for i from 11 to 88 
+;;; 	      when (<= 1 (mod i 10) 8) collect i)
+;;;         #'> :key #'(lambda (sq) (elt *weights* sq))))
 
 (defstruct (node) square board value)
 
@@ -355,3 +356,4 @@
   "Use an approximation of Iago's evaluation function."
   (alpha-beta-searcher3 depth #'iago-eval))
 
+;;;; othello2.lisp                    -- 2003-05-16 07:45:38 -- pascal   ;;;;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/othello.dat norvig-paip-pjb/othello.dat
--- norvig/othello.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/othello.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,273 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(print-board (initial-board))
+
+     1 2 3 4 5 6 7 8 [@=2 O=2 (+0)]
+  10 . . . . . . . . 
+  20 . . . . . . . . 
+  30 . . . . . . . . 
+  40 . . . O @ . . . 
+  50 . . . @ O . . . 
+  60 . . . . . . . . 
+  70 . . . . . . . . 
+  80 . . . . . . . . 
+
+(write (initial-board) :array t)          
+#(3 3 3 3 3 3 3 3 3 3       
+  3 0 0 0 0 0 0 0 0 3       
+  3 0 0 0 0 0 0 0 0 3       
+  3 0 0 0 0 0 0 0 0 3       
+  3 0 0 0 2 1 0 0 0 3       
+  3 0 0 0 1 2 0 0 0 3       
+  3 0 0 0 0 0 0 0 0 3       
+  3 0 0 0 0 0 0 0 0 3       
+  3 0 0 0 0 0 0 0 0 3       
+  3 3 3 3 3 3 3 3 3 3)      
+#<ART-2B-100 -72570734>
+
+(othello (maximizer #'weighted-squares) 
+         (maximizer #'count-difference) nil)
+
+(othello (maximizer #'count-difference)
+         (maximizer #'weighted-squares) nil) 
+
+(othello (minimax-searcher 3 #'count-difference)
+         (maximizer #'count-difference))
+...
+
+The game is over.  Final result:
+
+     1 2 3 4 5 6 7 8   [@=53 O=0  (+53)]
+  10 @ @ @ @ @ @ @ @ 
+  20 @ @ @ @ @ @ @ @ 
+  30 @ @ @ @ @ @ @ @ 
+  40 @ @ @ @ @ @ @ @ 
+  50 @ @ @ @ @ @ @ @ 
+  60 . . @ @ @ @ @ @ 
+  70 . . . @ @ @ @ @ 
+  80 . . . . @ @ . .
+
+53
+;;; The following should produce the same result, but faster
+
+(othello (alpha-beta-searcher 3 #'count-difference)
+	 (maximizer #'count-difference))
+
+;;; ==============================
+
+(othello (alpha-beta-searcher 4 #'count-difference)
+         (alpha-beta-searcher 4 #'weighted-squares))
+
+     1 2 3 4 5 6 7 8   [@=20 O=1  (+19)]
+  10 O @ . . . . . . 
+  20 . @ . . . @ @ . 
+  30 @ @ @ @ @ @ . . 
+  40 . @ . @ @ . . . 
+  50 @ @ @ @ @ @ . . 
+  60 . @ . . . . . . 
+  70 . . . . . . . . 
+  80 . . . . . . . . 
+
+;;; ==============================
+
+     1 2 3 4 5 6 7 8   [@=32 O=15 (+17)]
+  10 O O O O @ @ O O 
+  20 @ @ O @ @ @ @ @ 
+  30 @ @ O O @ O @ @ 
+  40 O O @ @ @ @ @ @ 
+  50 @ O @ @ @ @ . . 
+  60 @ @ O @ @ O . . 
+  70 @ . . @ @ . . . 
+  80 . . . . . . . . 
+
+     1 2 3 4 5 6 7 8   [@=34 O=19 (+15)]
+  10 O O O O @ @ O O 
+  20 @ @ O @ @ @ @ @ 
+  30 @ @ O O @ O @ @ 
+  40 O @ O @ @ @ @ @ 
+  50 O @ O @ @ @ @ . 
+  60 O @ O @ @ @ . . 
+  70 O @ @ @ @ . . . 
+  80 O @ O . . . . . 
+
+
+;;; ==============================
+
+
+     1 2 3 4 5 6 7 8   [@=31 O=30 (+1)]
+  10 O O O O @ @ O O 
+  20 @ @ O O @ @ @ O 
+  30 @ @ O O O @ @ O 
+  40 O @ O O O @ @ O 
+  50 O @ O @ O @ @ O 
+  60 O @ O @ @ @ @ O 
+  70 O @ @ @ @ @ O O 
+  80 O @ @ @ . . . O 
+
+O moves to 85.
+
+     1 2 3 4 5 6 7 8   [@=23 O=39 (-16)]
+  10 O O O O @ @ O O 
+  20 @ @ O O @ @ @ O 
+  30 @ @ O O O @ @ O 
+  40 O @ O O O @ @ O 
+  50 O @ O @ O @ @ O 
+  60 O @ O @ O @ O O 
+  70 O @ @ O O O O O 
+  80 O O O O O . . O 
+
+@ moves to 86.
+
+     1 2 3 4 5 6 7 8   [@=26 O=37 (-11)]
+  10 O O O O @ @ O O 
+  20 @ @ O O @ @ @ O 
+  30 @ @ O O O @ @ O 
+  40 O @ O O O @ @ O 
+  50 O @ O @ O @ @ O 
+  60 O @ O @ O @ O O 
+  70 O @ @ O @ @ O O 
+  80 O O O O O @ . O 
+
+O moves to 87.
+The game is over.  Final result:
+
+     1 2 3 4 5 6 7 8   [@=24 O=40 (-16)]
+  10 O O O O @ @ O O 
+  20 @ @ O O @ @ @ O 
+  30 @ @ O O O @ @ O 
+  40 O @ O O O @ @ O 
+  50 O @ O @ O @ @ O 
+  60 O @ O @ O @ O O 
+  70 O @ @ O @ O O O 
+  80 O O O O O O O O 
+-16
+
+(othello (alpha-beta-searcher 6 #'count-difference)
+         (alpha-beta-searcher 4 #'weighted-squares))
+
+;;; ==============================
+
+     1 2 3 4 5 6 7 8   [@=21 O=8  (+13)]
+  10 . . @ @ @ @ @ . 
+  20 . @ . @ O @ . . 
+  30 O @ @ O @ O O . 
+  40 . @ . @ O @ O . 
+  50 . @ @ @ @ @ . . 
+  60 . @ . @ . O . . 
+  70 . . . . . . . . 
+  80 . . . . . . . . 
+
+;;; ==============================
+
+     1 2 3 4 5 6 7 8   [@=34 O=11 (+23)]
+  10 O . @ @ @ @ @ . 
+  20 . O O @ @ @ . . 
+  30 O @ O O @ @ @ @ 
+  40 @ @ @ @ O @ @ . 
+  50 @ @ @ @ @ O @ . 
+  60 @ @ @ @ @ @ O O 
+  70 @ . . @ . . @ O 
+  80 . . . . . . . . 
+
+;;; ==============================
+
+     1 2 3 4 5 6 7 8   [@=23 O=27 (-4)]
+  10 O O O O O O O O 
+  20 @ @ O @ @ @ . . 
+  30 O @ O O @ @ @ @ 
+  40 O @ O @ O @ @ . 
+  50 O @ O @ @ O @ . 
+  60 O O O @ @ @ O O 
+  70 O . O @ . . @ O 
+  80 O . . . . . . . 
+
+;;; ==============================
+
+     1 2 3 4 5 6 7 8   [@=24 O=40 (-16)]
+  10 O O O O O O O O 
+  20 @ @ O @ O O @ @ 
+  30 O @ O O @ @ @ @ 
+  40 O @ O O @ @ @ O 
+  50 O O @ @ O @ O O 
+  60 O O O @ O @ @ O 
+  70 O O O O @ @ O O 
+  80 O O O O O @ @ O 
+-16
+
+;;; ==============================
+
+     1 2 3 4 5 6 7 8   [@=20 O=1  (+19)]
+  10 O @ . . . . . . 
+  20 . @ . . . @ @ . 
+  30 @ @ @ @ @ @ . . 
+  40 . @ . @ @ . . . 
+  50 @ @ @ @ @ @ . . 
+  60 . @ . . . . . . 
+  70 . . . . . . . . 
+  80 . . . . . . . . 
+
+;;; ==============================
+
+;;; Using modified-weighted-squares
+
+     1 2 3 4 5 6 7 8   [@=42 O=21 (+21)]
+  10 @ @ @ @ @ @ @ @ 
+  20 @ @ O O O O @ @ 
+  30 @ O @ @ @ @ O @ 
+  40 @ O @ @ @ @ O @ 
+  50 @ O @ O @ @ O @ 
+  60 @ @ O @ O @ @ @ 
+  70 @ O @ @ @ @ @ @ 
+  80 O O O O O O O . 
+
+;;; ==============================
+
+(othello-series 
+  (alpha-beta-searcher 2 #'modified-weighted-squares)
+  (alpha-beta-searcher 2 #'weighted-squares) 5)
+0
+60
+(-28 40 -28 40 -28 40 -28 40 -28 40)
+
+(random-othello-series 
+  (alpha-beta-searcher 2 #'weighted-squares)
+  (alpha-beta-searcher 2 #'modified-weighted-squares)
+  5)
+4
+-76
+(-8 -40 22 -30 10 -10 12 -18 4 -18)
+
+> (round-robin
+   (list (maximizer #'count-difference)
+         (maximizer #'mobility)
+         (maximizer #'weighted-squares)
+         (maximizer #'modified-weighted-squares)
+         #'random-strategy)
+   5 10
+   '(count-difference mobility weighted modified-weighted random))
+
+COUNT-DIFFERENCE     12.5:  ---  3.0  2.5  0.0  7.0 
+MOBILITY             20.5:  7.0  ---  1.5  5.0  7.0 
+WEIGHTED             28.0:  7.5  8.5  ---  3.0  9.0 
+MODIFIED-WEIGHTED    31.5: 10.0  5.0  7.0  ---  9.5 
+RANDOM                7.5:  3.0  3.0  1.0  0.5  --- 
+
+;;; ==============================
+
+> (round-robin
+   (list (alpha-beta-searcher 4 #'count-difference)
+         (alpha-beta-searcher 4 #'weighted-squares)
+         (alpha-beta-searcher 4 #'modified-weighted-squares)
+         #'random-strategy)
+   5 10 
+   '(count-difference weighted modified-weighted random))
+
+COUNT-DIFFERENCE     12.0:  ---  2.0  0.0 10.0
+WEIGHTED             23.5:  8.0  ---  5.5 10.0
+MODIFIED-WEIGHTED    24.5: 10.0  4.5  --- 10.0
+RANDOM                0.0:  0.0  0.0  0.0  ---
+
+;;; ==============================
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/othello.lisp norvig-paip-pjb/othello.lisp
--- norvig/othello.lisp	1997-02-05 07:39:54.000000000 +0100
+++ norvig-paip-pjb/othello.lisp	2008-03-18 20:52:52.000000000 +0100
@@ -5,8 +5,6 @@
 ;;;; File othello.lisp: An othello monitor, with all strategies
 ;;;; up to and including section 18.8
 
-;;; One bug fix by Alberto Segre, segre@cs.cornell.edu, March 1993.
-
 (defun cross-product (fn xlist ylist)
   "Return a list of all (fn x y) values."
   (mappend #'(lambda (y)
@@ -80,9 +78,13 @@
   "Make any flips in the given direction."
   (let ((bracketer (would-flip? move player board dir)))
     (when bracketer
-      (loop for c from (+ move dir) by dir until (eql c bracketer)
+      ;; strict clhs forbid (minusp dir)
+      ;; (loop for c from (+ move dir) by dir until (eql c bracketer)
+      ;;       do (setf (bref board c) player))
+      (loop for c = (+ move dir) then (+ c dir) until (eql c bracketer)
             do (setf (bref board c) player)))))
 
+
 (defun would-flip? (move player board dir)
   "Would this move result in any flips in this direction?
   If so, return the square number of the bracketing piece."
@@ -122,9 +124,8 @@
 
 (defun legal-moves (player board)
   "Returns a list of legal moves for player"
-  ;;*** fix, segre, 3/30/93.  Was remove-if, which can share with all-squares.
-  (loop for move in all-squares
-	when (legal-p move player board) collect move))
+  (remove-if #'(lambda (move) (not (legal-p move player board)))
+             all-squares))
 
 (defun maximize-difference (player board)
   "A strategy that maximizes the difference in pieces."
@@ -273,7 +274,7 @@
     (aref neighbor-table square)))
 
 (let ((square-names 
-        (cross-product #'symbol
+        (cross-product #'simbol
                        '(? a b c d e f g h ?)
                        '(? 1 2 3 4 5 6 7 8 ?))))
 
@@ -436,3 +437,4 @@
   "The number of moves a player has."
   (length (legal-moves player board)))
 
+;;;; othello.lisp                     -- 2003-05-14 17:27:50 -- pascal   ;;;;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/overview.lisp norvig-paip-pjb/overview.lisp
--- norvig/overview.lisp	1997-02-05 07:39:55.000000000 +0100
+++ norvig-paip-pjb/overview.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -63,9 +63,9 @@
         summing 1))              ;   adding 1 each time
 
 (defun length6 (list)
-  (loop with len = 0             ; start with LEN=0
+  (loop for element = (pop list) ; on each iteration
+        with len = 0             ; start with LEN=0
         until (null list)        ; and (until end of list)
-        for element = (pop list) ; on each iteration
         do (incf len)            ;  increment LEN by 1
         finally (return len)))   ; and return LEN
 
@@ -350,3 +350,4 @@
 
 ;;; ==============================
 
+;;;; overview.lisp                    -- 2003-05-14 17:25:47 -- pascal   ;;;;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/patmatch.dat norvig-paip-pjb/patmatch.dat
--- norvig/patmatch.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/patmatch.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,52 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(pat-match '(x = (?is ?n numberp)) '(x = 34))
+;;;; -> ((?n . 34))
+
+(pat-match '(x = (?is ?n numberp)) '(x = x))
+;;;; -> NIL
+
+(pat-match '(?x (?or < = >) ?y) '(3 < 4))
+;;;; -> ((?Y . 4) (?X . 3))
+
+(pat-match '(x = (?and (?is ?n numberp) (?is ?n oddp))) '(x = 3))
+;;;; -> ((?N . 3))
+
+(pat-match '(?x /= (?not ?x)) '(3 /= 4))
+;;;; -> ((?X . 3))
+
+(pat-match '(?x > ?y (?if (> ?x ?y))) '(4 > 3))
+;;;; -> ((?Y . 3) (?X . 4))
+
+(pat-match '(a (?* ?x) d) '(a b c d))
+;;;; -> ((?X B C))
+
+(pat-match '(a (?* ?x) (?* ?y) d) '(a b c d))
+;;;; -> ((?Y B C) (?X))
+
+(pat-match '(a (?* ?x) (?* ?y) ?x ?y) '(a b c d (b c) (d)))
+;;;; -> ((?Y D) (?X B C))
+
+(pat-match '(?x ?op ?y is ?z (?if (eql (?op ?x ?y) ?z))) '(3 + 4 is 7))
+;;;; -> ((?Z . 7) (?Y . 4) (?OP . +) (?X . 3))
+
+(pat-match '(?x ?op ?y (?if (?op ?x ?y))) '(3 > 4))
+;;;; -> NIL
+
+(pat-match-abbrev '?x* '(?* ?x))
+;;;; -> (?* ?X)
+
+(pat-match-abbrev '?y* '(?* ?y))
+;;;; -> (?* ?Y)
+
+(setf axyd (expand-pat-match-abbrev '(a ?x* ?y* d)))
+;;;; -> (A (?* ?X) (?* ?Y) D)
+
+(pat-match axyd '(a b c d))
+;;;; -> ((?Y B C) (?X))
+
+(pat-match '(((?* ?x) (?* ?y)) ?x ?y) '((a b c d) (a b) (c d)))
+;;;; -> NIL
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/patmatch.lisp norvig-paip-pjb/patmatch.lisp
--- norvig/patmatch.lisp	1997-02-05 07:39:55.000000000 +0100
+++ norvig-paip-pjb/patmatch.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -6,12 +6,6 @@
 
 ;;; Two bug fixes By Richard Fateman, rjf@cs.berkeley.edu  October 92.
 
-;;; The basic are in auxfns.lisp; look for "PATTERN MATCHING FACILITY"
-
-(defun variable-p (x)
-  "Is x a variable (a symbol beginning with `?')?"
-  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))
-
 (defun pat-match (pattern input &optional (bindings no-bindings))
   "Match pattern against input in the context of the bindings"
   (cond ((eq bindings fail) fail)
@@ -28,6 +22,49 @@
                                bindings)))
         (t fail)))
 
+(defconstant fail nil "Indicates pat-match failure")
+
+;; Already defined in auxfns.lisp
+;; (defconstant no-bindings '((t . t))
+;;   "Indicates pat-match success, with no variables.")
+
+(defun variable-p (x)
+  "Is x a variable (a symbol beginning with `?')?"
+  (and (symbolp x) (equal (char (symbol-name x) 0) #\?)))
+
+(defun get-binding (var bindings)
+  "Find a (variable . value) pair in a binding list."
+  (assoc var bindings))
+
+(defun binding-var (binding)
+  "Get the variable part of a single binding."
+  (car binding))
+
+(defun binding-val (binding)
+  "Get the value part of a single binding."
+  (cdr binding))
+
+(defun make-binding (var val) (cons var val))
+
+(defun lookup (var bindings)
+  "Get the value part (for var) from a binding list."
+  (binding-val (get-binding var bindings)))
+
+(defun extend-bindings (var val bindings)
+  "Add a (var . value) pair to a binding list."
+  (cons (make-binding var val)
+        ;; Once we add a "real" binding,
+        ;; we can get rid of the dummy no-bindings
+        (if (and (eq bindings no-bindings))
+            nil
+            bindings)))
+
+(defun match-variable (var input bindings)
+  "Does VAR match input?  Uses (or updates) and returns bindings."
+  (let ((binding (get-binding var bindings)))
+    (cond ((not binding) (extend-bindings var input bindings))
+          ((equal input (binding-val binding)) bindings)
+          (t fail))))
 
 (setf (get '?is  'single-match) 'match-is)
 (setf (get '?or  'single-match) 'match-or)
@@ -156,8 +193,7 @@
 
 (defun pat-match-abbrev (symbol expansion)
   "Define symbol as a macro standing for a pat-match pattern."
-  (setf (get symbol 'expand-pat-match-abbrev) 
-    (expand-pat-match-abbrev expansion)))
+  (setf (get symbol 'expand-pat-match-abbrev) expansion))
 
 (defun expand-pat-match-abbrev (pat)
   "Expand out all pattern matching abbreviations in pat."
@@ -167,7 +203,7 @@
                  (expand-pat-match-abbrev (rest pat))))))
 
 (defun rule-based-translator 
-       (input rules &key (matcher 'pat-match) 
+       (input rules &key (matcher #'pat-match) 
         (rule-if #'first) (rule-then #'rest) (action #'sublis))
   "Find the first rule in rules that matches input,
   and apply the action to that rule."
@@ -178,3 +214,4 @@
           (if (not (eq result fail))
               (funcall action result (funcall rule-then rule)))))
     rules))
+;;;; patmatch.lisp                    -- 2003-05-14 17:05:43 -- pascal   ;;;;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prolog1.dat norvig-paip-pjb/prolog1.dat
--- norvig/prolog1.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/prolog1.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,41 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(<- (likes Kim Robin))
+(<- (likes Sandy Lee))
+(<- (likes Sandy Kim))
+(<- (likes Robin cats))
+(<- (likes Sandy ?x) (likes ?x cats))
+(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
+(<- (likes ?x ?x))
+
+(?- (likes Sandy ?who))
+;;;; ?WHO = LEE;
+;;;; ?WHO = KIM;
+;;;; ?WHO = ROBIN;
+;;;; ?WHO = SANDY;
+;;;; ?WHO = CATS;
+;;;; ?WHO = SANDY;
+
+(?- (likes ?who Sandy))
+;;;; ?WHO = SANDY;
+;;;; ?WHO = KIM;
+;;;; ?WHO = SANDY;
+
+(?- (likes Robin Lee))
+;;;; No.
+
+(?- (likes ?x ?y) (likes ?y ?x))
+;;;; ?Y = KIM
+;;;; ?X = SANDY;
+;;;; ?Y = SANDY
+;;;; ?X = SANDY;
+;;;; ?Y = SANDY
+;;;; ?X = SANDY;
+;;;; ?Y = SANDY
+;;;; ?X = KIM;
+;;;; ?Y = SANDY
+;;;; ?X = SANDY;
+;;;; ?Y = ?X3251
+;;;; ?X = ?X3251;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologc1.dat norvig-paip-pjb/prologc1.dat
--- norvig/prologc1.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/prologc1.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,33 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(<- (likes Robin cats))
+(<- (likes Sandy ?x) (likes ?x cats))
+(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
+
+(prolog-compile 'likes)
+;;;; (DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)
+;;;;  (IF (UNIFY! ?ARG1 'ROBIN)
+;;;;      (IF (UNIFY! ?ARG2 'CATS)
+;;;;          (FUNCALL CONT)))
+;;;;  (IF (UNIFY! ?ARG1 'SANDY)
+;;;;      (IF (UNIFY! ?ARG2 ?X)
+;;;;          (LIKES/2 ?X 'CATS CONT)))
+;;;;  (IF (UNIFY! ?ARG1 'KIM)
+;;;;      (IF (UNIFY! ?ARG2 ?X)
+;;;;          (LIKES/2 ?X 'LEE (LAMBDA ()
+;;;;                             (LIKES/2 ?X 'KIM CONT)))))) 
+
+(<- (member ?item (?item . ?rest)))
+(<- (member ?item (?x . ?rest)) (member ?item ?rest))
+
+(prolog-compile 'member)
+;;;; (DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)
+;;;;  (IF (UNIFY! ?ARG1 ?ITEM)
+;;;;      (IF (UNIFY! ?ARG2 (CONS ?ITEM ?REST))
+;;;;          (FUNCALL CONT)))
+;;;;  (IF (UNIFY! ?ARG1 ?ITEM)
+;;;;      (IF (UNIFY! ?ARG2 (CONS ?X ?REST))
+;;;;          (MEMBER/2 ?ITEM ?REST CONT))))
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologc1.lisp norvig-paip-pjb/prologc1.lisp
--- norvig/prologc1.lisp	1997-02-05 07:39:57.000000000 +0100
+++ norvig-paip-pjb/prologc1.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -108,7 +108,7 @@
 
 (defun make-predicate (symbol arity)
   "Return the symbol: symbol/arity"
-  (symbol symbol '/ arity))
+  (simbol symbol '/ arity))
 
 (defun compile-clause (parms clause cont)
   "Transform away the head, and compile the resulting body."
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologc2.dat norvig-paip-pjb/prologc2.dat
--- norvig/prologc2.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/prologc2.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,45 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(<- (likes Robin cats))
+(<- (likes Sandy ?x) (likes ?x cats))
+(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
+
+(prolog-compile 'likes)
+;;;; (DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)
+;;;;  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
+;;;;    (IF (UNIFY! ?ARG1 'ROBIN)
+;;;;        (IF (UNIFY! ?ARG2 'CATS)
+;;;;            (FUNCALL CONT)))
+;;;;    (UNDO-BINDINGS! OLD-TRAIL)
+;;;;    (LET ((?X (?)))
+;;;;      (IF (UNIFY! ?ARG1 'SANDY)
+;;;;          (IF (UNIFY! ?ARG2 ?X)
+;;;;              (LIKES/2 ?X 'CATS CONT))))
+;;;;    (UNDO-BINDINGS! OLD-TRAIL)
+;;;;    (LET ((?X (?)))
+;;;;      (IF (UNIFY! ?ARG1 'KIM)
+;;;;          (IF (UNIFY! ?ARG2 ?X)
+;;;;              (LIKES/2 ?X 'LEE (LAMBDA ()
+;;;;                                 (LIKES/2 ?X 'KIM CONT)))))))) 
+
+(<- (member ?item (?item . ?rest)))
+(<- (member ?item (?x . ?rest)) (member ?item ?rest))
+
+(prolog-compile 'member)
+;;;; (DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)
+;;;;  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
+;;;;    (LET ((?ITEM (?))
+;;;;          (?REST (?)))
+;;;;      (IF (UNIFY! ?ARG1 ?ITEM)
+;;;;          (IF (UNIFY! ?ARG2 (CONS ?ITEM ?REST))
+;;;;              (FUNCALL CONT))))
+;;;;    (UNDO-BINDINGS! OLD-TRAIL)
+;;;;    (LET ((?X (?))
+;;;;          (?ITEM (?))
+;;;;          (?REST (?)))
+;;;;      (IF (UNIFY! ?ARG1 ?ITEM)
+;;;;          (IF (UNIFY! ?ARG2 (CONS ?X ?REST))
+;;;;              (MEMBER/2 ?ITEM ?REST CONT))))))
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologc2.lisp norvig-paip-pjb/prologc2.lisp
--- norvig/prologc2.lisp	1997-02-05 07:39:57.000000000 +0100
+++ norvig-paip-pjb/prologc2.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -96,7 +96,7 @@
 
 (defun make-predicate (symbol arity)
   "Return the symbol: symbol/arity"
-  (symbol symbol '/ arity))
+  (simbol symbol '/ arity))
 
 (defun make-= (x y) `(= ,x ,y))
 
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologc.dat norvig-paip-pjb/prologc.dat
--- norvig/prologc.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/prologc.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,53 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(<- (likes Robin cats))
+(<- (likes Sandy ?x) (likes ?x cats))
+(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
+
+(prolog-compile 'likes)
+;;;; (DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)
+;;;;  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
+;;;;    (IF (UNIFY! ?ARG1 'ROBIN)
+;;;;        (IF (UNIFY! ?ARG2 'CATS)
+;;;;            (FUNCALL CONT)))
+;;;;    (UNDO-BINDINGS! OLD-TRAIL)
+;;;;    (IF (UNIFY! ?ARG1 'SANDY)
+;;;;        (LIKES/2 ?ARG2 'CATS CONT))
+;;;;    (UNDO-BINDINGS! OLD-TRAIL)
+;;;;    (IF (UNIFY! ?ARG1 'KIM)
+;;;;        (LIKES/2 ?ARG2 'LEE (LAMBDA ()
+;;;;                              (LIKES/2 ?ARG2 'KIM CONT))))))
+
+(<- (member ?item (?item . ?rest)))
+(<- (member ?item (?x . ?rest)) (member ?item ?rest))
+
+(prolog-compile 'member)
+;;;; (DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)
+;;;;  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
+;;;;    (IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))
+;;;;        (FUNCALL CONT))
+;;;;    (UNDO-BINDINGS! OLD-TRAIL)
+;;;;    (LET ((?REST (?)))
+;;;;      (IF (UNIFY! ?ARG2 (CONS (?) ?REST))
+;;;;          (MEMBER/2 ?ARG1 ?REST CONT)))))
+
+(<- (test-cut) (p a) (p b) ! (p c) (p d))
+(<- (test-cut) (p e))
+
+(<- (p ?x) (write (?x 1)))
+(<- (p ?x) (write (?x 2)))
+
+(?- (test-cut))
+;;;; (A 1)(B 1)(C 1)(D 1)
+;;;; Yes;
+;;;; (D 2)
+;;;; Yes;
+;;;; (C 2)(D 1)
+;;;; Yes;
+;;;; (D 2)
+;;;; Yes;
+;;;; No.
+
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologc.lisp norvig-paip-pjb/prologc.lisp
--- norvig/prologc.lisp	1997-02-05 07:39:56.000000000 +0100
+++ norvig-paip-pjb/prologc.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -96,7 +96,7 @@
 
 (defun make-predicate (symbol arity)
   "Return the symbol: symbol/arity"
-  (symbol symbol '/ arity))
+  (simbol symbol '/ arity))
 
 (defun make-= (x y) `(= ,x ,y))
 
@@ -298,7 +298,7 @@
       (mapcar #'self-cons parms))))                    ;***
 
 (defvar *uncompiled* nil 
-  "Prolog symbols that have not been compiled.")
+        "Prolog symbols that have not been compiled.")
 
 (defun add-clause (clause)
   "Add a clause to the data base, indexed by head's predicate."
@@ -321,7 +321,7 @@
                   (show-prolog-vars ,(mapcar #'symbol-name vars)
                                     ,vars))))
   ;; Now run it
-  (run-prolog 'top-level-query/0 #'ignore)
+  (run-prolog 'top-level-query/0 #'ygnore)
   (format t "~&No.")
   (values))
 
@@ -342,7 +342,7 @@
   (mapc #'prolog-compile symbols)
   (setf *uncompiled* (set-difference *uncompiled* symbols)))
 
-(defun ignore (&rest args)
+(defun ygnore (&rest args)
   (declare (ignore args))
   nil)
 
@@ -410,3 +410,4 @@
                            (rest body) cont
                            (bind-new-variables bindings goal))))))))))
 
+;;;; prologc.lisp                     -- 2003-05-14 17:30:42 -- pascal   ;;;;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prologcp.lisp norvig-paip-pjb/prologcp.lisp
--- norvig/prologcp.lisp	1997-02-05 07:39:57.000000000 +0100
+++ norvig-paip-pjb/prologcp.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -75,9 +75,7 @@
   ;;     (bagof ?x (p ?x) ?l) ==> ?l = (1 2 3)
   (let ((answers nil))
     (call/1 goal #'(lambda ()
-		     ;; Bug fix by mdf0%shemesh@gte.com (Mark Feblowitz)
-		     ;; on 25 Jan 1996; was deref-COPY
-                     (push (deref-EXP exp) answers))) 
+                     (push (deref-copy exp) answers)))
     (if (and (not (null answers))
              (unify! result (nreverse answers)))
         (funcall cont))))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/prolog.dat norvig-paip-pjb/prolog.dat
--- norvig/prolog.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/prolog.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,100 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(<- (member ?item (?item . ?rest)))
+(<- (member ?item (?x . ?rest)) (member ?item ?rest))
+
+(?- (member 2 ?list))
+;;;; ?LIST = (2 . ?REST3302);
+;;;; ?LIST = (?X3303 2 . ?REST3307);
+;;;; ?LIST = (?X3303 ?X3308 2 . ?REST3312);
+;;;; ?LIST = (?X3303 ?X3308 ?X3313 2 . ?REST3317).
+;;;; No.
+
+(?- (member ?item ?list))
+;;;; ?ITEM = ?ITEM3318
+;;;; ?LIST = (?ITEM3318 . ?REST3319);
+;;;; ?ITEM = ?ITEM3323
+;;;; ?LIST = (?X3320 ?ITEM3323 . ?REST3324);
+;;;; ?ITEM = ?ITEM3328
+;;;; ?LIST = (?X3320 ?X3325 ?ITEM3328 . ?REST3329);
+;;;; ?ITEM = ?ITEM3333
+;;;; ?LIST = (?X3320 ?X3325 ?X3330 ?ITEM3333 . ?REST3334).
+;;;; No.
+
+(<- (length () 0))
+(<- (length (?x . ?y) (1+ ?n)) (length ?y ?n))
+
+(?- (length (a b c d) ?n))
+;;;; ?N = (1+ (1+ (1+ (1+ 0))));
+;;;; No.
+
+(?- (length ?list (1+ (1+ 0))))
+;;;; ?LIST = (?X3869 ?X3872);
+;;;; No.
+
+(?- (length ?list ?n))
+;;;; ?LIST = NIL
+;;;; ?N = 0;
+;;;; ?LIST = (?X3918)
+;;;; ?N = (1+ 0);
+;;;; ?LIST = (?X3918 ?X3921)
+;;;; ?N = (1+ (1+ 0)).
+;;;; No.
+
+(?- (length ?l (1+ (1+ 0))) (member a ?l))
+;;;; ?L = (A ?X4057);
+;;;; ?L = (?Y4061 A);
+;;;; No.
+
+(?- (member a ?l) (length ?l (1+ (1+ 0))))
+;;;; ?L = (A ?X4081);
+;;;; ?L = (?Y4085 A);[Abort]
+
+;;;; Section 11.4 (The Zebra Problem)
+
+(<- (nextto ?x ?y ?list) (iright ?x ?y ?list))
+(<- (nextto ?x ?y ?list) (iright ?y ?x ?list))
+
+(<- (iright ?left ?right (?left ?right . ?rest)))
+(<- (iright ?left ?right (?x . ?rest)) 
+    (iright ?left ?right ?rest))
+
+(<- (= ?x ?x))
+
+(<- (zebra ?h ?w ?z)
+  ;; Each house is of the form:
+  ;; (house nationality pet cigarette drink house-color)
+  (= ?h ((house norwegian ? ? ? ?)               ;1,10
+         ? 
+         (house ? ? ? milk ?) ? ?))              ; 9
+  (member (house englishman ? ? ? red) ?h)       ; 2
+  (member (house spaniard dog ? ? ?) ?h)         ; 3
+  (member (house ? ? ? coffee green) ?h)         ; 4
+  (member (house ukrainian ? ? tea ?) ?h)         ; 5
+  (iright (house ? ? ? ? ivory)                  ; 6
+          (house ? ? ? ? green) ?h)
+  (member (house ? snails winston ? ?) ?h)       ; 7
+  (member (house ? ? kools ? yellow) ?h)         ; 8
+  (nextto (house ? ? chesterfield ? ?)           ;11
+          (house ? fox ? ? ?) ?h)
+  (nextto (house ? ? kools ? ?)                  ;12
+          (house ? horse ? ? ?) ?h)
+  (member (house ? ? luckystrike oj ?) ?h)       ;13
+  (member (house japanese ? parliaments ? ?) ?h) ;14
+  (nextto (house norwegian ? ? ? ?)              ;15
+          (house ? ? ? ? blue) ?h)
+  (member (house ?w ? ? water ?) ?h)             ;Q1
+  (member (house ?z zebra ? ? ?) ?h))            ;Q2
+
+(?- (zebra ?houses ?water-drinker ?zebra-owner))
+;;;; ?HOUSES = ((HOUSE NORWEGIAN FOX KOOLS WATER YELLOW)
+;;;;           (HOUSE UKRAINIAN HORSE CHESTERFIELD TEA BLUE)
+;;;;           (HOUSE ENGLISHMAN SNAILS WINSTON MILK RED)
+;;;;           (HOUSE SPANIARD DOG LUCKYSTRIKE OJ IVORY)
+;;;;           (HOUSE JAPANESE ZEBRA PARLIAMENTS COFFEE GREEN))
+;;;; ?WATER-DRINKER = NORWEGIAN
+;;;; ?ZEBRA-OWNER = JAPANESE.
+;;;; No.
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/README norvig-paip-pjb/README
--- norvig/README	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/README	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,202 @@
+
+			      Code for
+	  Paradigms of Artificial Intelligence Programming:
+		     Case Studies in Common Lisp
+		   Copyright (c) 1991 Peter Norvig
+
+The Lisp source code files for the book "Paradigms of Artificial
+Intelligence Programming" are available by anonymous FTP from the
+Internet, and on disk in Macintosh or DOS format from the publisher,
+Morgan Kaufmann.  The total size is about 440K bytes in 78 files of
+source code and data.  Currently there are two sites for anonymous FTP:
+
+country machine		  number	directory/files
+------- ----------------- -----------	---------------
+USA     unix.sri.com	  128.18.10.3	pub/norvig/*
+Japan   etlport.etl.go.jp		pub/eus/norvig/* 
+					(or pub/eus/norvig.tar.Z)
+
+The downloading process works like this:
+
+Computer Prints:		You type:
+----------------		---------
+%				ftp unix.sri.com
+Name (unix.sri.com:yourname)	anonymous
+Password:			yourname@your.address
+ftp>				cd pub/norvig
+250 CWD command succesful.
+ftp>				prompt off
+Interactive mode off.
+ftp>				mget *
+...
+ftp>				bye
+221 Goodbye.
+
+Most of the files use some auxiliary macros and functions, so you
+should load the files "auxmacs" and "auxfns" first.  Then load the
+files you are interested in.  The index below gives the chapter in
+the book, file name, and short description for each file.  The
+filenames are shorter than normal to fit within the DOS limitation of
+eight-character names.  If you have acquired a DOS disk, you will
+find that the file type ".lisp" has been changed to ".lis" but
+everything else works the same.
+
+The function "requires" is used for a primitive form of control over
+what files require other files to be loaded first.  If "requires" does
+not work properly on your system you may have to alter its definition,
+in the file "auxfns.lisp".  For more complicated use of these files,
+you should follow the guidelines for organizing files explained in
+Chapter 24.  Many of the Lisp files have a corresponding file of type
+".dat".  These files contain appropriate test data.  They should not
+be loaded, but rather should be evaluated one expression at a time,
+comparing the output from your system with the output listed in the
+file.
+
+For more information, see the file "ORDERING" or contact:
+
+	Morgan Kaufmann Publishers, Inc.	Tel: 	   (415) 578-9928
+	2929 Campus Drive, Suite 260		Toll-free: (800) 745-7323
+	San Mateo, CA 94403 USA			FAX:	   (415) 578-0672
+						Email:	   morgan@unix.sri.com
+
+
+CH FILENAME		DESCRIPTION
+== =======		===========
+-  README		This file: explanation and index
+-  ORDERING		How to order the book from the publisher
+-  ERRATA		Corrections for bugs and typos
+-  auxmacs.lisp		A few macros; load this first
+24 loop.lisp		Load this next if your Lisp doesn't support ANSI LOOP
+-  auxfns.lisp		Commonly used auxiliary functions; load this third
+
+1  intro.lisp		A few simple definitions
+2  simple.lisp		Random sentence generator (two versions)
+3  overview.lisp	14 versions of LENGTH and other examples
+
+4  gps1.lisp		Simple version of General Problem Solver
+4  gps1.dat		Test data (examples) for above
+4  gps.lisp		Final version of General Problem Solver
+4  gps.dat		Test data (examples) for above
+
+5  eliza1.lisp		Basic version of Eliza program
+5  eliza.lisp		Eliza with more rules; different reader
+
+6  patmatch.lisp	Pattern Matching Utility
+6  patmatch.dat		Test data (examples) for above
+6  eliza-pm.lisp	Version of Eliza using utilities
+6  search.lisp		Search Utility
+6  search.dat		Test data (examples) for above
+6  gps-srch.lisp	Version of GPS using the search utility 
+6  gps-srch.dat		Test data (examples) for above
+
+7  student.lisp		The Student Program
+7  student.dat		Test data (examples) for above
+
+8  macsyma.lisp		The Macsyma Program
+8  macsymar.lisp	Simplification and integration rules for Macsyma
+8  macsyma.dat		Test data (examples) for above
+
+9-10			<no files; important functions in auxfns.lisp>
+
+11 unify.lisp		Unification functions
+11 prolog1.lisp		First version of Prolog interpreter
+11 prolog1.dat		Test data (examples) for above
+11 prolog.lisp		Final version of Prolog interpreter
+11 prolog.dat		Test data (examples) for above
+
+12 prologc1.lisp	First version of Prolog compiler
+12 prologc1.dat		Test data (examples) for above
+12 prologc2.lisp	Second version of Prolog compiler
+12 prologc2.dat		Test data (examples) for above
+12 prologc.lisp		Final version of Prolog compiler
+12 prologc.dat		Test data (examples) for above
+12 prologcp.lisp	Primitives for Prolog compiler
+
+13 clos.lisp		Some object-oriented and CLOS code
+13 clos.dat		Test data (examples) for above
+
+14 krep1.lisp		Knowledge Representation code: first version 
+14 krep1.dat		Test data (examples) for above
+14 krep2.lisp		Knowledge Representation code with conjunctions
+14 krep.lisp		Final KR code: worlds and attached functions
+
+15 cmacsyma.lisp	Efficient Macsyma with canonical form
+15 cmacsyma.dat		Test data (examples) for above
+
+16 mycin.lisp		The Emycin expert system shell
+16 mycin-r.lisp		Some rules for a medical application of emycin
+16 mycin.dat		Test data (examples) for above
+
+17 waltz.lisp		A Line-Labeling program using the Waltz algorithm
+17 waltz.dat		Test data (examples) for above
+
+18 othello.lisp		The Othello playing program and some strategies
+18 othello.dat		Test data (examples) for above
+18 othello2.lisp	Additional strategies for Othello
+18 edge-tab.lisp	Edge table for Iago strategy
+
+19 syntax1.lisp		Syntactic Parser
+19 syntax1.dat		Test data (examples) for above
+19 syntax2.lisp		Syntactic Parser with semantics
+19 syntax2.dat		Test data (examples) for above
+19 syntax3.lisp		Syntactic Parser with semantics and preferences
+19 syntax3.dat		Test data (examples) for above
+
+20 unifgram.lisp	Unification Parser
+20 unifgram.dat		Test data (examples) for above
+
+21 grammar.lisp		Comprehensive grammar of English
+21 lexicon.lisp		Sample Lexicon of English
+21 grammar.dat		Test data (examples) for above
+
+22 interp1.lisp		Scheme interpreter, including version with macros
+22 interp1.dat		Test data (examples) for above
+22 interp2.lisp		A tail recurive Scheme interpreter
+22 interp3.lisp		A Scheme interpreter that handles call/cc
+22 interp3.dat		Test data (examples) for above
+
+23 compile1.lisp	Simple Scheme compiler
+23 compile2.lisp	Compiler with tail recursion and primitives
+23 compile3.lisp	Compiler with peephole optimizer
+23 compopt.lisp		Peephole optimizers for compile3.lisp
+23 compile.dat		Test data (examples) for all 3 versions above
+
+
+To use these files you must have a Common Lisp compiler.  There are
+two free implementations available on the Internet, and at least four
+vendors who will sell you a full industrial-strength implementation,
+but only if you are willing to spend over $1000.
+
+
+Kyoto Common Lisp (KCL) is free, but requires a license.
+Austin Kyoto Common Lisp (AKCL) is Bill Schelter's
+improvements to KCL. Both are available by anonymous ftp
+from rascal.ics.utexas.edu [128.83.138.20] in the directory
+/pub. KCL is in the file kcl.tar, and AKCL is in the file
+akcl-xxx.tar.Z (take the highest value of xxx). 
+Runs on Sparc, IBM RT, RS/6000.
+Mailing List:kcl@rascal.ics.utexas.edu
+
+
+CMU Common Lisp is free, and runs on Sparcs (Mach and SunOs),
+DecStation 3100 (Mach), IBM RT (Mach) and requires 16mb RAM,
+25mb disk. It includes an incremental compiler, Hemlock 
+emacs-style editor, source-code level debugger, code profiler
+and is X3J13 compatible, including the new loop macro.
+It is available by anonymous ftp from any CMU CS machine,
+such as lisp-rt1.slisp.cs.cmu.edu and lisp-rt2.slisp.cs.cmu.edu,
+in the directory /afs/cs.cmu.edu/project/clisp/release. Login
+with username "anonymous" and "userid@host" (your email address)
+as password. Due to security restrictions on anonymous ftps,
+it is important to "cd" to the source directory with a single
+command. Don't forget to put the ftp into binary mode before
+using "get" to obtain the compressed/tarred files. The binary
+releases are contained in files of the form
+<version>-<machine>_<os>.tar.Z
+Other files in this directory of possible interest are
+15b-sun4-source.tar.Z, which contains all the ".lisp" source
+files used to build version 15b for Sparc machines, and
+10-16-91-cmucl-master.tar.Z which contains the
+project/clisp/master subtree, with RCS source (,v) files for
+all of CMU CL. Bug reports should be sent to cmucl-bugs@cs.cmu.edu.
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/README.html norvig-paip-pjb/README.html
--- norvig/README.html	2002-04-10 02:04:00.000000000 +0200
+++ norvig-paip-pjb/README.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,137 +0,0 @@
-<HTML>
-<TITLE>Paradigms of AI Programming Source Code</TITLE> 
-<!-- Changed by: Peter Norvig,  2-Jul-1996 -->
-<BODY bgcolor="#ffffff"> 
-<h1>Paradigms of AI Programming Source Code</h1> 
-
-<p>
-This page is the index for the Lisp source code files
-for the book <i>Paradigms of Artificial
-Intelligence Programming</i>.  The code is offered as
-open source freeware under <a href="../license.html">this license</a>.
-You can browse all the files in <a href="../paip/">this directory</a>.
-
-<h1>Installation Instructions</h1>
-
-<ol>
-<li> Download the file <a href="paip.zip">paip.zip</a> and unzip it.
-<li> You must have a <a href="http://www-2.cs.cmu.edu/Groups/AI/html/faqs/lang/lisp/part4/faq-doc-1.html">lisp compiler/interpreter</a>.
-<li> To test all the code, do the following:
-<pre>
-(load "auxfns.lisp")
-(requires "examples")
-(do-examples :all)
-</pre>
-This should print out a long list of inputs and outputs, and the last output
-should be the total number of errors.  If all goes well, this should be "0".
-</ol>
-
-<h1>Use</h1>
-
-To use the code, edit any of the files or add new files.  You will
-always have to do <tt>(load "auxfns.lisp")</tt> first, and you will
-typically have to do <tt>(requires "<i>file</i>")</tt>, for various
-instances of <i>file</i> that you want to use. 
-
-<p>
-The function "requires"
-is used for a primitive form of control over what files require other
-files to be loaded first.  If "requires" does not work properly on
-your system you may have to alter its definition, in the file
-"auxfns.lisp".  For more complicated use of these files, you should
-follow the guidelines for organizing files explained in Chapter 24.
-
-<p>
-The function <tt>do-examples</tt>, which takes as an argument either <tt>:all</tt>
-or a chapter number or a list of chapter numbers, can be used to see examples
-of the use of various functions.  For example, <tt>(do-examples 1)</tt> shows
-the examples from chapter 1.
-
-<h1>The Files</h1>
-
-The index below gives the chapter in the book, file
-name, and short description for each file.  
-
-
-<pre>
-CH Filename		Description
-== =======		===========
--  <a href="README.html">README.html</a>		This file: explanation and index
--  <a href="examples.lisp">examples.lisp</a>	A list of example inputs taken from the book
--  <a href="tutor.lisp">tutor.lisp</a>		An interactive application for running the examples
--  <a href="gui-capi.lisp">gui-capi.lisp</a>	Graphical User Interface for Harlequin's CAPI
--  <a href="gui-mcl.lisp">gui-mcl.lisp</a>		Graphical User Interface for Macintosh Common Lisp
-
-24 <a href="loop.lisp">loop.lisp</a>		Load this first if your Lisp doesn't support ANSI LOOP
--  <a href="auxfns.lisp">auxfns.lisp</a>		Auxiliary functions; load this before anything else
-
-1  <a href="intro.lisp">intro.lisp</a>		A few simple definitions
-2  <a href="simple.lisp">simple.lisp</a>		Random sentence generator (two versions)
-3  <a href="overview.lisp">overview.lisp</a>	14 versions of LENGTH and other examples
-
-4  <a href="gps1.lisp">gps1.lisp</a>		Simple version of General Problem Solver
-4  <a href="gps.lisp">gps.lisp</a>		Final version of General Problem Solver
-
-5  <a href="eliza1.lisp">eliza1.lisp</a>		Basic version of Eliza program
-5  <a href="eliza.lisp">eliza.lisp</a>		Eliza with more rules; different reader
-
-6  <a href="patmatch.lisp">patmatch.lisp</a>	Pattern Matching Utility
-6  <a href="eliza-pm.lisp">eliza-pm.lisp</a>	Version of Eliza using utilities
-6  <a href="search.lisp">search.lisp</a>		Search Utility
-6  <a href="gps-srch.lisp">gps-srch.lisp</a>	Version of GPS using the search utility 
-
-7  <a href="student.lisp">student.lisp</a>		The Student Program
-
-8  <a href="macsyma.lisp">macsyma.lisp</a>		The Macsyma Program
-8  <a href="macsymar.lisp">macsymar.lisp</a>	Simplification and integration rules for Macsyma
-
-9-10			(no files; important functions in <a href="auxfns.lisp">auxfns.lisp</a>	
-
-11 <a href="unify.lisp">unify.lisp</a>		Unification functions
-11 <a href="prolog1.lisp">prolog1.lisp</a>		First version of Prolog interpreter
-11 <a href="prolog.lisp">prolog.lisp</a>		Final version of Prolog interpreter
-
-12 <a href="prologc1.lisp">prologc1.lisp</a>	First version of Prolog compiler
-12 <a href="prologc2.lisp">prologc2.lisp</a>	Second version of Prolog compiler
-12 <a href="prologc.lisp">prologc.lisp</a>		Final version of Prolog compiler
-12 <a href="prologcp.lisp">prologcp.lisp</a>	Primitives for Prolog compiler
-
-13 <a href="clos.lisp">clos.lisp</a>		Some object-oriented and CLOS code
-
-14 <a href="krep1.lisp">krep1.lisp</a>		Knowledge Representation code: first version 
-14 <a href="krep2.lisp">krep2.lisp</a>		Knowledge Representation code with conjunctions
-14 <a href="krep.lisp">krep.lisp</a>		Final KR code: worlds and attached functions
-
-15 <a href="cmacsyma.lisp">cmacsyma.lisp</a>	Efficient Macsyma with canonical form
-
-16 <a href="mycin.lisp">mycin.lisp</a>		The Emycin expert system shell
-16 <a href="mycin-r.lisp">mycin-r.lisp</a>		Some rules for a medical application of emycin
-
-17 <a href="waltz.lisp">waltz.lisp</a>		A Line-Labeling program using the Waltz algorithm
-
-18 <a href="othello.lisp">othello.lisp</a>		The Othello playing program and some strategies
-18 <a href="othello2.lisp">othello2.lisp</a>	Additional strategies for Othello
-18 <a href="edge-tab.lisp">edge-tab.lisp</a>	Edge table for Iago strategy
-
-19 <a href="syntax1.lisp">syntax1.lisp</a>		Syntactic Parser
-19 <a href="syntax2.lisp">syntax2.lisp</a>		Syntactic Parser with semantics
-19 <a href="syntax3.lisp">syntax3.lisp</a>		Syntactic Parser with semantics and preferences
-
-20 <a href="unifgram.lisp">unifgram.lisp</a>	Unification Parser
-
-21 <a href="grammar.lisp">grammar.lisp</a>		Comprehensive grammar of English
-21 <a href="lexicon.lisp">lexicon.lisp</a>		Sample Lexicon of English
-
-22 <a href="interp1.lisp">interp1.lisp</a>		Scheme interpreter, including version with macros
-22 <a href="interp2.lisp">interp2.lisp</a>		A tail recurive Scheme interpreter
-22 <a href="interp3.lisp">interp3.lisp</a>		A Scheme interpreter that handles call/cc
-
-23 <a href="compile1.lisp">compile1.lisp</a>	Simple Scheme compiler
-23 <a href="compile2.lisp">compile2.lisp</a>	Compiler with tail recursion and primitives
-23 <a href="compile3.lisp">compile3.lisp</a>	Compiler with peephole optimizer
-23 <a href="compopt.lisp">compopt.lisp</a>		Peephole optimizers for compile3.lisp
-</pre>
-<p>
-<hr>
-<i><a href="http://www.norvig.com">Peter Norvig</a></i>
-
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/search.dat norvig-paip-pjb/search.dat
--- norvig/search.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/search.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,171 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(debug :search)
+;;;; -> (SEARCH)
+
+(breadth-first-search 1 (is 12) 'binary-tree)
+;; Search: (1)
+;; Search: (2 3)
+;; Search: (3 4 5)
+;; Search: (4 5 6 7)
+;; Search: (5 6 7 8 9)
+;; Search: (6 7 8 9 10 11)
+;; Search: (7 8 9 10 11 12 13)
+;; Search: (8 9 10 11 12 13 14 15)
+;; Search: (9 10 11 12 13 14 15 16 17)
+;; Search: (10 11 12 13 14 15 16 17 18 19)
+;; Search: (11 12 13 14 15 16 17 18 19 20 21)
+;; Search: (12 13 14 15 16 17 18 19 20 21 22 23)
+;;;; -> 12
+
+(depth-first-search 1 (is 12) (finite-binary-tree 15))
+;; Search: (1)
+;; Search: (2 3)
+;; Search: (4 5 3)
+;; Search: (8 9 5 3)
+;; Search: (9 5 3)
+;; Search: (5 3)
+;; Search: (10 11 3)
+;; Search: (11 3)
+;; Search: (3)
+;; Search: (6 7)
+;; Search: (12 13 7)
+;;;; -> 12
+
+(best-first-search 1 (is 12) #'binary-tree (diff 12))
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6 2)
+;; Search: (14 15 6 2)
+;; Search: (15 6 2 28 29)
+;; Search: (6 2 28 29 30 31)
+;; Search: (12 13 2 28 29 30 31)
+;;;; -> 12
+
+(best-first-search 1 (is 12) #'binary-tree (price-is-right 12))
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6 2)
+;; Search: (6 2 14 15)
+;; Search: (12 2 13 14 15)
+;;;; -> 12
+
+(beam-search 1 (is 12) #'binary-tree (price-is-right 12) 2)
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6)
+;; Search: (6 14)
+;; Search: (12 13)
+;;;; -> 12
+
+(beam-search 1 (is 12) #'binary-tree (diff 12) 2)
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6)
+;; Search: (14 15)
+;; Search: (15 28)
+;; Search: (28 30)
+;; Search: (30 56)
+;; Search: (56 60)
+;; Search: (60 112)
+;; Search: (112 120)
+;; Search: (120 224)
+;;;; -> [Abort]
+
+(trip (city 'san-francisco) (city 'boston))
+;; Search: ((SAN-FRANCISCO 122.26 37.47))
+;; Search: ((RENO 119.49 39.3))
+;; Search: ((GRAND-JCT 108.37 39.05))
+;; Search: ((DENVER 105.0 39.45))
+;; Search: ((KANSAS-CITY 94.35 39.06))
+;; Search: ((INDIANAPOLIS 86.1 39.46))
+;; Search: ((PITTSBURGH 79.57 40.27))
+;; Search: ((BOSTON 71.05 42.21))
+;;;; -> (BOSTON 71.05 42.21)
+
+(trip (city 'boston) (city 'san-francisco))
+;; Search: ((BOSTON 71.05 42.21))
+;; Search: ((PITTSBURGH
+ 79.57 40.27))
+;; Search: ((CHICAGO 87.37 41.5))
+;; Search: ((KANSAS-CITY 94.35 39.06))
+;; Search: ((DENVER 105.0 39.45))
+;; Search: ((FLAGSTAFF 111.41 35.13))
+;; Search: ((RENO 119.49 39.3))
+;; Search: ((SAN-FRANCISCO 122.26 37.47))
+;;;; -> (SAN-FRANCISCO 122.26 37.47)
+
+(show-city-path (trip (city 'san-francisco) (city 'boston) 1))
+;;;; -> #<Path 4514.8 km: San-Francisco - Reno - Grand-Jct - Denver - 
+          Kansas-City - Indianapolis - Pittsburgh - Boston>
+
+(show-city-path (trip (city 'boston) (city 'san-francisco) 1))
+;;;; -> #<Path 4577.3 km: Boston - Pittsburgh - Chicago - Kansas-City -
+          Denver - Grand-Jct - Reno - San-Francisco>
+
+(show-city-path (trip (city 'boston) (city 'san-francisco) 3))
+;;;; -> #<Path 4514.8 km: Boston - Pittsburgh - Indianapolis -
+          Kansas-City - Denver - Grand-Jct - Reno - San-Francisco>
+
+(iter-wide-search 1 (is 12) (finite-binary-tree 15) (diff 12)) 
+; Width: 1
+;; Search: (1)
+;; Search: (3)
+;; Search: (7)
+;; Search: (14)
+;; Search: NIL
+; Width: 2
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6)
+;; Search: (14 15)
+;; Search: (15)
+;; Search: NIL
+; Width: 3
+;; Search: (1)
+;; Search: (3 2)
+;; Search: (7 6 2)
+;; Search: (14 15 6)
+;; Search: (15 6)
+;; Search: (6)
+;; Search: (12 13)
+;;;; -> 12
+
+(tree-search '(1) (is 6) #'next2 #'prepend)
+;; Search: (1)
+;; Search: (2 3)
+;; Search: (3 3 4)
+;; Search: (3 4 4 5)
+;; Search: (4 4 5 4 5)
+;; Search: (4 5 4 5 5 6)
+;; Search: (5 4 5 5 6 5 6)
+;; Search: (4 5 5 6 5 6 6 7)
+;; Search: (5 5 6 5 6 6 7 5 6)
+;; Search: (5 6 5 6 6 7 5 6 6 7)
+;; Search: (6 5 6 6 7 5 6 6 7 6 7)
+;;;; -> 6
+
+(graph-search '(1) (is 6) #'next2 #'prepend)
+;; Search: (1)
+;; Search: (2 3)
+;; Search: (3 4)
+;; Search: (4 5)
+;; Search: (5 6)
+;; Search: (6 7)
+;;;; -> 6
+
+(path-states
+    (a*-search (list (make-path :state 1)) (is 6) 
+               #'next2 #'(lambda (x y) 1) (diff 6)))
+;; Search: (#<Path to 1 cost 0.0>)
+;; Search: (#<Path to 3 cost 4.0> #<Path to 2 cost 5.0>)
+;; Search: (#<Path to 5 cost 3.0> #<Path to 4 cost 4.0> 
+            #<Path to 2 cost 5.0>)
+;; Search: (#<Path to 6 cost 3.0> #<Path to 7 cost 4.0> 
+            #<Path to 4 cost 4.0> #<Path to 2 cost 5.0>)
+;;;; -> (6 5 3 1)
+
+
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/simple.lisp norvig-paip-pjb/simple.lisp
--- norvig/simple.lisp	1997-02-05 07:39:58.000000000 +0100
+++ norvig-paip-pjb/simple.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -2,6 +2,7 @@
 ;;; Code from Paradigms of Artificial Intelligence Programming
 ;;; Copyright (c) 1991 Peter Norvig
 
+
 (defun sentence ()    (append (noun-phrase) (verb-phrase)))
 (defun noun-phrase () (append (Article) (Noun)))
 (defun verb-phrase () (append (Verb) (noun-phrase)))
@@ -9,6 +10,7 @@
 (defun Noun ()        (one-of '(man ball woman table)))
 (defun Verb ()        (one-of '(hit took saw liked)))
 
+
 ;;; ==============================
 
 (defun one-of (set)
@@ -31,7 +33,7 @@
       (append (PP) (PP*))
       nil))
 
-;; (defun noun-phrase () (append (Article) (Adj*) (Noun) (PP*)))
+(defun noun-phrase () (append (Article) (Adj*) (Noun) (PP*)))
 (defun PP () (append (Prep) (noun-phrase)))
 (defun Adj () (one-of '(big little blue green adiabatic)))
 (defun Prep () (one-of '(to in by with on)))
@@ -65,6 +67,7 @@
   "Return a list of the possible rewrites for this category."
   (rule-rhs (assoc category *grammar*)))
 
+
 ;;; ==============================
 
 (defun generate (phrase)
@@ -92,7 +95,7 @@
     (Verb -> hit took saw liked)
     (Pronoun -> he she it these those that)))
 
-;; (setf *grammar* *bigger-grammar*)
+(setf *grammar* *bigger-grammar*)
 
 ;;; ==============================
 
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/SOURCE norvig-paip-pjb/SOURCE
--- norvig/SOURCE	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/SOURCE	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,2 @@
+unix.sri.com:pub/norvig/
+Peter Norvig
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/student.dat norvig-paip-pjb/student.dat
--- norvig/student.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/student.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,153 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(translate-to-expression '(if z is 3 |,| what is twice z))
+; Input: (If z is 3, what is twice z)
+; Rule: ((if ?x |,| ?y)       (?x ?y))
+; Binding: ((?x . (z is 3))  (?y . (what is twice z)))
+;  Input: (z is 3)
+;  Rule: ((?x is ?y)          (= ?x ?y))
+;  Result: (= z 3)
+;  Input: (what is twice z ?)
+;  Rule: ((?x is ?y)          (= ?x ?y))
+;  Binding: ((?x . what) (?y . (twice z)))
+;    Input: (twice z)
+;    Rule: ((twice ?x)         (* 2 ?x))
+;    Result: (* 2 z)
+;  Result: (= what (* 2 z))
+; Result: ((= z 3) (= what (* 2 z)))
+
+(solve-equations (translate-to-expression '(if z is 3 |,| what is twice z)))
+
+(trace isolate solve)
+;;;; -> (isolate solve)
+
+(solve-equations '((= (+ 3 4) (* (- 5 (+ 2 x)) 7))
+                   (= (+ (* 3 x) y) 12)))
+
+(solve-equations '( (= 0 (+ (* 2 x x) (8 x) 1))))
+
+
+; The equations to be solved are:
+;   (3 + 4) = ((5 - (2 + X)) * 7)
+;   ((3 * X) + Y) = 12
+; (1 ENTER SOLVE: ((= (+ 3 4) (* (- 5 (+ 2 X)) 7))
+;                 (= (+ (* 3 X) Y) 12)) NIL)
+;  (1 ENTER ISOLATE: (= (+ 3 4) (* (- 5 (+ 2 X)) 7)) X)
+;    (2 ENTER ISOLATE: (= (* (- 5 (+ 2 X)) 7) (+ 3 4)) X)
+;      (3 ENTER ISOLATE: (= (- 5 (+ 2 X)) (/ (+ 3 4) 7)) X)
+;        (4 ENTER ISOLATE: (= (+ 2 X) (- 5 (/ (+ 3 4) 7))) X)
+;          (5 ENTER ISOLATE: (= X (- (- 5 (/ (+ 3 4) 7)) 2)) X)
+;          (5 EXIT ISOLATE: (= X (- (- 5 (/ (+ 3 4) 7)) 2)))
+;        (4 EXIT ISOLATE: (= X (- (- 5 (/ (+ 3 4) 7)) 2)))
+;      (3 EXIT ISOLATE: (= X (- (- 5 (/ (+ 3 4) 7)) 2)))
+;    (2 EXIT ISOLATE: (= X (- (- 5 (/ (+ 3 4) 7)) 2)))
+;  (1 EXIT ISOLATE: (= X (- (- 5 (/ (+ 3 4) 7)) 2)))
+;  (2 ENTER SOLVE: ((= (+ (* 3 2) Y) 12)) ((= X 2)))
+;    (1 ENTER ISOLATE: (= (+ (* 3 2) Y) 12) Y)
+;      (2 ENTER ISOLATE: (= Y (- 12 (* 3 2))) Y)
+;      (2 EXIT ISOLATE: (= Y (- 12 (* 3 2))))
+;    (1 EXIT ISOLATE: (= Y (- 12 (* 3 2))))
+;    (3 ENTER SOLVE: NIL ((= Y 6) (= X 2)))
+;    (3 EXIT SOLVE: ((= Y 6) (= X 2)))
+;  (2 EXIT SOLVE: ((= Y 6) (= X 2)))
+; (1 EXIT SOLVE: ((= Y 6) (= X 2)))
+; The solution is:
+;   Y = 6
+;   X = 2
+; -> NIL
+
+(student '(If the number of customers Tom gets is twice the square of
+           20 % of the number of advertisements he runs |,| 
+           and the number of advertisements is 45 |,|
+           then what is the number of customers Tom gets ?))
+; The equations to be solved are:
+;   CUSTOMERS = (2 * (((20 / 100) * ADVERTISEMENTS) * 
+;                     ((20 / 100) * ADVERTISEMENTS)))
+;   ADVERTISEMENTS = 45
+;   WHAT = CUSTOMERS
+; 
+; The solution is:
+;   WHAT = 162
+;   CUSTOMERS = 162
+;   ADVERTISEMENTS = 45
+; -> NIL
+(with-input-from-string
+ (input
+  "The daily cost of living for a group is the overhead cost plus 
+   the running cost for each person times the number of people in 
+   the group.  This cost for one group equals $100,
+   and the number of people in the group is 40.
+   If the overhead cost is 10 times the running cost,
+   find the overhead and running cost for each person.")
+ (loop for word = (read input nil :eof nil)
+       until (eq word :eof)
+       collect word into text
+       finally return text))
+
+
+(student '(The capitain |'| s age is half the capitain |'| s height measured in centimeters. The capitain |'| s height is twice his height when he was twice younger. What |'| s the capitain |'| s age ?))
+
+(student '(The daily cost of living for a group is the overhead cost plus 
+           the running cost for each person times the number of people in 
+           the group |.|  This cost for one group equals $ 100 |,|
+           and the number of people in the group is 40 |.|
+           If the overhead cost is 10 times the running cost |,|
+           find the overhead and running cost for each person |.|))
+; The equations to be solved are:
+;   DAILY = (OVERHEAD + (RUNNING * PEOPLE))
+;   COST = 100
+;   PEOPLE = 40
+;   OVERHEAD = (10 * RUNNING)
+;   TO-FIND-1 = OVERHEAD
+;   TO-FIND-2 = RUNNING
+; 
+; The solution is:
+;   PEOPLE = 40
+;   COST = 100
+; -> NIL
+
+(student '(Fran's age divided by Robin's height is one half Kelly's IQ |.|
+           Kelly's IQ minus 80 is Robin's height |.|
+           If Robin is 4 feet tall |,| how old is Fran ?))
+; The equations to be solved are:
+;   (FRAN / ROBIN) = (KELLY / 2)
+;   (KELLY - 80) = ROBIN
+;   ROBIN = 4
+;   HOW = FRAN
+; 
+; The solution is:
+;   HOW = 168
+;   FRAN = 168
+;   KELLY = 84
+;   ROBIN = 4
+; -> NIL
+
+(student '(Fran's age divided by Robin's height is one half Kelly's IQ |.|
+           Kelly's IQ minus 80 is Robin's height |.|
+           If Robin is 0 feet tall |,| how old is Fran ?))
+; The equations to be solved are:
+;   (FRAN / ROBIN) = (KELLY / 2)
+;   (KELLY - 80) = ROBIN
+;   ROBIN = 0
+;   HOW = FRAN
+; 
+; The solution is:
+;   HOW = 0
+;   FRAN = 0
+;   KELLY = 80
+;   ROBIN = 0
+; -> NIL
+
+(student '(Fran's age times Robin's height is one half Kelly's IQ |.|
+	   Kelly's IQ minus 80 is Robin's height |.|
+	   If Robin is 0 feet tall |,| how old is Fran ?))
+; The equations to be solved are:
+;   (FRAN * ROBIN) = (KELLY / 2)
+;   (KELLY - 80) = ROBIN
+;   ROBIN = 0
+;   HOW = FRAN
+; 
+; >>Error: There was an attempt to divide a number by zero
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/student.lisp norvig-paip-pjb/student.lisp
--- norvig/student.lisp	1997-02-05 07:39:58.000000000 +0100
+++ norvig-paip-pjb/student.lisp	2006-05-03 21:28:41.000000000 +0200
@@ -34,8 +34,8 @@
     ((?x* is ?y*)           (= ?x ?y))
     ((?x* - ?y*)            (- ?x ?y))
     ((?x* minus ?y*)        (- ?x ?y))
-    ((difference between ?x* and ?y*)  (- ?y ?x))
-    ((difference ?x* and ?y*)          (- ?y ?x))
+    ((difference between ?x* and ?y*)  (- ?x ?y))
+    ((difference ?x* and ?y*)          (- ?x ?y))
     ((?x* + ?y*)            (+ ?x ?y))
     ((?x* plus ?y*)         (+ ?x ?y))
     ((sum ?x* and ?y*)      (+ ?x ?y))
@@ -51,19 +51,33 @@
     ((square ?x*)           (* ?x ?x))
     ((?x* % less than ?y*)  (* ?y (/ (- 100 ?x) 100)))
     ((?x* % more than ?y*)  (* ?y (/ (+ 100 ?x) 100)))
-    ((?x* % ?y*)            (* (/ ?x 100) ?y)))))
+    ((?x* % ?y*)            (* (/ ?x 100) ?y))
+    )))
+
+(defun clean-equations (equations)
+  (mapcar (lambda (equation)
+            (mapcar (lambda (item)
+                      (if (and (consp item)
+                               (consp (first item)) 
+                               (null (rest item)))
+                          (first item)
+                          item))
+                    equation))
+          equations))
+                        
 
 (defun student (words)
   "Solve certain Algebra Word Problems."
   (solve-equations 
+   (clean-equations
     (create-list-of-equations
-      (translate-to-expression (remove-if #'noise-word-p words)))))
+      (translate-to-expression (remove-if #'noise-word-p words))))))
 
 (defun translate-to-expression (words)
   "Translate an English phrase into an equation or expression."
   (or (rule-based-translator
         words *student-rules*
-        :rule-if #'rule-pattern :rule-then #'rule-response
+        :rule-if #'rule-pattern :rule-then #'rule-responses
         :action #'(lambda (bindings response)
                     (sublis (mapcar #'translate-pair bindings)
                               response)))
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/syntax1.dat norvig-paip-pjb/syntax1.dat
--- norvig/syntax1.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/syntax1.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,75 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+;;;; Examples for syntax1.lisp
+
+(use *grammar3*)
+;;;; -> 15
+
+(parser '(the table))
+;;;; -> ((NP (ART THE) (NOUN TABLE)))
+
+(parser '(the ball hit the table))
+;;;; -> ((SENTENCE (NP (ART THE) (NOUN BALL))
+;;;;               (VP (VERB HIT)
+;;;;                   (NP (ART THE) (NOUN TABLE)))))
+
+(parser '(the noun took the verb))
+;;;; -> ((SENTENCE (NP (ART THE) (NOUN NOUN))
+;;;;               (VP (VERB TOOK)
+;;;;                   (NP (ART THE) (NOUN VERB)))))
+
+
+(use *grammar4*)
+;;;; -> 54
+
+(parser '(The man hit the table with the ball))
+;;;; -> ((S (NP (D THE) (N MAN))
+;;;;        (VP (VP (V HIT) (NP (D THE) (N TABLE)))
+;;;;        (PP (P WITH) (NP (D THE) (N BALL)))))
+;;;;     (S (NP (D THE) (N MAN))
+;;;;        (VP (V HIT)
+;;;;            (NP (NP (D THE) (N TABLE))
+;;;;                (PP (P WITH) (NP (D THE) (N BALL)))))))
+
+(parser '(the orange saw))
+;;;; -> ((S (NP (D THE) (N ORANGE)) (VP (V SAW)))
+;;;;     (NP (D THE) (A+ (A ORANGE)) (N SAW)))
+
+(setf s '(THE PERSPICUOUS BIG GREEN BALL BY A BLUE WOMAN WITH A BIG MAN 
+          HIT A TABLE BY THE SAW BY THE GREEN ORANGE))
+
+(time (length (parser s)))
+;;;; Evaluation of (LENGTH (PARSER S 'S)) took .13 Seconds of elapsed time.
+;;;; -> 10
+
+(parser '(John liked Mary))
+;;;; -> ((S (NP (NAME JOHN))
+;;;;        (VP (V LIKED) (NP (NAME MARY)))))
+
+(parser '(Dana liked Dale))
+;;;; -> ((S (NP (NAME DANA))
+;;;;        (VP (V LIKED) (NP (NAME DALE)))))
+
+(parser '(the rab zaggled the woogly quax))
+;;;; -> ((S (NP (D THE) (N RAB))
+;;;;        (VP (V ZAGGLED) (NP (D THE) (A+ (A WOOGLY)) (N QUAX)))))
+
+(parser '(the slithy toves gymbled))
+;;;; -> ((S (NP (D THE) (N SLITHY)) (VP (V TOVES) (NP (NAME GYMBLED))))
+;;;;     (S (NP (D THE) (A+ (A SLITHY)) (N TOVES)) (VP (V GYMBLED)))
+;;;;     (NP (D THE) (A+ (A SLITHY) (A+ (A TOVES))) (N GYMBLED)))
+
+(parser '(the slithy toves gymbled on the wabe))
+;;;; -> ((S (NP (D THE) (N SLITHY))
+;;;;        (VP (VP (V TOVES) (NP (NAME GYMBLED)))
+;;;;              (PP (P ON) (NP (D THE) (N WABE)))))
+;;;;     (S (NP (D THE) (N SLITHY))
+;;;;        (VP (V TOVES) (NP (NP (NAME GYMBLED))
+;;;;                          (PP (P ON) (NP (D THE) (N WABE))))))
+;;;;     (S (NP (D THE) (A+ (A SLITHY)) (N TOVES))
+;;;;        (VP (VP (V GYMBLED)) (PP (P ON) (NP (D THE) (N WABE)))))
+;;;;     (NP (NP (D THE) (A+ (A SLITHY) (A+ (A TOVES))) (N GYMBLED))
+;;;;         (PP (P ON) (NP (D THE) (N WABE)))))
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/syntax2.dat norvig-paip-pjb/syntax2.dat
--- norvig/syntax2.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/syntax2.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,36 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(use *grammar5*)
+;;;; -> 17
+
+(meanings '(1 to 5 without 3))
+;;;; -> ((1 2 4 5))
+
+(meanings '(1 to 4 and 7 to 9))
+;;;; -> ((1 2 3 4 7 8 9))
+
+(meanings '(1 to 6 without 3 and 4))
+;;;; -> ((1 2 4 5 6) (1 2 5 6))
+
+
+(use *grammar6*)
+;;;; -> 18
+
+(meanings '(1 to 6 without 3 and 4))
+;;;; -> ((1 2 5 6))
+
+(meanings '(1 and 3 to 7 and 9 without 5 and 6))
+;;;; -> ((1 3 4 7 9))
+
+(meanings '(1 and 3 to 7 and 9 without 5 and 2))
+;;;; -> ((1 3 4 6 7 9 2))
+
+(meanings '(1 9 8 to 2 0 1))
+;;;; -> ((198 199 200 201))
+
+(meanings '(1 2 3))
+;;;; -> (123 (123))
+
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/syntax2.lisp norvig-paip-pjb/syntax2.lisp
--- norvig/syntax2.lisp	1997-02-05 07:39:58.000000000 +0100
+++ norvig-paip-pjb/syntax2.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -116,29 +116,19 @@
     (NP -> (N P N)      infix-funcall)
     (N ->  (DIGIT)      identity)
     (P ->  to           integers)
-    (CONJ -> and        ordered-union)
-    (CONJ -> without    ordered-set-difference)
+    (CONJ -> and        union)
+    (CONJ -> without    set-difference)
     (N -> 1 1) (N -> 2 2) (N -> 3 3) (N -> 4 4) (N -> 5 5)
     (N -> 6 6) (N -> 7 7) (N -> 8 8) (N -> 9 9) (N -> 0 0)))
 
-(defun infix-funcall (arg1 function arg2)
-  "Apply the function to the two arguments"
-  (funcall function arg1 arg2))
-
 (defun integers (start end)
   "A list of all the integers in the range [start...end] inclusive."
   (if (> start end) nil
       (cons start (integers (+ start 1) end))))
 
-(defun ordered-union (a b)
-  "Add elements of B to A, but preserve order of A (and B)."
-  ;; Added by norvig Jun 11 96; some Lisps don't preserve order
- (append a (ordered-set-difference b a)))
-
-(defun ordered-set-difference (a b)
-  "Subtact elements of B from A, but preserve order of A."
-  ;; Added by norvig Jun 11 96; some Lisps don't preserve order
-  (remove-if #'(lambda (x) (member x b)) a))
+(defun infix-funcall (arg1 function arg2)
+  "Apply the function to the two arguments"
+  (funcall function arg1 arg2))
 
 
 (defparameter *grammar6*
@@ -156,7 +146,5 @@
     (DIGIT -> 0 0)))
 
 (defun union* (x y) (if (null (intersection x y)) (append x y)))
-(defun set-diff (x y) (if (subsetp y x) (ordered-set-difference x y)))
+(defun set-diff (x y) (if (subsetp y x) (set-difference x y)))
 (defun 10*N+D (N D) (+ (* 10 N) D))
-
-
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/syntax3.dat norvig-paip-pjb/syntax3.dat
--- norvig/syntax3.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/syntax3.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,81 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+(use *grammar7*)
+26
+
+(all-parses '(1 to 6 without 3 and 4))
+Score  Semantics         (1 TO 6 WITHOUT 3 AND 4)
+=====  =========         ============================
+  0.3  (1 2 5 6)         ((1 TO 6) WITHOUT (3 AND 4))
+ -0.7  (1 2 4 5 6 4)     (((1 TO 6) WITHOUT 3) AND 4)
+
+(all-parses '(1 and 3 to 7 and 9 without 5 and 6))
+Score  Semantics         (1 AND 3 TO 7 AND 9 WITHOUT 5 AND 6)
+=====  =========         ============================
+  0.2  (1 3 4 7 9)       (1 AND (((3 TO 7) AND 9) WITHOUT (5 AND 6)))
+  0.1  (1 3 4 7 9)       (((1 AND (3 TO 7)) AND 9) WITHOUT (5 AND 6))
+  0.1  (1 3 4 7 9)       ((1 AND ((3 TO 7) AND 9)) WITHOUT (5 AND 6))
+ -0.8  (1 3 4 6 7 9 6)   ((1 AND (((3 TO 7) AND 9) WITHOUT 5)) AND 6)
+ -0.8  (1 3 4 6 7 9 6)   (1 AND ((((3 TO 7) AND 9) WITHOUT 5) AND 6))
+ -0.9  (1 3 4 6 7 9 6)   ((((1 AND (3 TO 7)) AND 9) WITHOUT 5) AND 6)
+ -0.9  (1 3 4 6 7 9 6)   (((1 AND ((3 TO 7) AND 9)) WITHOUT 5) AND 6)
+ -2.0  (1 3 4 5 6 7 9)   ((1 AND (3 TO 7)) AND (9 WITHOUT (5 AND 6)))
+ -2.0  (1 3 4 5 6 7 9)   (1 AND ((3 TO 7) AND (9 WITHOUT (5 AND 6))))
+ -3.0  (1 3 4 5 6 7 9 6) (((1 AND (3 TO 7)) AND (9 WITHOUT 5)) AND 6)
+ -3.0  (1 3 4 5 6 7 9 6) ((1 AND (3 TO 7)) AND ((9 WITHOUT 5) AND 6))
+ -3.0  (1 3 4 5 6 7 9 6) ((1 AND ((3 TO 7) AND (9 WITHOUT 5))) AND 6)
+ -3.0  (1 3 4 5 6 7 9 6) (1 AND (((3 TO 7) AND (9 WITHOUT 5)) AND 6))
+ -3.0  (1 3 4 5 6 7 9 6) (1 AND ((3 TO 7) AND ((9 WITHOUT 5) AND 6)))
+
+(all-parses '(1 and 3 to 7 and 9 without 5 and 2))
+Score  Semantics         (1 AND 3 TO 7 AND 9 WITHOUT 5 AND 2)
+=====  =========         ============================
+  0.2  (1 3 4 6 7 9 2)   ((1 AND (((3 TO 7) AND 9) WITHOUT 5)) AND 2)
+  0.2  (1 3 4 6 7 9 2)   (1 AND ((((3 TO 7) AND 9) WITHOUT 5) AND 2))
+  0.1  (1 3 4 6 7 9 2)   ((((1 AND (3 TO 7)) AND 9) WITHOUT 5) AND 2)
+  0.1  (1 3 4 6 7 9 2)   (((1 AND ((3 TO 7) AND 9)) WITHOUT 5) AND 2)
+ -2.0  (1 3 4 5 6 7 9 2) (((1 AND (3 TO 7)) AND (9 WITHOUT 5)) AND 2)
+ -2.0  (1 3 4 5 6 7 9 2) ((1 AND (3 TO 7)) AND ((9 WITHOUT 5) AND 2))
+ -2.0  (1 3 4 5 6 7 9)   ((1 AND (3 TO 7)) AND (9 WITHOUT (5 AND 2)))
+ -2.0  (1 3 4 5 6 7 9 2) ((1 AND ((3 TO 7) AND (9 WITHOUT 5))) AND 2)
+ -2.0  (1 3 4 5 6 7 9 2) (1 AND (((3 TO 7) AND (9 WITHOUT 5)) AND 2))
+ -2.0  (1 3 4 5 6 7 9 2) (1 AND ((3 TO 7) AND ((9 WITHOUT 5) AND 2)))
+ -2.0  (1 3 4 5 6 7 9)   (1 AND ((3 TO 7) AND (9 WITHOUT (5 AND 2))))
+ -2.8  (1 3 4 6 7 9)     (1 AND (((3 TO 7) AND 9) WITHOUT (5 AND 2)))
+ -2.9  (1 3 4 6 7 9)     (((1 AND (3 TO 7)) AND 9) WITHOUT (5 AND 2))
+ -2.9  (1 3 4 6 7 9)     ((1 AND ((3 TO 7) AND 9)) WITHOUT (5 AND 2))
+
+(meaning '(1 to 5 without 3 and 4))
+(1 2 5)
+
+(meaning '(1 to 5 without 3 and 6))
+(1 2 4 5 6)
+
+(meaning '(1 to 5 without 3 and 6 shuffled))
+(6 4 1 2 5)
+
+(meaning '([ 1 to 5 without [ 3 and 6 ] ] reversed))
+(5 4 2 1)
+
+(meaning '(1 to 5 to 9))
+Sorry, I didn't understand that.
+NIL
+
+(meaning '(1 to 5 without 3 and 7 repeat 2))
+Please pick one:
+  1: (1 2 4 5 7 1 2 4 5 7)
+  2: (1 2 4 5 7 7)
+Your choice? 1
+(1 2 4 5 7 1 2 4 5 7)
+
+(all-parses '(1 to 5 without 3 and 7 repeat 2))
+Score  Semantics              (1 TO 5 WITHOUT 3 AND 7 REPEAT 2)
+=====  =========              ============================
+  0.3  (1 2 4 5 7 1 2 4 5 7)  ((((1 TO 5) WITHOUT 3) AND 7) REPEAT 2)
+  0.3  (1 2 4 5 7 7)          (((1 TO 5) WITHOUT 3) AND (7 REPEAT 2))
+ -2.7  (1 2 4 5 1 2 4 5)      (((1 TO 5) WITHOUT (3 AND 7)) REPEAT 2)
+ -2.7  (1 2 4 5)              ((1 TO 5) WITHOUT ((3 AND 7) REPEAT 2))
+ -2.7  (1 2 4 5)              ((1 TO 5) WITHOUT (3 AND (7 REPEAT 2)))
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/syntax3.lisp norvig-paip-pjb/syntax3.lisp
--- norvig/syntax3.lisp	1997-02-05 07:39:59.000000000 +0100
+++ norvig-paip-pjb/syntax3.lisp	2003-12-29 22:41:52.000000000 +0100
@@ -171,7 +171,7 @@
 
 ;;;; Grammar
 
-(defparameter *grammar7*
+(defvar *grammar7*
   '((NP -> (NP CONJ NP) infix-funcall  infix-scorer)
     (NP -> (N P N)      infix-funcall  infix-scorer)
     (NP -> (N)          list)
@@ -185,7 +185,7 @@
     (]  -> ]            ])
     (OP -> repeat       repeat)
     (CONJ -> and        append         prefer-disjoint)
-    (CONJ -> without    ordered-set-difference prefer-subset)
+    (CONJ -> without    set-difference prefer-subset)
     (ADJ -> reversed    reverse        inv-span)
     (ADJ -> shuffled    permute        prefer-not-singleton)
     (D -> 1 1) (D -> 2 2) (D -> 3 3) (D -> 4 4) (D -> 5 5)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/tutor.lisp norvig-paip-pjb/tutor.lisp
--- norvig/tutor.lisp	2002-04-10 01:48:26.000000000 +0200
+++ norvig-paip-pjb/tutor.lisp	1970-01-01 01:00:00.000000000 +0100
@@ -1,179 +0,0 @@
-;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
-;;; Code for Paradigms of AI Programming
-;;; Copyright (c) 1996 Peter Norvig
-
-;;;; PAIP TUTOR
-
-(requires "auxfns")
-
-(defvar *chapters* '() "List of chapter structures, one per chapter.")
-
-(defun do-examples (chapters &optional (stream *standard-output*))
-  "Run examples from one or more chapters and sum the number of errors.  
-  If all is well, this should return 0. If STREAM is nil, very little 
-  output is produced."
-  (loop for chapter in (cond ((member chapters '(all :all)) *chapters*)
-			     ((listp chapters) chapters)
-			     (t (list chapters)))
-	sum (do-chapter chapter stream)))
-
-(defmacro defexamples (chapter-number title &rest examples)
-  "Define a set of test examples.  Each example is of the form 
-     (exp [ => result ] [ @ page ] [ :input string ]) 
-  where [] indicates an optional part, and the parts can be in any order.
-  Evaluate exp and complain if it is not equal to result.  The page is
-  the page in the book where the example appears.  An 'example' may also be
-  one of the following:
-     string                   Serves as documentation
-     (:SECTION string)        Says what section of book we're in"
-  `(add-chapter ',chapter-number ',title ',examples))
-
-(defun do-chapter (chapter interface)
-  "Run the examples in a chapter.  Return the number of unexpected results."
-  (let ((chapter (find-chapter chapter)))
-    (set-chapter chapter interface)
-    (let ((n (count-if-not 
-	      #'(lambda (example)
-		  (do-example example interface))
-	      (chapter-examples chapter))))
-      (if (> n 0)
-	  (format t "~%**** ~D unexpected result~:p on Chapter ~D"
-		  n chapter)
-	(format t "~%Chapter ~D done.~%" chapter))
-      n)))
-
-(defstruct (chapter (:print-function 
-		(lambda (chapter stream depth)
-		  (declare (ignore depth))
-		  (format stream "~2D. ~A" (chapter-number chapter)
-			  (chapter-title chapter)))))
-  number title examples)
-
-(defun add-chapter (number title examples)
-  "The functional interface for defexamples: adds test examples."
-  (let ((chapter (make-chapter :number number :title title 
-			       :examples examples)))
-    (setf *chapters* 
-	  (sort 
-	   (cons chapter (delete number *chapters* :key #'chapter-number))
-	   #'< :key #'chapter-number))
-    chapter))
-
-(defun find-chapter (number)
-  "Given a chapter number, find the chapter structure for it."
-  (typecase number
-    (chapter number) ; If given a chapter, just return it.
-    (t (find number *chapters* :key #'chapter-number))))
-
-(defun do-example (example interface)
-  "Run an example; print out what's happening unless INTERFACE is nil.
-  Return nil if there is a unexpected result."
-  (let* ((stream (output-stream interface))
-	 (*print-pretty* t)
-         (*standard-output* stream)
-         (*trace-output* stream)
-	 (*debug-io* stream)
-	 (expected ':anything)
-	 (result nil))
-    (cond ((stringp example)
-	   (when stream
-	     (format stream "~A~%" example)))
-	  ((starts-with example ':section)
-	   (display-section (second example) interface))
-	  ((consp example)
-	   (let ((exp (copy-tree (first example))) ;; To avoid NCONC problems
-		 (page (getf (rest example) '@))
-		 (input (getf (rest example) ':input)))
-	     (setf result nil)
-	     (setf expected (getf (rest example) '=> ':anything))
-	     (set-example example interface)
-             (when page
-               (set-page page interface))
-	     (when stream
-	       (let ((*print-case* ':downcase))
-		 (display-example exp interface)))
-	     (if input
-		 (with-input-from-string (*standard-input* input)
-		   (setf result (eval exp)))
-	         (setf result (eval exp)))
-	     (when stream
-	       (format stream "~&~S~%" result))
-	     (unless (or (equal expected ':anything) 
-                         (nearly-equal result expected))
-	       (if stream 
-		   (format *terminal-io*
-			   "~%**** expected ~S" expected)
-		   (format *terminal-io*
-			   "~%**** For ~S~%     expected ~S~%      got:~S~%"
-			   exp expected result)))))
-	  ((atom example) (cerror "Bad example: ~A" example example)))
-    ;; Return nil if there is a unexpected result:
-    (or (eql expected ':anything) (nearly-equal result expected))))
-
-(defun do-documentation-examples (examples interface)
-  "Go through any documentation strings or (:SECTION ...) examples."
-  (loop (let ((one (pop examples)))
-	  (cond ((or (stringp one) (starts-with one ':section))
-		 (do-example one interface))
-		(t (RETURN)))))
-  examples)
-
-(defun nearly-equal (x y)
-  "Are two objects nearly equal?  Like equal, except floating point numbers
-  need only be within epsilon of each other."
-  (let ((epsilon 0.001)) ;; could be more mathematically sophisticated
-    (typecase x
-      (FLOAT (and (floatp y) (< (abs (- x y)) epsilon)))
-      (VECTOR (and (vectorp y) (eql (length x) (length y))
-		   (nearly-equal (coerce x 'list) (coerce y 'list))))
-      (CONS (and (consp y) 
-		 (nearly-equal (car x) (car y)) 
-		 (nearly-equal (cdr x) (cdr y))))
-      (T (equal x y)))))
-
-;;;; GUI Implementation
-
-;;; We started to implement guis in UNUSED/gui-*
-
-;;; If you want to write a GUI for the tutor, you need to do four things:
-
-;;; (1) Define a class (or structure) which we call an interface -- it
-;;; is the window in which the examples will be displayed.  
-
-;;; (2) Define the function PAIP-TUTOR which should start up the interface.
-
-;;; (3) Implement the following six methods on your interface:
-;;; SET-CHAPTER, SET-PAGE, SET-EXAMPLE, 
-;;; DISPLAY-EXAMPLE, DISPLAY-SECTION, OUTPUT-STREAM
-
-;;; (4) Edit the file "auxfns.lisp" to include your files.
-
-;;; Below we show an implementation for the five methods that is good
-;;; for output streams (without any fancy window GUI).  
-
-
-(defmethod set-chapter (chapter interface)
-  ;; Update the interface to display this chapter
-  (format (output-stream interface) "~2&Chapter ~A~%" chapter))
-
-(defmethod set-page (page interface)
-  ;; Update the interface to display the page number
-  (format (output-stream interface) "~&; page ~D" page))
-
-(defmethod set-example (example interface)
-  ;; Update the interface to display this example. The idea is that
-  ;; this shows the example in a popup menu or something, but does not
-  ;; dsiplay it in the output stream.
-  (declare (ignore example interface)))
-
-(defmethod display-example (exp interface)
-  ;; Display a prompt and the expression on the interface's output stream
-  (format (output-stream interface) "~&> ~S~%" exp))
-
-(defmethod display-section (section interface)
-  ;; Display the string describing this section somewhere
-  (format (output-stream interface) "~2&Section ~A~%" section))
-
-(defmethod output-stream (interface)
-  ;; The stream on which output will be printed
-  interface)
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/unifgram.dat norvig-paip-pjb/unifgram.dat
--- norvig/unifgram.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/unifgram.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,275 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+;;; begin grammar snippet
+
+(rule (S (?pred ?subj)) -->
+  (NP ?agr ?subj)
+  (VP ?agr ?pred))
+
+(rule (NP ?agr (?det ?n)) -->
+  (Det ?agr ?det)
+  (N ?agr ?n))
+
+(rule (NP 3sg (the male))          --> (:word he))
+(rule (NP ~3sg (some objects))     --> (:word they))
+(rule (VP 3sg sleep)               --> (:word sleeps))
+(rule (VP ~3sg sleep)              --> (:word sleep))
+(rule (Det ?any the)               --> (:word the))
+(rule (N 3sg (young male human))   --> (:word boy))
+(rule (N 3sg (young female human)) --> (:word girl))
+
+;;; end grammar snippet
+
+;;; begin grammar snippet
+
+(rule (S ?pred) -->
+  (NP ?agr ?subj)
+  (VP ?agr ?subj ?pred))
+
+(rule (VP ?agr ?subj ?pred) -->
+  (Verb/tr ?agr ?subj ?pred ?obj)
+  (NP ?any-agr ?obj))
+
+(rule (VP ?agr ?subj ?pred) -->
+  (Verb/intr ?agr ?subj ?pred))
+
+(rule (Verb/tr ~3sg ?x (kiss ?x ?y) ?y) --> (:word kiss))
+(rule (Verb/tr 3sg ?x (kiss ?x ?y) ?y) --> (:word kisses))
+(rule (Verb/tr ?any  ?x (kiss ?x ?y) ?y) --> (:word kissed))
+
+(rule (Verb/intr ~3sg ?x (sleep ?x)) --> (:word sleep))
+(rule (Verb/intr 3sg ?x (sleep ?x)) --> (:word sleeps))
+(rule (Verb/intr ?any  ?x (sleep ?x)) --> (:word slept))
+
+(rule (NP ?agr ?sem) -->
+  (Name ?agr ?sem))
+
+(rule (NP ?agr (?det-sem ?noun-sem)) -->
+  (Det ?agr ?det-sem)
+  (Noun ?agr ?noun-sem))
+
+(rule (Name 3sg Terry) --> (:word Terry))
+(rule (Name 3sg Jean)  --> (:word Jean))
+
+(rule (Noun 3sg (young male human))           --> (:word boy))
+(rule (Noun 3sg (young female human))         --> (:word girl))
+(rule (Noun ~3sg (group (young male human)))   --> (:word boys))
+(rule (Noun ~3sg (group (young female human))) --> (:word girls))
+
+(rule (Det ?any the)  --> (:word the))
+(rule (Det 3sg a) --> (:word a))
+
+;;; end grammar snippet
+
+;;; begin examples for last snippet
+
+> (?- (S ?sem (The boys kiss a girl) ()))
+?SEM = (KISS (THE (GROUP (YOUNG MALE HUMAN)))
+             (A (YOUNG FEMALE HUMAN))).
+
+> (?- (S ?sem (The girls kissed the girls) ()))
+?SEM = (KISS (THE (GROUP (YOUNG FEMALE HUMAN)))
+             (THE (GROUP (YOUNG FEMALE HUMAN)))).
+
+> (?- (S ?sem (Terry kissed the girl) ()))
+?SEM = (KISS TERRY (THE (YOUNG FEMALE HUMAN))).
+
+> (?- (S ?sem (The girls kisses the boys) ()))
+No.
+
+> (?- (S ?sem (Terry kissed a girls) ()))
+No.
+
+> (?- (S ?sem (Terry sleeps Jean) ()))
+No.
+
+;;; end examples
+
+;;; begin grammar snippet
+
+(rule (Det ?any ?x ?p ?q (the ?x (and ?p ?q)))    --> (:word the))
+(rule (Det 3sg  ?x ?p ?q (exists ?x (and ?p ?q))) --> (:word a))
+(rule (Det 3sg  ?x ?p ?q (all    ?x (-> ?p ?q)))  --> (:word every))
+
+(rule (Noun 3sg ?x (picture ?x)) --> (:word picture))
+(rule (Noun 3sg ?x (story ?x)) --> (:word story))
+(rule (Noun 3sg ?x (and (young ?x) (male ?x) (human ?x))) -->
+  (:word boy))
+
+(rule (NP ?agr ?x ?pred ?pred) -->
+  (Name ?agr ?name))
+
+;(rule (NP ?agr ?x ?pred ?np) -->
+;  (Det ?agr ?x ?noun ?pred ?np)
+;  (Noun ?agr ?x ?noun))
+
+(rule (NP ?agr ?x ?pred ?np) -->
+  (Det ?agr ?x ?noun&rel ?pred ?np)
+  (Noun ?agr ?x ?noun)
+  (rel-clause ?agr ?x ?noun ?noun&rel))
+
+(rule (rel-clause ?agr ?x ?np ?np) --> )
+(rule (rel-clause ?agr ?x ?np (and ?np ?rel)) -->
+  (:word that)
+  (VP ?agr ?x ?rel))
+
+(rule (Verb/tr ~3sg ?x ?y (paint ?x ?y)) --> (:word paint))
+(rule (Verb/tr 3sg  ?x ?y (paint ?x ?y)) --> (:word paints))
+(rule (Verb/tr ?any ?x ?y (paint ?x ?y)) --> (:word painted))
+
+(rule (Verb/intr ~3sg ?x (sleep ?x)) --> (:word sleep))
+(rule (Verb/intr 3sg  ?x (sleep ?x)) --> (:word sleeps))
+(rule (Verb/intr ?any ?x (sleep ?x)) --> (:word slept))
+
+(rule (Verb/intr 3sg  ?x (sells ?x)) --> (:word sells))
+(rule (Verb/intr 3sg  ?x (stinks ?x)) --> (:word stinks))
+
+(rule (VP ?agr ?x ?vp) -->
+  (Verb/tr ?agr ?x ?obj ?verb)
+  (NP ?any-agr ?obj ?verb ?vp))
+
+(rule (VP ?agr ?x ?vp) -->
+  (Verb/intr ?agr ?x ?vp))
+
+(rule (S ?np) -->
+  (NP ?agr ?x ?vp ?np)
+  (VP ?agr ?x ?vp))
+
+;;; end grammar snippet
+
+;;; begin examples for last snippet
+
+Every picture paints a story.
+(ALL ?3 (-> (PICTURE ?3)
+            (EXISTS ?14 (AND (STORY ?14) (PAINT ?3 ?14)))))
+
+Every boy that paints a picture sleeps.
+(ALL ?3 (-> (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))
+                 (EXISTS ?19 (AND (PICTURE ?19)
+                                  (PAINT ?3 ?19))))
+            (SLEEP ?3)))
+
+Every boy that sleeps paints a picture.
+(ALL ?3 (-> (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))
+                 (SLEEP ?3))
+            (EXISTS ?22 (AND (PICTURE ?22) (PAINT ?3 ?22)))))
+
+Every boy that paints a picture that sells 
+paints a picture that stinks.
+(ALL ?3 (-> (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))
+                 (EXISTS ?19 (AND (AND (PICTURE ?19) (SELLS ?19))
+                                  (PAINT ?3 ?19))))
+            (EXISTS ?39 (AND (AND (PICTURE ?39) (STINKS ?39))
+                             (PAINT ?3 ?39)))))
+
+;;; end examples
+
+;;; begin grammar snippet
+
+(rule (S (and ?np ?vp)) -->
+  (NP ?agr ?x ?np)
+  (VP ?agr ?x ?vp))
+
+(rule (VP ?agr ?x (and ?verb ?obj)) -->
+  (Verb/tr ?agr ?x ?o ?verb)
+  (NP ?any-agr ?o ?obj))
+
+(rule (VP ?agr ?x ?verb) -->
+  (Verb/intr ?agr ?x ?verb))
+
+(rule (NP ?agr ?name t) -->
+  (Name ?agr ?name))
+
+(rule (NP ?agr ?x ?det) -->
+  (Det ?agr ?x (and ?noun ?rel) ?det)
+  (Noun ?agr ?x ?noun)
+  (rel-clause ?agr ?x ?rel))
+
+(rule (rel-clause ?agr ?x t) --> )
+(rule (rel-clause ?agr ?x ?rel) -->
+  (:word that)
+  (VP ?agr ?x ?rel))
+
+(rule (Name 3sg Terry)                     --> (:word Terry))
+(rule (Name 3sg Jean)                      --> (:word Jean))
+(rule (Det 3sg  ?x ?restr (all ?x ?restr)) --> (:word every))
+(rule (Noun 3sg ?x (man ?x))               --> (:word man))
+(rule (Verb/tr 3sg ?x ?y (love ?x ?y))     --> (:word loves))
+(rule (Verb/intr 3sg ?x (lives ?x))        --> (:word lives))
+(rule (Det 3sg  ?x ?res (exists ?x ?res))  --> (:word a))
+(rule (Noun 3sg ?x (woman ?x))             --> (:word woman))
+
+;;; end grammar snippet
+
+;;; begin examples for last snippet
+
+(and (all ?4 (and (man ?4) t))
+     (and (love ?4 ?12) (exists ?12 (and (woman ?12) t)))) 
+
+;;; ==============================
+
+(and (all ?m (man ?m))
+     (exists ?w (wowan ?w))
+     (loves ?m ?w))
+
+;;; end examples
+
+;;; begin grammar snippet
+
+(rule (S ?g0 ?g2 (and ?np ?vp)) -->
+  (NP ?g0 ?g1 ?agr ?x ?np)
+  (VP ?g1 ?g2 ?agr ?x ?vp))
+
+(rule (VP ?g0 ?g1 ?agr ?x (and ?obj ?verb)) -->
+  (Verb/tr ?agr ?x ?o ?verb)
+  (NP ?g0 ?g1 ?any-agr ?o ?obj))
+
+(rule (VP ?g0 ?g0 ?agr ?x ?verb) -->
+  (Verb/intr ?agr ?x ?verb))
+
+(rule (NP ?g0 ?g0 ?agr ?name t) -->
+  (Name ?agr ?name))
+
+(rule (NP ?g0 ?g0 ?agr ?x ?det) -->
+  (Det ?agr ?x (and ?noun ?rel) ?det)
+  (Noun ?agr ?x ?noun)
+  (rel-clause ?agr ?x ?rel))
+
+(rule (NP (gap NP ?agr ?x) nogap ?agr ?x t) --> )
+
+(rule (rel-clause ?agr ?x t) --> )
+
+(rule (rel-clause ?agr ?x ?rel) -->
+  (:word that)
+  (S (gap NP ?agr ?x) nogap ?rel))
+
+;;; end grammar snippet
+
+;;; begin examples for last snippet
+
+Every man that __ loves a woman likes a person.
+(AND (ALL ?28 (AND (MAN ?28)
+                   (AND T (AND (LOVE ?28 ?30)
+                               (EXISTS ?30 (AND (WOMAN ?30)
+                                                T))))))
+     (AND (EXISTS ?39 (AND (PERSON ?39) T)) (LIKE ?28 ?39)))
+
+Every man that a woman loves __ likes a person.
+(AND (ALL ?37 (AND (MAN ?37)
+                   (AND (EXISTS ?20 (AND (WOMAN ?20) T))
+                        (AND T (LOVE ?20 ?37)))))
+     (AND (EXISTS ?39 (AND (PERSON ?39) T)) (LIKE ?37 ?39)))
+
+Every man that loves a bird that __ flies likes a person.
+(AND (ALL ?28 (AND (MAN ?28)
+                   (AND T (AND (EXISTS ?54
+                                  (AND (BIRD ?54)
+                                       (AND T (FLY ?54))))
+                               (LOVE ?28 ?54)))))
+     (AND (EXISTS ?60 (AND (PERSON ?60) T)) (LIKE ?28 ?60)))
+
+;;; end examples
+
+;;;; unifgram.dat                     -- 2003-05-16 07:22:24 -- pascal   ;;;;
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/unifgram.lisp norvig-paip-pjb/unifgram.lisp
--- norvig/unifgram.lisp	1997-02-05 07:39:59.000000000 +0100
+++ norvig-paip-pjb/unifgram.lisp	2012-06-20 11:05:39.000000000 +0200
@@ -22,7 +22,7 @@
 
 (defun make-dcg (head body)
   (let ((n (count-if (complement #'dcg-normal-goal-p) body)))
-    `(<- (,@head ?s0 ,(symbol '?s n))
+    `(<- (,@head ?s0 ,(simbol '?s n))
          .,(make-dcg-body body 0))))
 
 (defun make-dcg-body (body n)
@@ -40,13 +40,13 @@
                    (make-dcg-body (rest body) n)))
           ((dcg-word-list-p goal)
            (cons
-             `(= ,(symbol '?s n)
-                 (,@(rest goal) .,(symbol '?s (+ n 1))))
+             `(= ,(simbol '?s n)
+                 (,@(rest goal) .,(simbol '?s (+ n 1))))
              (make-dcg-body (rest body) (+ n 1))))
           (t (cons
                (append goal
-                       (list (symbol '?s n)
-                             (symbol '?s (+ n 1))))
+                       (list (simbol '?s n)
+                             (simbol '?s (+ n 1))))
                (make-dcg-body (rest body) (+ n 1))))))))
 
 (setf (get '==> 'rule-function) 'make-augmented-dcg)
@@ -155,9 +155,9 @@
   "Define this category as an automatic conjunction."
   (assert (eq ==> '==>))
   `(progn
-     (setf (get ',cat 'conj-cat) ',(symbol cat '_))
+     (setf (get ',cat 'conj-cat) ',(simbol cat '_))
      (rule (,cat ,@(butlast args) ?combined-sem) ==>
-       (,(symbol cat '_) ,@(butlast args) ,sem1)
+       (,(simbol cat '_) ,@(butlast args) ,sem1)
        (,conj-cat ,sem1 ?combined-sem))
      (rule (,conj-cat ,sem1 ,combined-sem) ==>
        ,conj
@@ -175,3 +175,4 @@
   "If this is a conjunctive predicate, return the Cat_ symbol."
   (get predicate 'conj-category))
 
+
diff --exclude '*TAGS' --exclude .git --exclude .svn --exclude CVS --exclude _darcs --exclude '*~' --exclude '*.x86f' --exclude '*.fasl' --exclude '*.fas' --exclude '*.lib' --exclude '*.[oa]' --exclude '*.so' --exclude '#*' --exclude '*.orig' --exclude '*.rej' -Naur norvig/waltz.dat norvig-paip-pjb/waltz.dat
--- norvig/waltz.dat	1970-01-01 01:00:00.000000000 +0100
+++ norvig-paip-pjb/waltz.dat	2003-11-25 23:52:51.000000000 +0100
@@ -0,0 +1,122 @@
+;;;; -*- Mode: Lisp; Syntax: Common-Lisp -*-
+;;;; Code from Paradigms of AI Programming
+;;;; Copyright (c) 1991 Peter Norvig
+
+;;;; Sample diagrams to label:
+
+(defdiagram cube
+  (a Y b c d)
+  (b W g e a)
+  (c W e f a)
+  (d W f g a)
+  (e L c b)
+  (f L d c)
+  (g L b d))
+
+(print-labelings (diagram 'cube))
+
+(print-labelings (ground (diagram 'cube) 'g 'd))
+
+(defdiagram cube-on-plate
+  (a Y b c d)
+  (b W g e a)
+  (c W e f a)
+  (d W f g a)
+  (e L c b)
+  (f Y d c i)
+  (g Y b d h)
+  (h W l g j)
+  (i W f m j)
+  (j Y h i k)
+  (k W m l j)
+  (l L h k)
+  (m L k i))
+
+(print-labelings (ground (diagram 'cube-on-plate) 'k 'm))
+
+(defdiagram poiuyt
+  (a L b g)
+  (b L j a)
+  (c L d l)
+  (d L h c)
+  (e L f i)
+  (f L k e)
+  (g L a l)
+  (h L l d)
+  (i L e k)
+  (j L k b)
+  (k W j i f)
+  (l W h g c))
+
+(print-labelings (diagram 'poiuyt))
+
+(defdiagram tower
+  (a Y b c d)    (n L q o) 
+  (b W g e a)    (o W y j n)
+  (c W e f a)    (p L r i)
+  (d W f g a)    (q W n s w)
+  (e L c b)      (r W s p x)
+  (f Y d c i)    (s L r q)
+  (g Y b d h)    (t W w x z)
+  (h W l g j)    (u W x y z)
+  (i W f m p)    (v W y w z)
+  (j Y h o k)    (w Y t v q)
+  (k W m l j)    (x Y r u t)
+  (l L h k)      (y Y v u o)
+  (m L k i)      (z Y t u v))
+
+(print-labelings (ground (diagram 'tower) 'l 'k))
+
+(defdiagram arch
+  (a W e b c)  (p L o q)
+  (b L d a)    (q T p i r)
+  (c Y a d g)  (r T j s q)
+  (d Y c b m)  (s L r t)
+  (e L a f)    (t W v s k)
+  (f T e g n)  (u L t l)
+  (g W h f c)  (v L 2 4)
+  (h T g i o)  (w W x 1 y)
+  (i T h j q)  (x L w z)
+  (j T i k r)  (y Y w 2 z)
+  (k T j l t)  (z W 3 x y)
+  (l T k m v)  (1 T n o w)
+  (m L l d)    (2 W v 3 y)
+  (n L f 1)    (3 L z 2)
+  (o W p 1 h)  (4 T u l v))
+
+(defdiagram arch
+  (a W e b c)  (p L o q)
+  (b L d a)    (q T p i r)
+  (c Y a d g)  (r T j s q)
+  (d Y c b m)  (s L r t)
+  (e L a f)    (t W u s k)    ; t-u not t-v
+  (f T e g n)  (u L t 4)      ; u-4 not u-l
+  (g W h f c)  (v L 2 4)
+  (h T g i o)  (w W x 1 y)
+  (i T h j q)  (x L w z)
+  (j T i k r)  (y Y w 2 z)
+  (k T j l t)  (z W 3 x y)
+  (l T k m 4)  (1 T n o w)    ; l-4 not l-v
+  (m L l d)    (2 W v 3 y)
+  (n L f 1)    (3 L z 2)
+  (o W p 1 h)  (4 T u l v))
+
+(print-labelings (ground (diagram 'arch) 'x 'z))
+
+(defdiagram arch
+  (a W e b c)  (p L o q)
+  (b L d a)    (q T p i r)
+  (c Y a d g)  (r T j s q)
+  (d W b m c)  (s L r t)      ; d is a W, not Y
+  (e L a f)    (t W u s k)    
+  (f T e g n)  (u L t 4)      
+  (g W h f c)  (v L 2 4)
+  (h T g i o)  (w W x 1 y)
+  (i T h j q)  (x L w z)
+  (j T i k r)  (y Y w 2 z)
+  (k T j l t)  (z W 3 x y)
+  (l T k m 4)  (1 T n o w)    
+  (m L l d)    (2 W v 3 y)
+  (n L f 1)    (3 L z 2)
+  (o W p 1 h)  (4 T u l v))
+
